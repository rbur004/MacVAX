/*System includes*/#include <quickdraw.h>#include <packages.h>#include <Resources.h>#include <FCntl.h>#include <Files.h>#include	<StandardFile.h>#include <errors.h>#include <strings.h>#include <string.h>#include <stdlib.h>#include <stdio.h>#define _VAXMACIO_C_#include 	"macio.h"#include 	"mmemory.h"#include	"vaxmacio.h"#include	"aprintf.h"#pragma segment VAXMACIOunsigned long open_mac_file(void){unsigned long i;			for(i = 0; i < NUMB_FDS; i++)		{			if(filedescriptors[i] == (MFILE *)0)			{				if((filedescriptors[i] = mopen("")) != (MFILE *)0)					return i+1;				else					return 0;			}		}		aprintf("Too many open files (%d)",NUMB_FDS);		return 0;}long find_mac_file(	char *ftype,	/* types of files to find*/	address dest	/*where in vax memory to put result*/){struct Point 			dlgOrigin;			/* dialogbox top left corner*/static SFReply			theReply;			/* Data returned from dialogbox*/short 					num;				/* number of file types*/SFTypeList 				types;				/* file types*/char					*p;			dlgOrigin.h = DLGLEFT;			dlgOrigin.v = DLGTOP;						for (p = (char *) types, num = 0; *ftype && num < 16; num++ )				*p++ = *ftype++;			num /= 4;			if(num == 0)				num = -1;	/*display any type*/				//			sfgetfile(&dlgOrigin,"", (FileFilterProcPtr) 0, num, types, (DlgHookProcPtr)0, &theReply);			sfgetfile(&dlgOrigin,"", 0, num, types, 0, &theReply);			if(theReply.good)			{					vax_putw(theReply.vRefNum,dest);				dest += sizeof(short);				copy_to_vaxmem(	dest, (char *)theReply.fName, (long) ((unsigned char) theReply.fName[0]) + 1 );				return 0;			}			else				return -1;}unsigned long open_named_mac_file(	address name){unsigned long i;char buff[256], *b;long j;long length;short vRefNum;								/*extract file name from vax space*/		vRefNum = vax_fetchw(name);		name += sizeof(short);		b = buff;		if((length = (char)vax_fetchb(name++) & BYTE_MASK) != '\0')		{				for(j = 0; j < length; j++)			{				if((*b++ = (char)vax_fetchb(name++)) == '\0')					break;			}		}		*b = '\0';#ifdef THISWEEK				/*find the vRefNum from the pathname*/		if((b = strrchr(buff,':')) != 0)		{			*b++ = '\0';			vRefNum = get_vRefNum(buff);		}		else#endif THISWEEK			b = buff;				for(i = 0; i < NUMB_FDS; i++)		{			if(filedescriptors[i] == (MFILE *)0)			{				if((filedescriptors[i] =  mopen_na(b, vRefNum)) != (MFILE *)0)					return i+1;				else					return 0;			}		}		aprintf("Too many open files (%d)",NUMB_FDS);		return 0;}unsigned long create_mac_file(	address name){unsigned long i;char buff[34], *b;long j;long length;				b = buff;		if((length = (char)vax_fetchb(name++) & BYTE_MASK) != '\0')		{	if(length > 32)				length = 32;			for(j = 0; j < length; j++)			{				if((*b++ = (char)vax_fetchb(name++)) == '\0')					break;			}		}		*b = '\0';				for(i = 0; i < NUMB_FDS; i++)		{			if(filedescriptors[i] == (MFILE *)0)			{				if((filedescriptors[i] = mcreat("Filename:", buff, 'EDIT','TEXT')) != (MFILE *)0)					return i+1;				else					return 0;			}		}		aprintf("Too many open files (%d)",NUMB_FDS);		return 0;}unsigned long close_mac_file(	unsigned long fd){MFILE *fp;	if(fd == 0 || fd > NUMB_FDS || (fp = filedescriptors[fd-1]) == (MFILE *)0)		return ERROR;	filedescriptors[fd - 1] = (MFILE *)0;	return(mclose(fp));}unsigned long read_mac_file(	unsigned long fd,	address dest,	unsigned long length){char buff[256];long numb_so_far = 0;long numb_to_do_this_time;long got;	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{	aprintf("Bad file descriptor %d", fd);		return 0;	}	while(numb_so_far < length)	{		/*break reads into 256 byte chunks*/		if((numb_to_do_this_time = length - numb_so_far) > 256)			numb_to_do_this_time = 256;					/*do read and test result*/		if((got = mread(filedescriptors[fd-1]->fd,buff,numb_to_do_this_time)) != numb_to_do_this_time)		{	/*failed to read number of bytes requested*/			numb_so_far += got;			/*return number of bytes read so far less any we couldn't copy to vax memory*/			return numb_so_far - copy_to_vaxmem(dest,buff,got);			}		else			numb_so_far += got;					if((got = copy_to_vaxmem(dest,buff,got)) != 0 )		{	/*copy to vax memory failed to copy all bytes*/			/*return number of bytes read so far less any we couldn't copy to vax memory*/			return numb_so_far - got;		}				/*inc the vax destination address*/		dest += numb_to_do_this_time;	}	return length;}	long copy_to_vaxmem(	/*returns number of chars NOT copied*/	address dest,	char *buff,	long got){unsigned long i;	for (i = 0; i < got; i++)	{		if(vax_putb(*buff++,dest++) == -1)		{				return( got - i );		}	}	return 0;	}	long write_mac_file(	unsigned long fd,	address src,	unsigned long length){char buff[256];long numb_so_far = 0;long numb_to_do_this_time;long sent;long fetched_from_vax;long exit_loop = 0;	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{	aprintf("Bad file descriptor %d", fd);		return 0;	}	while(numb_so_far < length && !exit_loop)	{		/*break writes into 256 byte chunks*/		if((numb_to_do_this_time = length - numb_so_far) > 256)			numb_to_do_this_time = 256;					/*copy data from vax memory to our buffer*/		if((fetched_from_vax = copy_from_vaxmem(src,buff,numb_to_do_this_time)) != numb_to_do_this_time)		{	/*unable to copy entire buffer*/			numb_to_do_this_time = fetched_from_vax;			exit_loop = 1;		}				if(fetched_from_vax == 0)			return numb_so_far;	/*couldn't copy any*/					/*do write and check we wrote it all*/		if((sent = mwrite(filedescriptors[fd-1]->fd,buff,numb_to_do_this_time)) != numb_to_do_this_time)		{	/*failed to write it all*/			numb_so_far += sent;			return numb_so_far;		}		numb_so_far += sent;				/*in src VAX address*/		src += sent;	}	return numb_so_far;}long copy_from_vaxmem(	/*returns number of chars copied*/	address src,	char *buff,	long length){unsigned long i;	for (i = 0; i < length; i++)	{		*buff++ = vax_fetchb(src++);		if(stop == 1)		{				return( i );		}	}	return i;	}long seek_mac_file(	unsigned long fd,	unsigned long offset,	long whence){	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{	aprintf("Bad file descriptor %d", fd);		return -1;	}	if(whence < 0 || whence > 2)	{		aprintf("Seek: bad value for mode (%d)",whence);	}	else		mlseek(filedescriptors[fd-1]->fd, offset, whence);	return(mlgetpos(filedescriptors[fd-1]->fd));}long get_pos_mac(	unsigned long fd){	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{	aprintf("Bad file descriptor %d", fd);		return -1;	}	return(mlgetpos(filedescriptors[fd-1]->fd));}void closeall_mac_files(void){short fd;	for(fd = 1; fd <= NUMB_FDS;fd++)		if(filedescriptors[fd-1] != (MFILE *)0)			(void)close_mac_file(fd);}long valid_fd(	unsigned long fd){	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{	aprintf("Bad file descriptor %d", fd);		return -1;	}	return 0;}MFILE *MFILE_mac(	unsigned long fd){	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)		aprintf("Bad file descriptor %d", fd);	return filedescriptors[fd-1];}	long get_mac_filename_fd(	/*copies the MFILE->name and MFILE->vrefnum to VAX memory dest*/	unsigned long fd,	address dest){long fname_length;	if(fd == 0 || fd > NUMB_FDS || filedescriptors[fd-1] == (MFILE *)0)	{		aprintf("Bad file descriptor %d", fd);		return -1;	}	else	{	/*write volume reference number*/		vax_putw(filedescriptors[fd-1]->vrefnum,dest);		dest += sizeof(short);		/*write file name as pascal string*/		fname_length = strlen(filedescriptors[fd-1]->name);		vax_putb((char) fname_length,dest++);		copy_to_vaxmem(	dest, filedescriptors[fd-1]->name, fname_length );		return 0;	}}void display_dialog(	address message){char buff[256];unsigned char length;		length = (unsigned char) vax_fetchb(message++);	copy_from_vaxmem(message,buff,length);	buff[length] = 0;	aprintf("%s",buff);}