#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include 	<memory.h>#include	<StdLib.h>#define _SETTINGS_C_#include 	"window.h"#include 	"mmemory.h"#include 	"main.h"#include	"globals.h"#include 	"settings.h"#include	"docmds.h"#include 	"sym.h"#include	"iow.h"#include	"aprintf.h"void savestate(	long restricted){long i;struct ss **t;short error = 0;GrafPtr savePort;	h_save_state = (struct ss **) NewHandle(sizeof( struct ss ));	HLock((Handle)h_save_state);	save_state = *h_save_state;		save_state->glob.hex_mem_dump = hex_mem_dump;	save_state->glob.restricted = restricted;	GetPort(&savePort);	for(i = 0; i < NumWindows; i++)	{		if(theActiveWindow == window[i].windowptr)			save_state->glob.active_window = i;		save_state->window[i].visible = ((WindowPeek) (window[i].windowptr))->visible;		save_state->window[i].txFont = (window[i].windowptr)->txFont;		save_state->window[i].txFace = (window[i].windowptr)->txFace;					save_state->window[i].txSize = (window[i].windowptr)->txSize;		ShowWindow(window[i].windowptr);		save_state->window[i].strucRect = (*((WindowPeek) (window[i].windowptr))->strucRgn)->rgnBBox;		save_state->window[i].contRect = (*((WindowPeek) (window[i].windowptr))->contRgn)->rgnBBox;		if(save_state->window[i].visible == false)			HideWindow(window[i].windowptr);	}	SetPort(savePort);	SelectWindow(theActiveWindow);	for(i = 0 ; i < 16; i++)		save_state->glob.reg_dis_mode[i] = vax_regs[i].dis_mode;	save_state->glob.hexmode = hexmode;	save_state->glob.symmode = symmode;	t = (struct ss **)GetResource(SAVESTATE_RESTYPE,SAVESTATE_RESID);	if(ResError() == 0)	{			if(t != 0)		{			if((*t)->glob.restricted != 0 ) 				save_state->glob.restricted = (*t)->glob.restricted;			if(CurResFile() == HomeResFile((Handle)t))			{				ChangedResource((Handle)t);				if((error = ResError()) == 0)				{					RmveResource((Handle)t);					if((error = ResError()) == 0)					{						UpdateResFile(CurResFile());						if((error = ResError()) != 0)							aprintf("Can't remove old copy\nerror = %d",error);						else							DisposHandle((Handle)t);					}					else					{						aprintf("Unable to Remove old resource\nerror = %d",error);					}				}				else				{					aprintf("Unable to alter resource\nerror = %d",error);				}			}			else			{				ReleaseResource((Handle)t);			}		}	}/*	if((!error) && (CurResFile() == appl_fd) && restricted)	{	aprintf("modifier ignored ");		save_state->glob.restricted = 0;	} */	HUnlock((Handle)h_save_state); 	if(!error)	{ 		AddResource((Handle)h_save_state,SAVESTATE_RESTYPE,SAVESTATE_RESID,(void *)"");		if((error = ResError()) == 0)		{			UpdateResFile(CurResFile());			if((error = ResError()) != 0)				aprintf("Resource update failed\nerror = %d",error);			else				DetachResource((Handle)h_save_state);		}			else			aprintf("Unable to Add resource\nerror = %d",error); 	}  	DisposHandle((Handle)h_save_state);}void restorestate(	long If_Res_in_Doc){short i;GrafPtr savePort;FontInfo finfo;short error;long num_saved_windows;	h_save_state = (struct ss **)GetResource(SAVESTATE_RESTYPE,SAVESTATE_RESID);	if(error = ResError())  //Yes 1 ='s	{	aprintf("Unable to restore state\nerror = %d",error);		return;	}	if(h_save_state == 0)	{		aprintf("NIl Resourse handle?");		return;	}	if (If_Res_in_Doc && secure_mode == 0) /*restore only if resource not from MacVAX and not secure_mode*/	{		if(HomeResFile((Handle) h_save_state) == appl_fd)		{			ReleaseResource((Handle)h_save_state);			return;		}	}		HLock((Handle)h_save_state);	hex_mem_dump = 0;	save_state = *h_save_state;	if((num_saved_windows = SizeResource((Handle)h_save_state)) == -1 )	{		aprintf("Unable to size Settings resource?");		exit(-1);	}	num_saved_windows = (num_saved_windows - sizeof(struct Global_settings)) / sizeof(struct PerWindow_Settings);		for(i = 0 ; i < 16; i++)		vax_regs[i].dis_mode = save_state->glob.reg_dis_mode[i];	hexmode = save_state->glob.hexmode;	setitem(MyMenus[optionMenu],hexaddrCommand,hexmode?"Dec Addresses":"Hex Addresses");	symmode = save_state->glob.symmode;	hex_mem_dump = save_state->glob.hex_mem_dump;	setitem(MyMenus[optionMenu],symmodeCommand,symmode ? "Non Symbolic Mode":"Symbolic Mode");	secure_mode = save_state->glob.restricted;	GetPort(&savePort);	for(i = 0; i < num_saved_windows; i++)	{			HideWindow(window[i].windowptr);		SetPort(window[i].windowptr);		TextFont(save_state->window[i].txFont);		TextFace(save_state->window[i].txFace);					TextSize(save_state->window[i].txSize);		MoveWindow(window[i].windowptr,save_state->window[i].strucRect.left,				save_state->window[i].strucRect.top + 19,false);		SizeWindow(window[i].windowptr,					save_state->window[i].contRect.right - save_state->window[i].contRect.left,					save_state->window[i].contRect.bottom - save_state->window[i].contRect.top, false);		MoveScrollBars(&window[i]);							 /*resize the scroll bars to fit*/		UsableRect(&window[i]);								/*calculate new usable area*/		GetFontInfo(&finfo);		window[i].forigin = finfo.descent + finfo.leading + 1;		window[i].leading = finfo.leading + 1;		window[i].lsize = finfo.ascent + window[i].forigin;		window[i].fsize = save_state->window[i].txSize;		if(window[i].topMargin > 1) /*tempory cludge. fix it sometime.*/			window[i].topMargin = window[i].lsize;		window[i].nlines = (window[i].usable.bottom - window[i].topMargin) / window[i].lsize ; /*calculate num lines*/		window[i].secure = 0;	/*if secure this gets fixed below*/		if(save_state->window[i].visible)		{			ShowWindow(window[i].windowptr);			SelectWindow(window[i].windowptr);			do_activate(&window[i],0);			if ( i == (dumphwID - progwID))				EnableItem(MyMenus[windowsMenu],memdumpCommand);			else if ( i == (physmemwID - progwID))				EnableItem(MyMenus[windowsMenu],physmemCommand);			else				EnableItem(MyMenus[windowsMenu],i+1);		}		else 		{			if(save_state->glob.restricted)			{					window[i].secure = 1;				if ( i == (dumphwID - progwID))					DisableItem(MyMenus[windowsMenu],memdumpCommand);				else if ( i == (physmemwID - progwID))					DisableItem(MyMenus[windowsMenu],physmemCommand);				else					DisableItem(MyMenus[windowsMenu],i+1);			}			else			{					if ( i == (dumphwID - progwID))					EnableItem(MyMenus[windowsMenu],memdumpCommand);				else if ( i == (physmemwID - progwID))					EnableItem(MyMenus[windowsMenu],physmemCommand);				else					EnableItem(MyMenus[windowsMenu],i+1);			}		}	}	iow_grow();	SetPort(savePort);	SelectWindow(window[save_state->glob.active_window].windowptr);	HUnlock((Handle)h_save_state);	ReleaseResource((Handle)h_save_state);}void open_prefs_file(void){/*open a resource file in the system folder (prefs folder)*//*to hold saved state and transfer strings */}void close_prefs_file(void){}