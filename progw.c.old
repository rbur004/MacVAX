#include	<quickdraw.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<memory.h>#define __PROGW_C_#include 	"window.h"#include 	"progw.h"#include 	"memory.h"#include 	"printins.h"#include	"execute.h"#include	"sym.h"#include 	"symbol_tab.h"#include	"docmds.h"#include	"wprintf.h"void progw_click(	Point *p,	short modifiers){address newdot;address to_addr;address tmp_addr;long i;long line;long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	if((line = (p->v  / progWindow.lsize)) > 0)		line--;	else		return;	/*loop until The address of the instruction clicked on is found*/	Was_case = 0;	newdot = progWindow.mbase;	for(i = 0; i <  line; i++)	{			if(printlabel(newdot) && ++i == line)		{	wdiscard();			break;		}		newdot = printins( newdot );		wdiscard();	}		if( (modifiers & optionKey) && !(modifiers & ~optionKey) )	{		/*update PC*/		PC = newdot;	}	else if((modifiers & (optionKey | shiftKey)) && !(modifiers & ~(optionKey | shiftKey)) )	{		printins( newdot );		wdiscard();		display_comment();	}	else if(modifiers & cmdKey)	{		/*will put follow branch in here*/		printins( newdot );		wdiscard();		if ((modifiers & optionKey) && !( modifiers & ~(optionKey | cmdKey) ) )		{			tmp_addr = progWindow.mbase;			put_at_top_progwindow(last_top_of_progw);			last_top_of_progw = tmp_addr;		}		else if((to_addr = get_branch_dest()) != U_MAX_LONG)		{			draw_pointer_to_address(line,to_addr);			while(Button());			if((modifiers & shiftKey) && !( modifiers & ~(shiftKey | cmdKey)) )			{					last_top_of_progw = progWindow.mbase;				put_at_top_progwindow(to_addr);			}		}	}	else	{		if(progw_selection_point == newdot)			progw_selection_point = -1;		else			progw_selection_point = newdot;	}	update_prog_reg_display();		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}address get_c_pos_p(	/* Return address of the cursor */	/* returns ERROR if cursor == nil  */	void){	return (address) progw_selection_point;}void progw_keypress(	long key){#pragma unused(key)	SysBeep(5);}void progw_undo_keypress(void){	SysBeep(5);}BitMap  Bfinger;Handle	Hfinger;#define FINGER	256#pragma segment Initializevoid init_finger(void){	Hfinger = (Handle) GetCursor(FINGER)	;	MoveHHi(Hfinger);	HLock(Hfinger);	Bfinger.baseAddr = *Hfinger;	Bfinger.rowBytes = 2;	SetRect(&Bfinger.bounds,0,0,16,16);}#pragma segment Mainvoid put_PC_in_progwindow(void){register address olddot;register long i;register long j = ((progWindow.nlines/2)  + 1);long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	Was_case = 0;	if(PC >= dot || PC < progWindow.mbase)	{			if(new_pc == PC && progWindow.nlines > 2) /*we haven't branched*/		{			if(old_pc < dot && old_pc >= progWindow.mbase)			{				for(i =  0 ; i < j ; i++)				{					olddot = progWindow.mbase;					if( printlabel(olddot) && ++i == j)					{						wdiscard();						break;					}		 			progWindow.mbase += printins( olddot ) - olddot;					wdiscard();				}			}			else				progWindow.mbase = old_pc;		}		else			progWindow.mbase = PC;	}		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}static long last_dot = 0; /*First address of next page*/void update_prog_window(void){long newdot;RgnHandle	hold_h;long i;long j;short header = progWindow.lsize - progWindow.forigin;register short line_size = progWindow.lsize;register short v = line_size + line_size;	register short column1;short column1_5;register short column2;Rect r;		/*general purpose clip rect*/Rect r2;	/*clip rect for address column*/Rect e;Rect e2;Rect progw_cursor_r;Rect rfinger;GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;long	printed;			if( ((WindowPeek) (progWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(progWindow.windowptr);		exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;		column1 = CharWidth('0') * 12 + 5;	column1_5 = column1 + 14;	column2 = column1_5 + CharWidth('0') * 4;		Was_case = 0;	r = progWindow.usable;	hold_h = NewRgn();	GetClip(hold_h);		newdot = progWindow.mbase;	MoveTo(4, header);	r.right = column1  - CharWidth('0');	ClipRect(&r);	DrawString((void *)"\p    Addr");		MoveTo(column1 + CharWidth('0'),header);	ClipRect(&progWindow.usable);	DrawString((void *)"\p    Instruction");		MoveTo(4,line_size - 1);	PenSize(1,2);	Line(progWindow.usable.right,0);		PenSize(2,1);	MoveTo(column1 - CharWidth('0') ,0);	Line(0, progWindow.usable.bottom);		PenNormal();		r.top = line_size + 2;	rfinger.left   = column1;	rfinger.right  = column1 + 14;	rfinger.top    = r.top;	rfinger.bottom = progWindow.usable.bottom;		EraseRect(&rfinger);	/*zap current copy of finger*/		r2.top    = r.top;		/*clip rect for address column*/	r2.bottom = r.bottom;	r2.left   = 3;	r2.right  = column1  - CharWidth('0') - 2;		r.left   = column1;	r.bottom = progWindow.usable.bottom;	r.right  = progWindow.usable.right;		progw_cursor_r.left 	=  3;	/*fixed init part for highlight rect*/	progw_cursor_r.right 	=  r2.right - 2;		e.right = progWindow.usable.right;		e2.left  	= column1_5;	e2.right 	= column2;	for(i = 0, j = progWindow.nlines ; i <= j; i++)	{		dot = newdot;		ClipRect(&r);		MoveTo(column1_5 ,v);				saw_watch_point = 0;				printed = printlabel(dot);		wflush();				if(printed)		{			/*clear to end of line*/			e.left = (qd.thePort)->pnLoc.h;			e.bottom =  v + 3; /*(qd.thePort)->pnLoc.v + progWindow.forigin;*/			e.top = e.bottom - line_size; /*- 1*/			e.bottom -= progWindow.leading;			EraseRect(&e);						/*clear address field*/			progw_cursor_r.bottom 	=  v + 3;						progw_cursor_r.top		=  progw_cursor_r.bottom - line_size;			progw_cursor_r.bottom 	-= progWindow.leading;			ClipRect(&r2);			EraseRect(&progw_cursor_r);			ClipRect(&r);						v += line_size;			i++;		}		/*clear to end of column*/		e2.bottom 	=  v + 3;					e2.top		=  e2.bottom - line_size;		e2.bottom	-= progWindow.leading;		EraseRect(&e2);		if(dot == PC)		{			rfinger.top 	= v - 14;			rfinger.bottom 	= v + 2;						CopyBits( &Bfinger, &(progWindow.windowptr->portBits),					&Bfinger.bounds, &rfinger,srcOr,(RgnHandle)0);/*draw new one*/		}				MoveTo(column2,v);				newdot = printins( dot );		wflush();				e.left = (qd.thePort)->pnLoc.h;		e.bottom =  v + 3; /*(qd.thePort)->pnLoc.v + progWindow.forigin;*/		e.top = e.bottom - line_size ;/*- 1;*/		e.bottom -= progWindow.leading;		EraseRect(&e);		MoveTo( 1 ,v);		ClipRect(&r2);		wprintf(hexmode ? " 0x%8.8x":" %10.10u",dot);		wflush();		if(dot == progw_selection_point || saw_watch_point)		{			progw_cursor_r.bottom 	=  v + 3;						progw_cursor_r.top		=  progw_cursor_r.bottom - line_size;			progw_cursor_r.bottom 	-= progWindow.leading;			if(dot == progw_selection_point)				InvertRect(&progw_cursor_r);			if(saw_watch_point)				FrameRect(&progw_cursor_r);		}					v += line_size;	}	SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	last_dot = dot;	displaymode = 0;}void activate_prog_window(	long is_active){/*	if(is_active)		update_prog_window(); */}/* macro that detects whether an address starts an instruction or not. */#define INS_START(address,base,limit) ((address > limit) || \	bit_map[(address-base)>>3] & (1 << ((address-base) & 0x7)))void progw_scroll(	short dh,	short dv){#pragma unused(dh)address olddot;/* current process == viewed process? */Symbol_Table_Type *st;char *bit_map;unsigned long base;unsigned long limit;long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	if (current_process == 0) {		bit_map = 0;	/* turn off reverse scrolling */		limit = -1;	/* no limit really */		base = 0;	/* and no point in them anyway since they will be ignored */		}	else {		if(progWindow.mbase >= S_SPACE)			st = sys_process;		else			st = current_process;				bit_map = st->bit_map;		base = st->txtmap.b1;	/* is this dodgy? */		limit = st->txtmap.e1;	}		/* aprintf("bit map = %x, base = %x dv = %d",bit_map,base,dv); */		Was_case = 0;		if(dv < 0)		{			if(down_a_byte) /*set in ScrollDown()*/			{				down_a_byte = 0;				progWindow.mbase++;			}			else if(down_an_instruction) /*set in ScrollDown()*/			{				down_an_instruction = 0;				olddot = progWindow.mbase;				printlabel(olddot);		 		progWindow.mbase += printins( olddot ) - olddot;				wdiscard();			}			else /*must be page down*/			{		 		progWindow.mbase = last_dot;			}						}		else if(dv > 0)		{				if(up_a_byte) /*set in ScrollUp()*/			{				up_a_byte = 0;				if(progWindow.mbase-- == 0)					progWindow.mbase = 0;			}			else if(up_an_instruction) /*set in ScrollUp()*/			{				if (progWindow.mbase !=base && bit_map!=0) {					unsigned long new_dot = progWindow.mbase-1;										up_an_instruction = 0;					/*Calculate Previous Instruction*/					for(;new_dot!=base;new_dot--)					if (INS_START(new_dot,base,limit)) break;					progWindow.mbase = new_dot;				}			}			else /*must be page scroll up*/			{				/* aprintf("bit map = %x, base = %x mbase = %x",bit_map,base,progWindow.mbase); */				if (progWindow.mbase !=base && bit_map!=0) {					/* Calculate one page back */					/* go up an instruction nline times */					unsigned long new_dot = progWindow.mbase;					int nln;										for(nln=0;nln!=progWindow.nlines && new_dot!=base;nln++) {						/* find the start of an instruction */						while (--new_dot != base && !INS_START(new_dot,base,limit));						}				/*	aprintf("Returning to location %x. %d lines back, limit=%x",new_dot,nln,limit); */					progWindow.mbase = new_dot;				}			}		}		update_prog_reg_display();		SetCtlValue(progWindow.vScroll,1);		progWindow.theOrigin.v = 1;			stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void draw_pointer_to_address(	short from, /*line*/	address to /*line*/){address tmpdot;long i;short top;short bottom;GrafPtr savePort;Rect r;		/*general purpose clip rect*/register short column1;register short line_size = progWindow.lsize;RgnHandle	hold_h;long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	if( ((WindowPeek) (progWindow.windowptr))->visible == false )		return;	hold_h = NewRgn();	GetClip(hold_h);	GetPort(&savePort);	SetPort(progWindow.windowptr);		r = progWindow.usable;	r.top = line_size + 2;		column1 = CharWidth('0') * 12 + 5;		top = (line_size * from) + line_size / 2 + r.top; /*halfway through line*/		if(to > last_dot) /*draw to end of screen*/		bottom = r.bottom;	else if ( to < progWindow.mbase) /*draw to beginning of screen*/		bottom = r.top;	else /*on screen*/	{		/*loop until The address of the instruction clicked on is found*/		Was_case = 0;		tmpdot = progWindow.mbase;		for(i = 0; tmpdot <  to; i++)		{				if(printlabel(tmpdot))			{	i++;			}			tmpdot = printins( tmpdot );			wdiscard();		}		bottom = (line_size * i) + line_size/2 + r.top; /*halfway through line*/	}	ClipRect(&r);	PenSize(2,1);	MoveTo(column1 + 4,top);	Line(0, bottom - top);	PenNormal();		SetClip(hold_h);	SetPort(savePort);		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void put_at_top_progwindow(	address b){register long j = ((progWindow.nlines/2)  + 1);	Was_case = 0;	progWindow.mbase = b ;	update_prog_reg_display();}void progw_init(void){	SetCtlMax(progWindow.vScroll, 2); 	SetCtlMin(progWindow.vScroll, 0); 	SetCtlValue(progWindow.vScroll,1);	SetCtlMax(progWindow.hScroll, NUMBER_PROGS - 1); 	SetCtlMin(progWindow.hScroll, 0); 	SetCtlValue(progWindow.hScroll,0);	progWindow.theOrigin.v = 1;	progWindow.mbase = 0;}void dec_process_displayed(void){#ifdef TEST_CNTRLshort i = GetCtlValue(progWindow.hScroll);	if(i == 0)		SetCtlValue(progWindow.hScroll, NUMBER_PROGS - 1);	else		SetCtlValue(progWindow.hScroll,i - 1);#endif}void inc_process_displayed(void){#ifdef TEST_CNTRLshort i = GetCtlValue(progWindow.hScroll);	if(i == NUMBER_PROGS - 1)		SetCtlValue(progWindow.hScroll, 0);	else		SetCtlValue(progWindow.hScroll,i + 1);#endif}void set_displayed_process_number(short i){	SetCtlValue(progWindow.hScroll,i);}