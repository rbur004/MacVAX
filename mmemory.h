#ifndef MEMORY_H#define MEMORY_H#ifndef GLOBALS_H#include        "globals.h"#endiftypedef char byte;						/* 8 bits signed */typedef short word;						/* 16 bits signed *//*long*/								/* Longs already ok at 32 bits.*/typedef struct { 	long 			long1; 	unsigned long 	long0;} quad;typedef struct { 	long 			long3; 	unsigned long 	long2;	unsigned long 	long1;	unsigned long 	long0;} oct;typedef unsigned long address;			/* 32 bit virtual address. */typedef union{	unsigned long f;	struct	{		unsigned long fract2:8;		unsigned long fract3:8;		unsigned long sign:1;		unsigned long exponent:8;		unsigned long fract_1:7;	}f_bb;} v_float;extern quad quad_zero;	/*so we can assigne zero to a quad*/#define DEFINES#ifdef DEFINES#define NIBBLE_MASK		((unsigned long) 0x0000000Fu )#define HI_NIBBLE_MASK	((unsigned long) 0x000000F0u )#define BYTE_MASK		((unsigned long) 0x000000FFu )#define HI_BYTE_MASK	((unsigned long) 0x0000FF00u )#define WORD_MASK		((unsigned long) 0x0000FFFFu )#define HI_WORD_MASK	((unsigned long) 0xFFFF0000u )#define LONGWORD_MASK	((unsigned long) 0xFFFFFFFFu )#elseunsigned long  NIBBLE_MASK	=	((unsigned long) 0x0000000Fu );unsigned long  HI_NIBBLE_MASK = ((unsigned long) 0x000000F0u );unsigned long  BYTE_MASK	=	((unsigned long) 0x000000FFu );unsigned long  HI_BYTE_MASK	=	((unsigned long) 0x0000FF00u );unsigned long  WORD_MASK	=	((unsigned long) 0x0000FFFFu );unsigned long HI_WORD_MASK  =	((unsigned long) 0xFFFF0000u );unsigned long LONGWORD_MASK =	((unsigned long) 0xFFFFFFFFu );#endif#ifdef DEFINES#define 		BYTE_HI_BIT		((unsigned char) 0x00000080u)#define 		WORD_HI_BIT		((unsigned short) 0x00008000u)#define			LONG_HI_BIT		((unsigned long) 0x80000000u)#elseunsigned char	BYTE_HI_BIT	=	((unsigned char)  0x00000080u);unsigned short 	WORD_HI_BIT	=	((unsigned short) 0x00008000u);unsigned long	LONG_HI_BIT	=	((unsigned long)  0x80000000u);#endif#ifdef DEFINES#define S_MIN_BYTE ((char)  0x80u)			/* - ( 2 pow 7 ) */#define S_MIN_WORD ((short) 0x8000u)		/* - ( 2 pow 15 ) */#define S_MIN_LONG ((long)  0x80000000u)  	/* - ( 2 pow 31 ) */#define S_MAX_BYTE ((char)  0x7f)			/* 2 pow 7 -1 */#define S_MAX_WORD ((short) 0x7fff)			/* 2 pow 15 -1 */#define S_MAX_LONG ((long)  0x7ffffff)		/* 2 pow 31 -1 */#define U_MAX_BYTE ((unsigned char)  0xffu)			/* 2 pow 8 -1 */#define U_MAX_WORD ((unsigned short) 0xffffu)		/* 2 pow 16 -1 */#define U_MAX_LONG ((unsigned long)  0xffffffffu)	/* 2 pow 32 -1 */#elsechar 	S_MIN_BYTE	= 0x80;					/* - ( 2 pow 7 ) */short	S_MIN_WORD	= 0x8000;				/* - ( 2 pow 15 ) */long 	S_MIN_LONG	= 0x80000000 ; 	   		/* - ( 2 pow 31 ) */char 	S_MAX_BYTE	= 0x7f	;				/* 2 pow 7 -1 */short 	S_MAX_WORD	= 0x7fff;				/* 2 pow 15 -1 */long 	S_MAX_LONG	= 0x7ffffff;			/* 2 pow 31 -1 */unsigned char	U_MAX_BYTE = 0xff;			/* 2 pow 8 -1 */unsigned short	U_MAX_WORD = 0xffff;		/* 2 pow 16 -1 */unsigned long	U_MAX_LONG = 0xffffffff;	/* 2 pow 32 -1 */#endif#ifdef DEFINES#define		 ERROR		0xffffffffu#elseunsigned long ERROR	=	0xffffffffu;#endiftypedef struct{		union	{		v_float			as_v_float;		long			as_long;		unsigned long 	as_ulong;		address			as_address;		short			as_short[2];		unsigned short	as_ushort[2];		char			as_char[4];		unsigned char	as_uchar[4];	} contents;		char dis_mode;} reg_type;#define as_byte	as_char[3]#define as_word	as_short[1]extern reg_type	vax_regs[48];		/*16 usual regs and 32 temp regs*/#ifdef DEFINES#define REGBASE		((unsigned long)0xC0000000)		/*Memory addresses from REGBASE to REGBASE + 15 are interpreted by fetchx as the register*/#define TEMPREGS	((unsigned long)0xC0000010)		/*Memory addresses from TEMPREGS to TEMPREGS + 15 are interpreted by fetchx as a tempory register*/#define REG_MASK	((unsigned long)0x0000001F)#define AFREESPOT	((unsigned long)0xC000001F)#elseaddress REGBASE		= 0xC0000000;		/*Memory addresses from REGBASE to REGBASE + 15 are interpreted by fetchx as the register*/address TEMPREGS	= 0xC0000010;		/*Memory addresses from TEMPREGS to TEMPREGS + 15 are interpreted by fetchx as a tempory register*/unsigned long REG_MASK	= 0x0000001F;address AFREESPOT	= 0xC000001F;#endif#define FREESPOT	vax_regs[0x1F].contents.as_ulong#define R0	vax_regs[0].contents.as_ulong #define R1	vax_regs[1].contents.as_ulong #define R2	vax_regs[2].contents.as_ulong  #define R3	vax_regs[3].contents.as_ulong  #define R4	vax_regs[4].contents.as_ulong  #define R5	vax_regs[5].contents.as_ulong  #define R6	vax_regs[6].contents.as_ulong  #define R7	vax_regs[7].contents.as_ulong #define R8	vax_regs[8].contents.as_ulong  #define R9	vax_regs[9].contents.as_ulong  #define R10	vax_regs[10].contents.as_ulong  #define R11	vax_regs[11].contents.as_ulong  #define R12	vax_regs[12].contents.as_ulong #define R13	vax_regs[13].contents.as_ulong  #define R14	vax_regs[14].contents.as_ulong  #define R15	vax_regs[15].contents.as_ulong  #define AP	vax_regs[12].contents.as_ulong  #define FP	vax_regs[13].contents.as_ulong  #define SP	vax_regs[14].contents.as_ulong  #define PC	vax_regs[15].contents.as_ulong  #ifdef DEFINES#define AP_ADDR	((unsigned long)0xC000000C )#define FP_ADDR	((unsigned long)0xC000000D )#define SP_ADDR	((unsigned long)0xC000000E )#define PC_ADDR	((unsigned long)0xC000000F )#elseaddress AP_ADDR	= 0xC000000C ;address FP_ADDR	= 0xC000000D ;address SP_ADDR	= 0xC000000E ;address PC_ADDR	= 0xC000000F ;#endifextern address opaddr[ MAXARGS ];	/* The operands. */#define DECIMAL		0x01#define HEXIDECIMAL	0x02#define INSTRUCTION 0x03typedef union{	unsigned long	psl_as_int;			/*bits 1-32*/	struct 	{			unsigned long cm:1;			/*bit 31*/		unsigned long tp:1;			/*bit 30*/		unsigned long mbz2:2;			/*bit 28 - 29*/		unsigned long fpd:1;			/*bit 27*/		unsigned long is:1;			/*bit 26*/		unsigned long cnt_mode:2;		/*bits 24-25*/		unsigned long prev_mode:2;	/*bits 22-23*/		unsigned long mbz:1;			/*bit 21*/		unsigned long ipl:5;			/*bits 16 - 20*/		unsigned long unused:8;		/*bits 8 - 15 reserved*/		unsigned long dvflag:1;		/*bit 7*/		unsigned long fuflag:1;		/*bit 6*/		unsigned long ivflag:1;		/*bit 5*/		unsigned long tflag:1;		/*bit 4*/		unsigned long nflag:1;		/*bit 3*/		unsigned long zflag:1;		/*bit 2*/		unsigned long vflag:1;		/*bit 1*/		unsigned long cflag:1;		/*bit 0*/	}psl_by_bit;	struct	{		unsigned short	top_half;		unsigned short 	bottom_half;	} psl_by_word;} psl_type;extern psl_type psl;#define vax_psl (psl.psl_as_int)#define C	(psl.psl_by_bit.cflag)		/* C flag. */#define V	(psl.psl_by_bit.vflag)		/* V flag. */#define Z	(psl.psl_by_bit.zflag)		/* Z flag. */#define N	(psl.psl_by_bit.nflag)		/* N flag. */#define T	(psl.psl_by_bit.tflag)		/* T flag. */#define IV	(psl.psl_by_bit.ivflag)		/* IV flag. */#define FU	(psl.psl_by_bit.fuflag)		/* FU flag. */#define DV	(psl.psl_by_bit.dvflag)		/* DV flag. */#define PSW	(psl.psl_by_word.bottom_half)		/* psw  */#define PSL (psl.psl_as_int)	/*whole thingo*/#define CM	(psl.psl_by_bit.cm)		/* PDP11 emulation mode*/#define TP	(psl.psl_by_bit.tp)		/* Trace pending*/#define FPD	(psl.psl_by_bit.fpd)	/* First Part Done*/#define IS	(psl.psl_by_bit.is)		/* using interrupt stack*/#define CMD	(psl.psl_by_bit.cnt_mode)		/* current mode*/#define PMD	(psl.psl_by_bit.prev_mode)		/* previous mode*/#define IPL (psl.psl_by_bit.ipl)	/*interrupt priority level*/#define CARRY		0x00000001#define OVERFLOW	0x00000002#define ZERO		0x00000004#define NEGATIVE	0x00000008#define TRACE		0x00000010#define IOFTRAP		0x00000020	/*integer overflow*/#define FUFTRAP		0x00000040	/*float underflow*/#define DOFTRAP		0x00000080	/*dec overflow*/#define MAX_PAGES 512						/* maximimum number of pages */#define PAGE_SIZE 0x200						/* page size in bytes must be power of 2 */#define PAGE_MASK 0x1FFFFFtypedef union virtual_address{	address v_address;	struct		{		unsigned long space:2;	/*4 address spaces*/		unsigned long page: 21;	/*lots of pages*/		unsigned long offset: 9;	/*512 bytes per page*/	} decoded_addr;} virtual_address;#ifdef DEFINES#define PAGE_NUMBER_MASK	((unsigned long) ~0xC00001FF)#define SPACE_MASK			((unsigned long)  0xC0000000)#elseunsigned long PAGE_NUMBER_MASK	=	((unsigned long) ~0xC00001FF);unsigned long SPACE_MASK		=	((unsigned long)  0xC0000000);#endif#define OFFSET_MASK			((unsigned long)  0x000001FF)#define PAGE_LENGTH_MASK	((unsigned long)  0x003FFFFF)#define Physical_Address_Mask 0x00FFFFFF#define P0 0								/* program region */#define P1 1								/* control region */#define S0 2								/* system region */#define R  3								/*unused*/#ifdef DEFINES#define PO_SPACE	((unsigned long) 0x00000000)	/* program region */#define P1_SPACE	((unsigned long) 0x40000000)	/* control region */#define S_SPACE		((unsigned long) 0x80000000)	/* system region */#define R_SPACE		((unsigned long) 0xC0000000)#define PO_SPACE_C	PO_SPACE	/* program region */#define P1_SPACE_C	P1_SPACE	/* control region */#define S_SPACE_C	S_SPACE  /* system region */#define R_SPACE_C	R_SPACE#elseaddress PO_SPACE =	0x00000000;	/* program region */address P1_SPACE =	0x40000000;	/* control region */address S_SPACE	 =	0x80000000;  /* system region */address R_SPACE	 =	0xC0000000;#define PO_SPACE_C	0x00000000	/* program region */#define P1_SPACE_C	0x40000000	/* control region */#define S_SPACE_C	0x80000000  /* system region */#define R_SPACE_C	0xC0000000#endiftypedef struct { 	unsigned long valid:1;	unsigned long protection:4;	unsigned long modified:1;			unsigned long mbz:1;	unsigned long own:2;	unsigned long s:2;	unsigned long pfn:21;} real_page_entry;#define NUM_PAGE_FRAMES 512		/*256K of memory*/#define REAL_MEM_SIZE	(NUM_PAGE_FRAMES << 9)#define NUM_P0_PTE_PAGES	3#define NUM_P1_PTE_PAGES	2#define NUM_S_PTE_PAGES		1#define TOTAL_P1_PAGES  	0x200000	/* 2**30 / PAGE_SIZE. Number of pages free in P1 space */#define MAX_PAGE_TABLE_SIZE	0x800000	/* 0x800000 = 2**30 / PAGE_SIZE * sizeof(pte) */typedef struct vax_mem_struct{	unsigned char *real_memory;	unsigned char *watchmap;}vax_mem_type;#define VAX_MEM_SIZE ((REAL_MEM_SIZE >> 3) + REAL_MEM_SIZE)/*Given a VAX Physical address return a mac address*/#define VAX2MAC_address(a)	(vax_mem.real_memory + (a))#define NA			0	/*no access*/#define RE			1	/*reserved*/#define KW			2	/*kernel read/write*/#define KR			3	/*kernel read only*/#define UW			4	/*user,sup,exec,kern read/write*/#define EW			5	/*exec,kern read/write*/#define ERKW		6	/*exec read only; kern read/write*/#define ER			7	/*exec,kern read only*/#define SW			8	/*sup,exec,kern read/write*/#define SREW		9	/*sup read only; exec,kern read/write*/#define SRKW	   10	/*sup,exec read only; kern read write*/#define SR		   11	/*sup,exec,kern read only*/#define URSW	   12	/*user read only; sup,exec,kern read/write*/#define UREW	   13	/*user,sup read only; exec,kern read/write*/#define URKW	   14	/*user,sup,exec read only; kern read/write*/#define UR		   15	/*user,sup,exec,kern read only*/#define E_KR		1	/*expanded kernel read*/#define E_KW		2	/*expanded kernel read*/#define E_ER		4	/*expanded executive read*/#define E_EW		8	/*expanded executive read*/#define E_SR		16	/*expanded supervisor read*/#define E_SW		32	/*expanded supervisor read*/#define E_UR		64	/*expanded user read*/#define E_UW		128	/*expanded user read*/#ifdef MEMORY_Cunsigned char expanded_protection[16] ={	0, 	0,	E_KR | E_KW,	E_KR,	E_KR | E_KW | E_ER | E_EW | E_SR | E_SW | E_UR | E_UW,	E_KR | E_KW | E_ER | E_EW,	E_KR | E_KW | E_ER,	E_KR | E_ER,	E_KR | E_KW | E_ER | E_EW | E_SR | E_SW,	E_KR | E_KW | E_ER | E_EW | E_SR,	E_KR | E_KW | E_ER | E_SR,	E_KR | E_ER | E_SR,	E_KR | E_KW | E_ER | E_EW | E_SR | E_SW | E_UR,	E_KR | E_KW | E_ER | E_EW | E_SR | E_UR,	E_KR | E_KW | E_ER | E_SR | E_UR,	E_KR | E_ER | E_SR | E_UR};#elseextern unsigned char expanded_protection[16];	#endif#define EXTRACT_PERM(mode,prot)	((expanded_protection[prot] >> (mode << 1)) & 0x3) #define TEST_PERM(mode,prot,rw)	(expanded_protection[prot] & (rw <<  (mode << 1)))#define RD			1	/*used when want to attempt a read*/#define WR			2	/*used when want to attemp a write*/extern long nf_temp_reg;/*internal processor registers*/#define KSP	 0x0	/*Kernel Stack pointer*/#define ESP	 0x1	/*Executive Stack pointer*/#define SSP	 0x2	/*Supervisor Stack pointer*/#define USP	 0x3	/*User Stack pointer*/#define ISP	 0x4	/*Interrupt Stack pointer*//*0x5, 0x7 reserved*/#define P0BR 0x8	/*P0 base register*/#define P0LR 0x9	/*P0 length register*/#define P1BR 0xA	/*P1 base register*/#define P1LR 0xB	/*P1 length register*/#define SBR	 0xC	/*system base register*/#define SLR	 0xD	/*system length register*//*0xE, 0xF reserved*/#define PCBB 0x10 	/*process control block base */#define SCBB 0x11 	/*system control block base (physical address)*/#define IPLR 0x12 	/*interrupt priority level*/#define ASTR 0x13 	/*Async Trap level*/#define SIRR 0x14	/*software interrupt request register*/#define SISR 0x15	/*software interrupt summary register*//*0x16 reserved*/#define MCSR 0x17 	/*Machine Check Status register*/#define ICCS 0x18	/*interval clock control/status register*/#define NICR 0x19 	/*next interval count register*/#define ICR  0x1A 	/*interval count register*/#define TODR 0x1B 	/*time of year*/#define CSRS 0x1C 	/*TU58 Control Storage Receive Status*/#define CSRD 0x1D 	/*TU58 Control Storage Receive Data*/#define CSTS 0x1E 	/*TU58 Control Storage Transmit Status*/#define CSTD 0x1F	/*TU58 Control Storage Transmit Data*/#define RXCS 0x20 	/*Console Receive Control/Status */#define RXDB 0x21 	/*Console Receive Data Buffer*/#define TXCS 0x22 	/*Console Transmit Control/Status */#define TXDB 0x23 	/*Console Transmit Data Buffer*/#define TBDR 0x24	/*Translation buffer disable Register*/#define CADR 0x25	/*Cash disable Register*/#define MCESR 0x26 	/*Machine Check Error Summary register*/#define CAER 0x27	/*Cash Error Register*/#define ACCS 0x28	/*Accelerator Control/Status*//*0x29 - 0x36 reserved*//*Fake internal processor registers*/#define MVCR  0x29	/*MacVAX Command register*/#define MVCS  0x2A	/*MACVAX Command Status Register*/#define MVPID 0x2B	/*MACVAX Process descriptor for symbol table info*/#define MVMEM 0x2C	/*MACVAX Available physical memory (Read only)*//*more macvax registers for display use in the stack window*/#define KFP	 0x32	/*Kernel Frame pointer: Read Only, for use in displaying stacks*/#define EFP	 0x33	/*Executive Frame pointer: Read Only, for use in displaying stacks*/#define SFP	 0x34	/*Supervisor Frame pointer: Read Only, for use in displaying stacks*/#define UFP	 0x35	/*User Frame pointer: Read Only, for use in displaying stacks*/#define IFP	 0x36	/*Interrupt Frame pointer: Read Only, for use in displaying stacks*//**/#define IORST 0x37	/*Initialize UNIBUS*/#define MME 0x38 	/*MAPEN Memory Management Enable */#define TBIA 0x39	/*Translation buffer Invalidate all Register*/#define TBIS 0x3A	/*Translation buffer Invalidate Single Register*/#define TBD 0x3B	/*Translation buffer Register*//*0x3C reserved*/#define PMR 0x3D	/*Performance Monitor Register*/#define SID 0x3E	/*System Identification Register*/#define TBHP 0x3F	/*Probe Translation Buffer for TB Hit*/#define NUM_IPRS 0x40	/*number of Internal Processor Registers*/extern reg_type ipr[NUM_IPRS];#define IPR(x)	ipr[x].contents.as_ulong /*Clock Status register defines*/#ifdef DEFINES#define ICCS_ERR_BIT 		((unsigned long)0x80000000u)#elseunsigned long ICCS_ERR_BIT = 0x80000000u;#endif#define ICCS_MBZ_BITS 		0x7fffff0e#define ICCS_INT_BIT 		0x00000080#define ICCS_INT_ENB_BIT 	0x00000040#define ICCS_SGL_BIT		0x00000020#define ICCS_XFR_BIT		0x00000010#define ICCS_RUN_BIT		0x00000001#define ICCS_ERR(x) 	((x) & ICCS_ERR_BIT)#define ICCS_MBZ(x) 	((x) & ICCS_MBZ_BITS)#define ICCS_INT(x) 	((x) & ICCS_INT_BIT)#define ICCS_INT_ENB(x)	((x) & ICCS_INT_ENB_BIT)#define ICCS_SGL(x)		((x) & ICCS_SGL_BIT)#define ICCS_XFR(x)		((x) & ICCS_XFR_BIT)#define ICCS_RUN(x)		((x) & ICCS_RUN_BIT)/*MacVAC control status register defines*/#ifdef DEFINES#define MVCS_ERR_BIT 		((unsigned long)0x80000000u)#elseunsigned long MVCS_ERR_BIT = 0x80000000u;#endif#define MVCS_MBZ_BITS 		0x7fffff3f#define MVCS_INT_BIT 		0x00000080#define MVCS_INT_ENB_BIT 	0x00000040#define MVCS_ERR(x) 	((x) & MVCS_ERR_BIT)#define MVCS_MBZ(x) 	((x) & MVCS_MBZ_BITS)#define MVCS_INT(x) 	((x) & MVCS_INT_BIT)#define MVCS_INT_ENB(x)	((x) & MVCS_INT_ENB_BIT)/*machine check defines*//*MCSR*/#define MCSR_BUS_ERR	0x0000000Fu#define NON_EXIST_MEM	0x00000008u/*MCESR*/#define BUS_ERROR		0x00000008u#define TB_ERR			0x00000004u#define EXBUF_ERR		0x00000001u/*Software interrupt bits, mask. We use the top bits for hardware interrupts*/#define SISR_MASK		((unsigned long) 0x0000FFFEu )/*vectors*/typedef union{	struct	{		unsigned long handler_address:30;			/*bit 31-2*/		unsigned long serviced_on:2;				/*bit 0 - 2*/	} vector_part;	address	vector_as_long;} vector;#define SERVICED_ON(x) (x.vector_as_long & 0x3)#define HANDLER_ADDRESS(x) (x.vector_as_long & 0xFFFFFFFCu)#define USE_KSP	0#define USE_ISP 1/*vector offsets from SCBB*/#define V_PR	((unsigned long)0x00)	/*Passive release*/#define V_MCV	((unsigned long)0x04)	/*ABORT Machine Check (for us always a physical address error)*/#define V_KSPNV	((unsigned long)0x08)	/*ABORT kernel stack pointer not valid*/#define V_RoPI	((unsigned long)0x10)	/*FAULT reservered or priviledged instruction*/#define V_XFC	((unsigned long)0x14)	/*FAULT xfc trap*/#define V_RO	((unsigned long)0x18)   /*FAULT/ABORT reserved operand*/#define V_RAM	((unsigned long)0x1C)	/*FAULT reserved address fault*/	#define V_ACV	((unsigned long)0x20)	/*FAULT access control violation*/#define V_TNV	((unsigned long)0x24)	/*FAULT translation not valid*/#define V_TP	((unsigned long)0x28)	/*FAULT trace pending*/#define V_BPI	((unsigned long)0x2C)	/*FAULT Break point instruction*/#define V_CM	((unsigned long)0x30)	/*FAULT/ABORT compatibility*/#define V_A		((unsigned long)0x34)	/*TRAP/FAULT arithmetic*//*38*//*3C*/#define V_CHMK	((unsigned long)0x40)	/*TRAP chmk*/#define V_CHME	((unsigned long)0x44)	/*TRAP chme*/#define V_CHMS	((unsigned long)0x48)	/*TRAP chms*/#define V_CHMU	((unsigned long)0x4C)	/*TRAP chmu*/#define V_SWI1	((unsigned long)0x84)	/*INTERRUPT software interrupt level 1*/#define V_SWI2	((unsigned long)0x88)	/*INTERRUPT software interrupt level 2*/#define V_SWI3	((unsigned long)0x8C)	/*INTERRUPT software interrupt level 3*/#define V_SWI4	((unsigned long)0x90)	/*INTERRUPT software interrupt level 4*/#define V_SWI5	((unsigned long)0x94)	/*INTERRUPT software interrupt level 5*/#define V_SWI6	((unsigned long)0x98)	/*INTERRUPT software interrupt level 6*/#define V_SWI7	((unsigned long)0x9C)	/*INTERRUPT software interrupt level 7*/#define V_SWI8	((unsigned long)0xA0)	/*INTERRUPT software interrupt level 8*/#define V_SWI9	((unsigned long)0xA4)	/*INTERRUPT software interrupt level 9*/#define V_SWIA	((unsigned long)0xA8)	/*INTERRUPT software interrupt level A*/#define V_SWIB	((unsigned long)0xAC)	/*INTERRUPT software interrupt level B*/#define V_SWIC	((unsigned long)0xB0)	/*INTERRUPT software interrupt level C*/#define V_SWID	((unsigned long)0xB4)	/*INTERRUPT software interrupt level D*/#define V_SWIE	((unsigned long)0xB8)	/*INTERRUPT software interrupt level E*/#define V_SWIF	((unsigned long)0xBC)	/*INTERRUPT software interrupt level F*/#define V_CLOCK	((unsigned long)0xC0)	/*INTERRUPT interval clock interrupt vector*/#define V_SE	((unsigned long)0xC8)	/*TRAP subset emulation*/#define V_SUSE	((unsigned long)0xCC)	/*FAULT suspended emulation*/#define V_MACVAX ((unsigned long)0xE0)	/*MacVAC to VAX system interrupts*/#define V_CTR	((unsigned long)0xF8)	/*INTERRUPT console terminal receive*/#define V_CTT	((unsigned long)0xFC)	/*INTERRUPT console terminal transmit*//*hardware interrupts bits in ips[SISR] */#define ICR_INTERRUPT_LEVEL		0x18		/*IPL 24*/#define ICR_INTERRUPT_BIT		0x01000000	/*IPL 24*/#define MACVAX_INTERRUPT_LEVEL	0x17		/*IPL 23*/#define MACVAX_INTERRUPT_BIT	0x00800000	/*IPL 23*/#define CONSOLE_INTERRUPT_LEVEL	0x14		/*IPL 20*/#define CONSOLE_INTERRUPT_BIT 	0x00100000	/*IPL 20*/#define PCB_KSP		0x00#define PCB_ESP		0x04#define PCB_SSP		0x08#define PCB_USP		0x0C#define PCB_R0		0x10#define PCB_R1		0x14#define PCB_R2		0x18#define PCB_R3		0x1c#define PCB_R4		0x20#define PCB_R5		0x24#define PCB_R6		0x28#define PCB_R7		0x2c#define PCB_R8		0x30#define PCB_R9		0x34#define PCB_R10		0x38#define PCB_R11		0x3c#define PCB_R12		0x40#define PCB_R13		0x44#define PCB_R15		0x48#define PCB_PSL		0x4C#define PCB_P0BR	0x50#define PCB_P0LR	0x54#define PCB_P1BR	0x58#define PCB_P1LR	0x5C#define PCB_PID 	0x60 /*the offset from the PCBB for the MACVAX's idea of the Process ID*/#define PCB_KFP 	0x64 /*Save MacVAX internal idea of Kernal Frame Pointer for stackw*/#define PCB_EFP 	0x68 /*Save MacVAX internal idea of Executive Frame Pointer for stackw*/#define PCB_SFP 	0x6C /*Save MacVAX internal idea of Supervisor Frame Pointer for stackw*/#define PCB_UFP 	0x70 /*Save MacVAX internal idea of User Frame Pointer for stackw*/#define USERPSL	0x03c00000	/*the PSL for a user mode prog*/#ifdef MEMORY_Cstatic long	interlock = 0;#endif/*11/750 CMI defines*//*These are physical addresses of the CMI address space*/#define MEMORY_CSR0		0xF20000#define MEMORY_CSR1		0xF20004#define MEMORY_CSR2		0xF20008extern	unsigned int memory_csr[3];#define BOOT_ROMA		0xF20400#define BOOT_ROMB		0xF20500#define BOOT_ROMC		0xF20600#define BOOT_ROMD		0xF20700extern unsigned char *boot_roms;#define BOOT_ROM_SIZE 0x400	/*will probably make this a resource*/#define UNIBUS_1_CS		0xF30000#define UNIBUS_1_MAP	0xF30800typedef union{	unsigned long as_ulong;	struct	{		unsigned int v      : 1;		unsigned int mbz0   : 5;		unsigned int offset : 1;		unsigned int free   : 2;		unsigned int dpn    : 2;		unsigned int mbz1   : 6;		unsigned int pfn    :15;	} x;} umap_register;extern  umap_register *unibus_map;#define UNIBUS_MAP_SIZE		0x800#define UNIBUS_1_MEMORY 0xFC0000extern long saw_watch_point;/*Functions*/void init_vax_memory(	/*Allocates memory for VAX physical memory*/	/*Allocates watch map for VAX debugging*/	/*Sets up default display modes for IPR's*/	void);unsigned char *mac_address(	/*returns the Macintosh address of the Vax Address a*/	register address a);void get_interlock(void);void free_interlock(void);int copy_boot_roms(	address base	/*base address of 64K mem seg for booting in*/);address add_sys_pte(	/* creates a system page table entry */	/* returns the pages virtual address */	unsigned long modified,	unsigned long pfn,	unsigned long protection);unsigned long next_free_pf(	/* returns the page number of the first free physical page */	void);long mark_as_free_pf(	/*Mark as Free an allocated Physical page*/	unsigned long pfn);address add_p0_pte(	/* creates a P0 page table entry */ 	/*returns the pages virtual address*/	unsigned long modified,	unsigned long pfn,	unsigned long protection);address add_p1_pte(	/* creates a P1 page table entry */ 	/*returns the pages virtual address*/	unsigned long modified,	unsigned long pfn,	unsigned long protection);unsigned long vax_fetchliR(	/* Return a long from the aligned VAX Physical address a */	/* Returns 0 on error	and sets stop    		*/	register address a);int vax_putliR(	/* Put a long at the aligned VAX Physical address a */	/* Returns -1 on error	and sets stop      */	unsigned long l,	register address a);unsigned char fvax_fetchbR(	/*return byte at VAX Physical address a */	/* Returns 0 on error	and sets stop   */	/* Will set saw_watch_point if it did    */	address a);long fvax_putbR(	/*Writes byte b at VAX physical address a*/	/* Returns -1 on error	and sets stop   */	/* Will set saw_watch_point if it did    */	unsigned char b,	address a);void vax_fetchptR(	/*fetch a page table entry given its physcial (VAX) address			 */	/*Returns the result in pte											*/	/*Generates a memory fault for an invalid address setting *pte to 0 */	register address a,	register long modify,	register real_page_entry *pte);real_page_entry vax_fetchpt(	/* fetch a page table entry given its virtual address 				 */	/* Usually bypassed for speed                         				 */	/* Returns the pte. 												 */	/* Generates a memory fault for an invalid address setting *pte to 0 */	address a,	long modify );void display_memory_usage(	/*Displays the memory usage of the current processes VAX memory*/	void);void freeallmem(	/*Clears all VAX memory including registers and IPR's*/	/*Marks Console register transmit status register as ready*/	/*Zero's the line counters for the dispaly of each region of memory*/	long And_watch_points);void clear_all_watch_points(void);/*Clear ALL set watch points*/void alloc_sys_space(	/*Sets up system space page tables*/	/*Turns on Virtual memory		  */	void);void alloc_p1_space(	/* Allocates stacks */	/*generates a PCCB  */	void);address alloc_cd(	/*Allocates a block of VAX memory in P0 space     					*/	/*Returns the Virual address of the Block or ERROR if the call fails	*/	long size,	short protection);void free_p0_page(	/*Clears the last allocated P0 page*/	void);void toggle_watch_bit(	/*Toggle the bit associated with the address VAX virtual addr*/	address addr);void clear_range_watch_points(address addr, long length);void set_range_watch_points(address addr, long length);address virtual(	/*returns the virtual address given the physical address*/	/*returns ERROR if address not found*/	address physical);address check_reference(	/*Returns the vax real address of the given virtual address*/	register address addr,		/*	virtual address							*/	long mode,					/*	processor mode to check referce with	*/	long protection,				/*	want to read(1) or write(2) 			*/	long modify					/*	Want to mark page as modified			*/);byte vax_fetchb(	/*Fetch a byte given the virtual address*/	address addr);word vax_fetchw(	/*return the word at the given virtual address*/	address addr);long vax_fetchl( 	/*fetch a long word given the VAX virtual address*/	address addr);quad vax_fetchq(	/*fetch a quad word given the VAX virtual address*/	address addr);oct vax_fetcho(	/*fetch a oct word given the VAX virtual address*/	address addr);long vax_fetchv(	/*Fetch a size bits from VAX memory*/	address base,	long position,	unsigned char size);v_float vax_fetchf(	/*fetch a float given the VAX virtual address*/	address a);long vax_putb( 	/*Write "value" to VAX address "addr" 								*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	unsigned char value, 	address  addr);long vax_putw( 	/*Write "value" to VAX address "addr" 								*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	word value,	address addr);long vax_putl( 	/*Write "value" to VAX address "addr" 								*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	long value,	address addr);int vax_putq( 	/*Write "value" to VAX address "addr" 								*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	quad value,	address addr);int vax_puto( 	/*Write "value" to VAX address "addr" 								*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	oct value,	address addr);int vax_putv( 	/*Write "value" to VAX address bitfield specified by base,size,position */	/*Return -1 on error				  								    */	/*If the external long stop_writes is set an error will be returned	    */	long	value,	address	base,	long position,	unsigned char size);long vax_putf(	/*write a float to a given VAX virtual address*/	/*Return -1 on error				  								*/	/*If the external long stop_writes is set an error will be returned	*/	v_float v,	address a);#endif MEMORY_H