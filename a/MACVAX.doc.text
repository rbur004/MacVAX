1MacVAX      Assembler/Simulator  Reference Manual© 1989,1990Department of Computer ScienceUniversity of AucklandPrivate BagAucklandNew ZealandIntroductionPurposeThe cross assembler As and the MacVAX simulator were developed principally as teaching tools for undergraduate computer architecture courses at Auckland University.  However, they are also useful for debugging of actual VAX code in a more friendly programming environment than the standard VAX debuggers offer.FeaturesThe As cross assembler features:•	a large subset of the VAX macro assembler running on Digital Equipment Corporation VAX systems under the VMS operating system.•	integration with the Edit and MacVAX programs via a Transfer menu.The MacVAX simulator features:•	Symbolic debugging of VAX assembly language programs.•	Step and Trace facilities.•	Watch and break points.•	Virtual and Physical Memory dumps in hexadecimal or decimal.•	Memory displayed by symbolic label.•	Register display of all 15 registers plus the PSL and many IPR's.•	Display of Process Control Block and Page tables.•	Input/output using the xfc instruction, or using the VAX processor registers, RXCS, RXDB, TXCS and TXDB.CreditsThe As assembler was developed jointly by Rob Burrowes and Paul Reddy.  Rob Burrowes developed the MacVAX simulator.  The MacVAX manual was written by Evan Torrie.and Rob BurrowesStandard Editor (Edit)Editing filesThe first step in writing an assembly language program is to create a text file for As to assemble.  The standard editor provided with the development system is Edit, a simple no-frills editor with which you can create and modify assembly language source programs.If you do not like the Edit program, you can use any other Macintosh editor which can save files in text format.  For example, MacWrite can be used if you save the file as text-only.  Transfer MenuOne advantage of using Edit  to create your programs is that it provides a built-in method of quickly transferring to As  to assemble the program which you have just written.  This capability is accessed through the Transfer menu, which has three available options, MacVax, As, or Other...Selecting either the MacVAX or As menu item will transfer control to the appropriate application.  If As is chosen, the program currently being edited will automatically be opened and assembled.  The Other... menu option allows you to choose to transfer to an application of your choice.      AssemblerThe As cross assembler is based largely on the Vax Macro assembler available on Vax systems running the VMS operating system.  It supports the entire Vax instruction set and recognizes most of the standard assembler directives as defined in the VMS macro assembler manual.Assembling your programOnce you have written your assembly language program, it must be assembled into an object file using the Assemble option from the File menu in As.  After telling As where to save the object file, your program will be assembled.  Any status or error messages are written to the main Output window, which can be saved to a file with the Save Output command.The normal course of operation is to transfer to As from Edit, and then after assembling the program (and assuming no errors), choose the MacVAX option from the Transfer menu to start MacVAX and execute your program.MenusThe  menu contains the About... option and the desk accessories currently available on your Startup disk.                  AssembleThe Assemble option allows you to choose a text file for As to assemble.  You will then be asked where to save the resulting object file (which the MacVAX simulator will use as its input).  As will read in the text file and assemble it, producing any status messages in the main Output window.Save outputSave output saves any messages displayed in the main Output window to a text file.Clear outputClear output clears the main Output window.QuitQuit will exit the As application and return you to the Finder.   However, in normal program development, you will want to transfer to either Edit (to remove an assembly program’s bugs), or to MacVAX (to run a successfully assembled program).  A fast and convenient way to do this is to use the Transfer menu (see below).             Cut, Copy, Paste, UndoThese menu options are always disabled.  As makes no use of the Edit menu options, although you can use the command key equivalents in open desk accessories.            MacVAX, Edit, OtherLike the Transfer menu in the Edit program, choosing one of these menu options will take you to the corresponding application.  Additionally, choosing either MacVax or Edit will automatically open the file you most recently assembled.      SimulatorIntroductionThe MacVAX simulator is a program that executes VAX machine code like a real VAX but with extra features that let you see what is going on inside the machine.  It allows you to view the memory of the machine (by address or by label), the registers, and then single step or trace through the program.  This makes the simulator an excellent debugging tool for VAX machine language programs.WindowsThe MacVAX simulator uses a number of windows to display the current status of the program being executed.Program Window                                        The Program window is the simulator’s main tool for examining the instructions which comprise the program to be executed.The window is divided into three sections:•	Label	If the Symbolic Mode menu option in the Options menu is enabled, this column displays the labels used in the assembly language program.	The Label column also contains the hand icon.  This points to the next instruction to be executed, and corresponds to the value of the program counter.   By pointing to an instruction in the Program window and clicking, the hand icon can be moved to that location, and the program counter altered.•	Addr	This column displays the address at which the corresponding instruction begins.  These addresses can be displayed in either hexadecimal or decimal notation using the Hex Addresses option in the Options menu.  Hexadecimal numbers are denoted by the characters 0x in front of the number, e.g. 0xFF = 25510.•	Instruction	The Instruction column contains the opcode and operands for the instruction.  If the Symbolic Mode option is enabled, addresses of data and instruction operands are displayed as labels, rather than numbers.  In addition, the numbers can be shown in hexadecimal or decimal format by using the Hex Addresses option.•	ScrollingInstead of a scroll bar the Program window has six buttons.   	Sets the window origin to  0.    	Scrolls the window back by a byte.    	Scrolls the window forward by a byte.Scrolling backward or forward by a byte may not correspond to an instruction in your assembly language program. The simple solution is to keep scrolling until you recognize an instruction from your program.    	Scrolls the window forward by an instruction.There is a button for scrolling forward an instruction but not one for scrolling backwards. It is not possible to determine the previous instruction accurately.  	Sets the window origin to the Program Counter.   	Displays a dialog box so the address or a label representing an address in the program may be entered. The window origin is set to the address entered.                                                      The program window was created so a programs execution could be easily viewed. It was not intended to be a way to view the original source (if it existed). The windows contents are derived by disassembling memory from the current PC. This may result in a listing which is different from the assembled source. Memory DumpThe Memory Dump window displays the raw hexadecimal or decimal data for both the program’s code and data.  Bytes corresponding to data and stack memory can be altered interactively.  Watch/break points are set by selecting a byte in the Memory Dump window and using the Toggle Watch/Break Point menu option.The Memory Dump window can take two different forms:•	The Hex Ascii Memory Dump window can be shown by choosing the Display in Hex option in the Options menu.                                                                The Hex Ascii Memory Dump window is divided into two sections.•	A table on the left which contains the values of the bytes currently held in the MacVAX simulator’s memory.•	Over on the right hand side, an ASCII representation of the same data.  This is useful for viewing strings in the data section of memory.•	The Decimal Memory Dump window which is selected by choosing the Display in Decimal option.                                                             The Decimal Memory Dump window displays 10 bytes per row in decimal format.Instruction/Data SeparationWhen you assemble your program using As, you can specify whether memory locations correspond to code or data by using the .code and .data directives.  The Vax architecture uses a technique called instruction/data separation to place the code and data in separate blocks of memory, called pages.  Each page is 512 bytes long and is protected against invalid memory accesses by marking it either read-only or read/write.  Instructions following a .code directive are placed in pages which are marked read-only. An attempt to store a value into a read-only page will generate an error.  Any data space allocation directives following a .data directive mark the memory as read/write.  These memory locations can be both read from and written to.  Normally you would write .code before your program instructions, and .data before any memory allocation.Code pages precede data pages in the simulator’s memory.  Hence the program’s code starts at location 0 in memory, and the data follows the code, starting at a multiple of 512 bytes, depending on the length of the code.  You can easily find the start of your data using the To Data Start option in the To menu to move the selection in the Memory Dump windows to the first byte of data.     If you don't specify either .code or .data, the assembler assumes a default of a .code directive.  This means that all pages are marked read-only, and you will  be able to read from, but not write to your data locations!  Thus, you should use the .data directive before any data space allocation.  Editing DataBoth Memory Dump windows allow you to edit the bytes contained in the simulator’s memory.  This involves selecting the byte you want to change by pointing and clicking with the mouse.  The byte is then inverted, and can be altered by typing the new value on the keyboard.  However, pages which are marked read-only (using the .code directive) cannot be altered in the simulator.Virtual memoryThe MacVAX simulator uses VAX virtual memory mapping to map your programs memory references to VAX physical memory.  VAX physical memory is implementedas an array in MAC physical memory. The Memory Dump window uses a thick black line to signify the separation of low memory from stack memory.  The addresses after the black line are those corresponding to the pages containing the stack.  As the stack grows, the Memory Dump window will automatically move the separation point down in memory.Example:                                                                  Memory by Label                                                                      The Memory by Label window displays the current memory contents starting from the first byte of the program’s data.  The symbolic labels used in the left most column correspond to the labels in the assembly language program.The addresses can be displayed in either hexadecimal or decimal using the Hex Addresses menu option.  The data can be displayed in any one of the four possible formats, hexadecimal, decimal, unsigned decimal or Ascii by clicking on the entry in the value column and choosing the appropriate “Display in ...” command from the Options menu.  The default mode of display for an item is the same as the mode in which it was declared in As.Physical Memory                                                                The Physical Memory window provides a read only display of MacVAX's VAX physical (real) memory. It has been provided to demonstrate the relationship between virtual and physical memory.The locations displayed may be scrolled using the scroll bar or by using the To Address option of the To menu. The other options in the To menu are disabled when this window is front most.The addresses used in a program are Virtual addresses. These are mapped to physical addresses using the program region (P0), Stack region (P1) and the system region (S) page tables. The "current" P0 and P1 page tables can be found (in virtual system space) easily by using the P0BR and the P1BR + 0x800000 of the To menu when the Memory Dump window is active. The S page table is common to all processes and can be found (in virtual system space) using the SBR of the To menu when the Memory Dump window is active. To find these tables in physical memory the system space page table entries must be used to convert the virtual location into a physical location.RegistersThe Registers window displays the current contents of the 16 general purpose VAX registers and the PSL (Processor Status Longword).                               Registers R12 through R15 are labeled with their usual mnemonics, Argument Pointer, Frame Pointer, Stack Pointer, and Program Counter.Processor Status Longword                                                             TP		= Trace PendingFPD	= First Part DoneIS		= Interrupt stack is being usedCMD	= Current ModePMD	= Previous ModeIPL	= Interrupt Priority LevelD		= Decimal overflow interrupt enableF		= Floating point underflow interrupt enableI		= Integer overflow interrupt enableT		= Trace bitN		= Negative bitZ		= Zero bitV		= Overflow bitC		= Carry bitThe low word of the PSL is displayed on the left using a character for each bit position.  If a bit is off in the PSW, then no character is displayed.  If a bit is on, then a letter corresponding to that bit is displayed.  For example, if the Zero flag is set in the PSW, the letter ‘Z’ appears in the PSW register.  The complete PSL is displayed to the right in hexadecimal format.Example:  If we execute the following piece of code	clrl	r0the PSW will be set to 	PSW:              Z		PSL:  0x03c00004The general purpose registers can be edited by clicking with the mouse on the number to be edited and typing the new value on the keyboard.As with the Memory by Label window, the registers can be displayed in any of the four formats by choosing the appropriate “Display in ...” command from the Options menu.Input Output                          The Input Output window displays any output generated by the simulator whilst executing the program.  This will only contain data if your program uses the sys system calls, or the processor register input/output mechanisms provided by the VAX architecture.  See the Appendix for an example of I/O with the MacVAX simulator.Watch/Break pointsWatch and break points are debugging aids provided by the MacVAX simulator to provide more sophisticated tracing of your program’s execution than the Go, Step and Step-Step commands allow.Watch points and break points are very similar in concept.  A break point is set at an arbitrary location in the program code, whereas a watch point is set at a data location.   If the simulator encounters a break point set at one of the memory locations in the current instruction, it will halt execution following that instruction and display a message indicating that it encountered a breakpoint.  If the simulator tries to access a data location for which a watch point is set, it will halt after executing the instruction that tried to access that data, and display a message indicating it encountered a watchpoint.Watch points and break points are set by selecting a location in the Memory window and using the Toggle Watch/Break Point command.  When watch/break points are enabled, using the Watch + Breaks On command in the Run menu, a rectangle appears around the locations in the Memory window at which watch/break points set.Example:Suppose we have the following program which adds one to each element of an array 100 bytes long:.dataTable:	.blkb	100.codeStart:	moval	Table, r0	movl	#100,r1Loop:	incb	(r0)+	sobgtr	r1, LoopEndLoop:	clrl	r0The simulator’s Program Window will appear as:                                        The program accesses memory locations starting from the address of Table (0x200) and adds 1 to each of the 100 locations.  Suppose we want the program to stop when it gets to the 11th element.  Rather than having to single-step through 11 iterations of the loop, we can set a watchpoint at the 11th location, i.e. address 0x20A, by selecting location 0x20A in the Memory Dump window and choosing Toggle Watch/Breakpoint, e.g.                                                                If we now set the program going using the Go command in the Run menu, the simulator will add 1 to the first 10 locations, execute the instruction which accesses location 0x20A and detect that a watchpoint has been set.  The simulator will halt and display the following message:                                                                      You can then continue with the execution of your program by using the Go or Step commands.Suppose we now want to continue execution of the program until it has finished the last element in the array and exits the loop.  By setting a breakpoint at the memory location of the instruction which follows the loop, we can stop the program as soon as it has finished adding one to each element.In the example, the instruction in question is the clrl r0.  This instruction begins at location 0x13, so to set a breakpoint at this instruction, we select the byte at location 0x13 in the Memory Dump window and choose Toggle Watch/Breakpoint.                                                                   Now, if we set the program executing again, the simulator will halt when it has finished the loop, displaying a message indicating it has encountered a breakpoint.Hence, watch and breakpoints can be used to debug your program much more quickly than would be possible with just the Step and Step-Step commands.MenusThe simulator has many and varied options for displaying and executing your program.  All of these options are selected using the eight menus in MacVax.The  menu contains the standard About... option describing the origins of the MacVAX program, and a list of the current desk accessories on the Startup disk.                   OpenThe Open option in the File menu is used to open an object file produced by As, ready for execution by the MacVAX simulator.  The file will normally have a .out suffix unless you explicitly gave it a different name.  If you transfer to MacVAX from As using the Transfer menu, the object file will automatically be opened.CloseClose closes the current simulator object file.Send Output ToCurrently this option is not implemented.Save StateSave State will save the current simulator working environment to the object file.  This includes the position of the windows, the current display format of each window, as well as which windows are open and which are closed.  The Save State command writes a description of the current state to the MacVAX program’s file.  If MacVAX is stored on a write-protected disk, the Save State command will have no effect.Restore StateRestore State will restore the most recently saved environment.  This is useful if you have altered the position and format of windows, and want to quickly get back to a previous state.QuitQuit quits the simulator and returns to the Finder.  If you want to return to Edit, it is quicker to use the Transfer menu.             Undo, Cut, Copy, PasteThese menu options are not used in the MacVAX program, although their command key equivalents can be used in open desk accessories.                               The Run menu is used for controlling the flow of execution of your machine language program.  ResetReset is the same as reopening the current simulator file.  It restores the Program Counter (PC) to its initial location, clears all registers, resets the data space locations to their original values, and clears all watch/break points. GoChoosing Go will start the program executing from the location of the current PC.  Execution will continue until• the program finishes• a break point or watch point is encountered• the program is interrupted using the Pause menu.• an exception such as an illegal memory reference.While a program is “Going”, the display windows, with the exception of the I/O window, are normally not updated.  However, a special sys 14  call exists to force an update of all windows (see the I/O section in the  Appendix). Step-StepStep-Step executes one instruction at a time.  It then updates the contents of all the windows, and continues with the next instruction.  Step-Step can also be interrupted using the Pause menu.StepStep executes one instruction, updates all the windows, and then stops.  Toggle Watch/Break PointThe Toggle Watch/Break Point command is used to set watch and break points in your program.  To set a watch or break point, select a byte in the Memory Dump window, and choose the Toggle Watch/Break Point command.  A rectangle appears around the location in the Memory window.  Watch + Breaks OnThis command toggles between enabling and disabling watch/break points.  Turning Watch + Breaks On means that watch and break points are recognized by the simulator, and will cause program execution to be interrupted.  If the command is disabled, the simulator will continue execution as if no watch/break points are set.  However, the simulator doesn’t forget where these points were, and will restore them if you choose to enable the option again at a later time.When the Watch + Breaks On option is enabled, the simulator identifies watch and break points by drawing a rectangle around the locations in the Memory Dump window.                      Program, Registers, Memory by Label, Input Output, Memory Dump, Physical MemoryChoosing these commands displays the respective window on the screen, if it is hidden or not open, and brings it to the front.Clear I/OThis option clears the I/O window 9 Point,12 Point,14 Point,18 PointThese options allow you to display the output in the front most window in a different font size.  Each window can have its own individual format.Bold, PlainThese toggle the front most window’s display between bold and plain typestyle.Courier, MonacoCourier and Monaco change the typeface in the front most window.  MacVAX only allows the Courier and Monaco typefaces to be used, because these are mono-spaced fonts.                                Hex AddressesChoosing Hex Addresses displays all addresses in the Program and Memory by Label window in hexadecimal, rather than decimal.Symbolic ModeThis command uses the labels defined in the assembly language program to mark the corresponding locations in the Program window in MacVAX.  Both instruction and data labels are symbolically displayed.Display in Hex, Decimal, Unsigned Decimal, Ascii, FloatThe Display set of commands change the output format of the data in the front most window.  These commands apply only to the Memory, Register and Memory by Label windows.Memory Dump windowDisplay in Hex and Display in Decimal will change the format of the displayed data in the Memory Dump window to the corresponding base.  Display in Unsigned Decimal and Display in Ascii are disabled for the Memory Dump window.Memory by Label and Register windowsAll four display options can be used for the Memory by Label and Register windows.  To change the format of a value, click and select the value you wish to view, then choose the appropriate “Display in ...” option.                                This set of commands is used for moving to the appropriate location in the Memory Dump window.To AddressA dialog box prompts for the address to go to. Address may be entered in hexadecimal (eg. 0x200) or in decimal (eg 512). A label (data or code) from the program may also be entered. If the Physical Memory window is the front window then this option scrolls the Physical Memory  rather than Memory Dump window.To Code Start, To Data StartTo Code Start and To Data Start moves to the start of the code segment and data segment respectively and select the byte at that memory location.To PC, To SP, To FP, To AP To PC, SP, FP, and AP moves to the location pointed to by the current value of the respective register.To USP, To SSP, To ESP, To KSP, To ISP, To P0BRTo USP,  SSP, ESP, KSP, ISP, P0BR moves to the location pointed to by the current value of the respective internal processor register.To P1BR + 0x800000To P1BR + 0x800000 moves to the location pointed to by the current value of the P1BR  internal processor register + 0x800000. This moves to the end of the P1 Page table.To SCBB, To SBR, To PCBBTo SCBB, SBR, PCBB moves to the virtual address corresponding to the current physical address of the respective register. As these registers hold physical addresses not virtual addresses, MacVax assumes the system will always place the SCBB at 0x80000000, the SBR at 0x80000A00 and the PCBB at 0x7FFFFE00 in virtual space.            AssemblerChoosing this command returns you to As.EditChoosing Edit will transfer control to the Edit program.OtherOther allows you to immediately transfer to any application of your choice, without returning to the Finder.             PauseThe Pause command allows you to interrupt MacVAX whilst it is executing your program.  Pause will interrupt both the Go and Step-Step modes of operation.Appendix AAssembler detailsThe As assembler is based largely on the Vax Macro assembler available on Digital Equipment Corporation VAX systems running the VMS operating system.  For a complete description of the assembler, see the appropriate Assembler Reference manual.BlanksBlank and tab characters may be used freely in the assembly language program to make the program more readable.  Blank lines are ignored by the assembler.LabelsA label is any sequence of alphanumeric characters that starts with a letter.  A label is tied to a particular location in the code where it is declared by placing a colon after it, e.g.	Start:     ; declare the label start We can then use the label anywhere we would normally use an address.	brb	StartNote that the As assembler is case-sensitive.  Labels must have exactly the same sequence of upper and lowercase letters everywhere they are used to be recognized as the same label.CommentsComments can be used anywhere in the program.  A semicolon “;”  starts the comment, and the rest of the line will be ignored.  C-style comments are also supported, using  the characters “/*” to start the comment, and following it with the characters “*/”.DirectivesDirectives are used to instruct the assembler to perform some special operation for the following statement, rather than treating it as a normal assembly language instruction.Initialized Data.blkb	exprReserves one or more bytes (8 bits) of memory and fills them with zero.	.byte	20			; reserves 20 bytes of space .byte		expr [ , expr ]Reserves one or more bytes (8 bits) of memory with values taken from the expressions, e.g.	.byte	3			; reserves one byte with contents 3 	.byte	2, 3, 5, 7	; reserves four consecutive bytes 					; with values 2, 3, 5, 7 .blkw	exprReserves one or more words (16 bits) of memory and fills them with zero..word	expr [ , expr ]Reserves one or more words (16 bits) of memory with values taken from the expressions..blkl		exprReserves one or more longwords (32 bits) of memory and fills them with zero..long		expr [ , expr ]Reserves one or more longwords (32 bits) of memory with values taken from the expressions..ascii		string [ , string ].asciz	string [ , string ]Stores an ASCII string as consecutive bytes in memory.  Asciz terminates the string with a null character (a zero byte) while ascii does not.Strings consist of a sequence of ASCII characters enclosed in double quotes, e.g.	.ascii	“This is a string”.float	floatConstant[ , floatConstant]Reserves one or more F float format longwords (32 bits) of memory with values taken from the numbers..enter	^M<[rn, ... rm], [iv],[dv]>This is a special form of the .word directive used in a .code segment to reserve a word of memory for the procedure mask at the start of a procedure.	.enter	^M<r2, r3>	; Procedure mask to save r2 and r3 on entryFilled Data.space	space_expr [ , fill_expr ]Reserves space_expr consecutive bytes in memory, and fills them with the value contained in fill_expr.  If fill_expr is omitted, it defaults to 0, e.g.	.space	12, 0xF		; fill 12 bytes with value 1510 		  	.space	20			; Reserve 20 bytes (filled with 0) 	  .fill		rep_expr , size_expr , fill_exprFill_expr, treated as an expression of size size_expr bytes, is assembled and replicated rep_expr times.  Note that size_expr must be between 1 and 8.	.fill	8, 2, 0xFFFF	; Reserve 8 words (16 bytes) with 						; value 0xFFFF 				  .align	align_expr [, fill_expr]The location counter is incremented to the next address which is divisible by 2align_expr bytes.  This is done by filling from 0 to 2align_expr bytes with the the low order byte of fill_expr.  If present, fill_expr must be absolute; otherwise it defaults to zero.	.align	2			; Pads using null bytes to make location 					; counter evenly divisible by 4Defining Constants.set		name, expressionSets the value of name to expression.  Any existing value for name is overwritten.	.set	RecordSize, 12	.set	NoRecords, 8Array:	.blkb	RecordSize*NoRecords	; reserve 96 bytes 	Including other files.include	filenameReads in the file filename, and assembles it as though it were part of the current file.	  Setting the code base address.origin	addressThe code is generated from address address  on. The .origin can only be used at the start of code segment 0. The data is relocated to the end of the generated code. 	  ExpressionsExpressions may consist of all normal arithmetic operations using any of the operators or operands as shown below.  Precedence is the same as for normal arithmetic, but parentheses can be used to group expressions to ensure the expected order of evaluation. All operands are treated as 32 bit integers. Floating point constants, Quador  Oct constants may not be manipulated by operators.Operators	Operator	Meaning	Example	Value left in r0      Unary:		–	negate	movl #–1, r0	–1 (0xFFFFFFFF)	~	bit negate	movl #~0xFFFFFFFE, r0	0x00000001      Binary:       	&	bitwise and	movl #0xFFFF & 07, r0	7	|	bitwise or	movl #01 | 05, r0	5	^	bitwise exclusive or	movl #07 ^ 05, r0	2	!	operand1 | ~operand2	movl #01 ! 05, r0	0xFFFFFFFB	*	multiplication	movl #12 * 7, r0	84	/	integer division	movl #75 / 6, r0	12	%	modulo	movl #75 % 6, r0	3	+	addition	movl #7 + 4, r0	11	–	subtraction	movl #7 – 4, r0	3	>>	logical right shift	movl #8>>2, r0	2	<<	logical left shift	movl #1<<4, r0	16Operands	<decimal constant>	a sequence of digits without a leading zero, e.g. 42	<octal constant>		a sequence of digits with a leading zero, e.g. 052	<hex constant>		 “0x” followed by a sequence of digits, e.g. 0x2A	<identifier>			a label or equate, e.g. brb start + 4	‘<letter>			a single character, e.g. movl ‘A, r0	<float constant>		a number of the form 0f±n.ne±n ,  eg.   0f5.723e-23Appendix BAssembler	Comment	#<expr>	The operand is a read only constant =  <expr>. 	 (Compiles to (PC)+ or a literal. )<expr>	The <expr> specifies the memory address of the operand. (PC relative.  Assembles to 	<expr> - current_location (PC) )@#<expr>	The <expr> specifies the memory address of the operand. (Absolute.  Has the same effect as <expr> but assembles to @(PC)+ )@<expr>	The <expr> specifies the address of the address of the operand. 	 (Assembles to @<expr> - current_location (PC) )Rn	The operand is the register contents.(Rn)	The operand is at the address specified in the register.–(Rn)	The Register contents are decremented by the size of  the operand type before being used as the address the operand.(Rn)+	The Register contents are incremented by the size of the operand type after being used as the address the operand.@(Rn)+	The Register contents is incremented by 4  after being used to obtain the address of the address of the operand.<expr>(Rn)	The operand is at the address specified by the 	 <expr> + the register contents.@<expr>(Rn)	The address of the address of the operand is specified by the <expr> +  register contents .	Assembler	Comment#<expr>[Rx]	The operand is at the address (Rx * operand size) + PC.  (Assembles to (PC)+[Rx]. This is NOT a useful mode)<expr>[Rx]	The operand is at the address (Rx * operand size)+<expr>.  (PC relative.  Assembles to 	<expr> - current_location (PC) [Rx] ).@#<expr>[Rx]	The operand is at the address (Rx * operand size)+<expr>.   (This has the same effect as <expr>[Rx] but assembles to @(PC)+[Rx]).@<expr>[Rx]	The operand is at the address (Rx * operand size) + the value (long) at the address <expr> .  (Compiles to @<expr> - current_location(PC)[Rx] ).(Rn)[Rx]	The operand is at the address (Rx * operand size) + Rn–(Rn)[Rx]	The value of Rn is decremented by the size of the operand type before adding it to (Rx * operand size) to obtain the address of the operand.(Rn)+[Rx]	The value of Rn is incremented by the size of the operand type after adding it to (Rx * operand size) to obtain the address of the operand.@(Rn)+[Rx]	The operands address is obtained by taking the value at the memory address specified by the contents of Rn and adding it to (Rx * operand size) . The contents of Rn are then incremented by 4.<expr>(Rn)[Rx]	The address of the operand is obtained by <expr> + Rn + (Rx * operand size) .@<expr>(Rn)[Rx]	The operands address is obtained by taking the value at the  address (<expr> + Rn) and adding it to (Rx * operand size) .		 Notes	<expr> is an expression as described in Appendix A.An <expr> is evaluated at assembly time. Rn and Rx are any registers and may be the same register.Appendix CSystem callsThe MacVAX simulator provides a collection of built-in system calls allowing reading and writing of strings and numbers, file i/o, and miscellaneous window management routines.  These calls are accessed using the sys instruction (which uses the opcode for the normal Vax xfc instruction).  The general format of a sys call is:	sys	nwhere n is a byte representing the system call number.  Arguments are passed to and returned from  sys calls in registers.Example:To read one character from the keyboard, we use sys call number 0, and the character read gets returned in r0.	sys	#0		; Read one character (returned in r0) Alternatively we could use another register for the system call number.	movl	#0, r2	sys	r2		; Read one character (returned in r0) Console IOSYS 0 (ReadChar)Reads one character from keyboard with no echoing.  Character is returned in the low byte of r0.SYS 1 (WriteChar)Output one character to the I/O window.  Character is passed in the low byte of r0.SYS 2 (ReadLine)Input one line from the keyboard – equivalent to Pascal’s readln – characters are echoed and erase/kill processing is performed.  On execution, r0 must contain the address where the string is to be placed.  After execution r0 points to one byte after the end of the string, and r1 contains the length of the string.  An end of line character is not appended to the return string.SYS 3 (WriteString)Output one line to the screen – equivalent to Pascal’s write.  On execution, r0 must contain the address of a buffer which contains the string to output, and r1 the length of the string.  Characters from the buffer are output one at a time until a null byte is reached or r1 characters have been written.  After execution r0 points to the byte after the terminating character of the string.String To Number ConversionSYS 4 (AHToI)Convert a hexadecimal number string into the equivalent binary number.  On execution r0 must contain the address of the string to convert – leading spaces in the string are skipped until a hex digit is found.  The conversion continues until either eight hex digits have been found or a non hex digit is encountered.  After execution the binary value is returned in r1, and r0 points to the byte after the last digit converted.SYS 5 (ADToI)Convert a decimal number string into the equivalent binary number.  On execution r0 must contain the address of the string to convert – leading spaces in the string are skipped until a decimal digit is found.  The conversion continues until either ten decimal digits have been found or a non decimal digit is encountered.  After execution the binary value is returned in r1, and r0 points to the byte after the last digit converted.SYS 6 (IToAH)Convert a binary number into a hexadecimal string.  On execution r0 contains the address of a buffer where the string will be placed, and r1 contains the integer to be converted.  After execution r0 points to 1 byte past the end of the string.SYS 7 (IToAD)Convert a binary number into a decimal string.  On execution r0 contains the address of a buffer where the string will be placed, and r1 contains the integer to be converted.    After execution r0 points to 1 byte past the end of the string.File I/OThe following sys routines handle input and output to Macintosh text files.SYS 8 (OPEN_MAC_FILE)Puts up a Standard File Open dialogue box, and waits for the user to select a file.  A file descriptor used to refer to the file in all subsequent file i/o calls is returned in r0.  A value of 0 in r0 indicates the Cancel button was clicked, or an error occurred while trying to open the file.SYS 9 (CREATE_MAC_FILE)Puts up a Standard File Put dialogue box, and waits for the user to type in a file name.  A pointer to a buffer for the new file’s name must be passed in r1.  The file descriptor is returned in r0.  A value of 0 in r0 indicates the Cancel button was clicked, or an error occurred while trying to create the file.SYS 10 (CLOSE_MAC_FILE)Closes the file described by the file descriptor passed in r0.  If the file was closed successfully, 0 will be returned in r0.  If an error occurred, r0 will be set to –1.SYS 11 (READ_MAC_FILE)Reads the number of bytes indicated by r2 into a string buffer pointed to by r1. The file to be read from is given by the file descriptor passed in r0.  The current file position is shifted by the number of bytes read.  The number of bytes actually read is returned in r2.SYS 12 (WRITE_MAC_FILE)Writes the number of bytes indicated by r2 from a string buffer pointed to by r1 at the current file position.  The file to be written is selected by the file descriptor passed in r0.  The current file position is shifted by the number of bytes written.  The number of bytes actually written is returned in r2.SYS 13 (SEEK_MAC_FILE)Moves the current file position to the position passed in r1 according to the mode passed in r2.  The file is selected using the file descriptor passed in r0.  The mode has three possible values:	0	Seek from beginning of file	1	Seek relative to current position	2	Seek from end of fileOn return, r1 contains the new current file position.Window ManagementThe following eleven sys calls all handle window management inside the MacVAX simulator. SYS 14 (UPDATE_WINDOWS)Causes all open windows to be updated while the program is “Going”.SYS 15 (PROG_TO_FRONT)	Bring Program window to front.SYS 16 (REG_TO_FRONT)	Bring Register window to front.SYS 17 (MEML_TO_FRONT)	Bring Memory by Label window to front.SYS 18 (IO_TO_FRONT)	Bring I/O window to front.SYS 19 (MEM_TO_FRONT)	Bring Memory window to front.SYS 20 (PROG_CLOSE)	Close Program window.SYS 21 (REG_CLOSE)	Close Register window.SYS 22 (MEML_CLOSE)	Close Memory by Label window.SYS 23 (IO_CLOSE)	Close I/O window.SYS 24 (MEM_CLOSE)	Close Memory window.SYS 27 (CLEAR_IOW)	Clear I/O window.Memory ManagementSYS 25 (ALLOC_MEM)	Add a page of memory to P0 space. 				Returns address of blockSYS 26 (FREE_MEM)	Removes a page of memory to P0 space.Appendix DInternal Processor RegistersThese registers are accessed using the mtpr and mfpr instructions. KSP 		0x0	Kernel Stack Pointer			Read / WriteESP 		0x1	Executive Stack Pointer			Read / WriteSSP 		0x2	Supervisor Stack Pointer			Read / WriteUSP 		0x3	User Stack Pointer				Read / WriteISP 		0x4	Interrupt Stack Pointer			Read / Write                                                             The stack pointer to be used is determined by bits 23,24 (the current mode) and 25 (IS bit) of the PSL. The IS bit of the PSL is set when the processor aborts, faults, traps or interrupts through an SCB vector which has the low 2 bits set to 01. The CMD field of the PSL is set to 0 on an  abort, fault, trap or interrupt. The IS bit of the PSL is cleared when a new PSL with the IS bit clear is load by a rei instruction.P0BR 	0x8	Process Space P0 Base Register		Read / Write                                                             POBR holds the virtual address of the current processes P0 page table entries. The address must be long aligned (the low 2 bits must be 00) and must be in system space ( >= 0x80000000 and < 0xC0000000).P0LR 	0x9	Process Space P0 Length Register	Read / Write                                                            The P0LR contains the size of the current processes P0 page table in long words.P1BR 	0xA	Process Space P1 Base Register		Read / Write                                                             P1BR holds the virtual address of the current processes P1 page table entries. The address must be long aligned (the low 2 bits must be 00) and  must have a value between 0x7f80000 and 0xBF000000. This is to ensure the page table entries are always in system space.P1LR 	0xB	Process Space P1 Length Register	Read / Write                                                            The P1LR contains the number of unused page table entries (each PTE is a long word) of the current processes P1 page table. SBR 		0xC	System Base Register			Read / Write                                                             SBR holds the Real address of the system page table entries. The address must be long aligned (the low 2 bits must be 00) .SLR 		0xD	System Length Register			Read / Write                                                            The SLR contains the size of the System page table in long words.MAPEN	0x38	Memory Management Enable		Read / Write                                                            E	= Enable bit		Read / WriteSetting bit 0 of  the MAPEN register enables memory management. MacVAX sets this bit when resetting or loading a program. MacVAX assumes memory management will be enabled. PCBB 		0x10	 Process Control Block Base	Read / Write                                                             PCBB holds the Real address of  the current processes Process Control Block The address must be long aligned (the low 2 bits must be 00) .SCBB 		0x11	 System Control Block Base	Read / Write                                                             SCBB holds the Real address of  the System Control Block The address must be long aligned (the low 2 bits must be 00) . The System Control Block is a page of vectors for aborts, faults, traps, and interrupts.IPLR		0x12	 Interrupt Priority Level Register	Read / Write                                                            The IPLR accesses bits 20 to 16 of the PSL.SIRR		0x14	 Software Interrupt Request Register	Write Only                                                            The SIRR is write only. A mtpr src , #SIRR instruction requests an software interrupt at IPL src. Pending interrupts are summarized in the SISR.SISR		0x15	 Software Interrupt Summary Register	Read / Write                                                            The SISR holds a summary of the pending software interrupts. The register is cleared at boot time and may be cleared by software using a mtpr #0, #SISR. This is normally considered a read only register. Software interrupts should be requested using the SIRR register not by setting bits in the  SISR register directly.TODR	0x1B	Time of Year			Read Only                                                             The MacVAX simulator provides a “Time of Year” processor register using the Macintosh internal clock.  The VAX clock has a resolution of 10ms. As the Macintosh clock has a resolution of 1 second the low bits of the register will always be 0.  TODR is accessed with mfpr #TODR. ICCS 		0x18	Interval Clock Control Status Register		Read / Write                                                            E = ERR or error bit. 	 (set by hardware, write clears)	I = INT or interrupt bit. 	(set by hardware, write clears)IE = INT_ENB or interrupt enabled bit	(read/write)	S = SGL or Single increment bit 	(write only)X = XFR or transfer bit	(write only)			R = RUN 	(read/write)The ICCS is a read/write register that contains control and status information for the interval clock. When the RUN bit is one the ICR register is incremented every microsecond (instruction on MACVAX). Writing to the XFR (transfer) bit will  copy the NICR to the ICR.  Writing to the SGL (single increment) bit when the RUN bit is zero will increment ICR.  When the INT_ENB (interrupt enable) bit is one an overflow of the ICR will generate an interrupt at IPL 24. The INT (interrupt) bit is set by hardware whenever the ICR overflows. It can must be cleared by the clock interrupt service routine by writing the the INT bit (ie.. writing a one to it clears it). The ERR (error) bit is set by hardware when an overflow occurs and the INT bit is already set. It may be cleared by writing a one to it.NICR	0x19	Next Interval Count Register			Write Only                                                             The NICR is a write only register that holds the clock count in microseconds to be loaded into the ICR when the ICR overflows (ie.. after an increment its value is zero) or when the XFR (transfer) bit of the ICCS is written to. As the ICR register is incremented, not decremented, the value stored in NICR should be set to the two's  complement of the interval wanted.ICR 		0x1A	Interval Count Register				Read Only                                                             The ICR is a read only register that is incremented every microsecond on a VAX (every instruction on MACVAX) while the RUN bit of the ICCS is one. It can also be incremented by writing to the SGL (single increment) bit of the ICCS. It is loaded from the NICR when the XFR (transfer) bit of the ICCS is written to or when the ICR overflows (ie.. after an increment its value is zero).  An overflow will also set the INT (interrupt) bit of the ICCS. If the INT bit was already set the ERR (error) bit will be set to indicate one or more clock interrupts have been missed. If the INT_ENB (interrupt enable) bit is one, an overflow will generate an interrupt at priority level 24. Console RegistersRXCS 	0x20	Receive Control Register			Read / Write                                                            D	= Done bit		Read OnlyIE	= Interrupt enable		Read/WriteThe done bit in the RXCS register is read-only and is set by the keyboard handler whenever a key press is received.  It is initialized to 0 at bootstrap time and is cleared whenever mfpr #RXDB, dst is executed.   If  the RXCS interrupt enable  bit is set by software, an interrupt is generated when done becomes set.  Similarly, if done is already set and the software sets interrupt enable , an interrupt is generated.RXDB	0x21	Receive Data Register			Read Only                                                             E = Error bit		Read OnlyThe data received from the keyboard is stored in the low eight bits.  The error bit in the RXDB register is set when the received data contained an error such as overrun or loss of connection.  This register is read only.TXCS		0x22	Transmit Control Register		Read / Write                                                            R	= Ready bit		Read OnlyIE	= Interrupt enable bit	Read WriteAt Bootstrap time (when MacVax is reset) the ready  bit is set to 1. On a mtpr src, #TXDB instruction, the ready  bit is cleared.  When the output of the character completes the ready  bit is set back to 1. If the interrupt enable bit is set by software, an interrupt is generated when the ready  bit is set.  If the ready  bit is already set and software sets interrupt enable, an interrupt is also generated. TXDB	0x23	Transmit Data Register			Write Only                                                             Writing into the TXDB register will cause the character represented by the low byte to be drawn in the I/O window.  Writing to the TXDB register when the ready  bit is clear  may cause the character currently being output to be lost.   Note that the MacVAX simulator sends characters asynchronously to the screen using a VBL queue task.  This means that your characters may not appear instantly in the input/output window upon execution of a mtpr src, #TXDB. Several instructions may be executed before the output is completed.Appendix E 	Virtual Memory Map                                           MacVAX maps program virtual memory references to Physical memory using the usual VAX page tables. VAX physical memory is implemented as an array in Macintosh memory.Appendix FInterrupt HandlingThe following exception and interrupt conditions are recognized by MacVAX.Vector(offset from SCBB)	Name	type	number ofParameters0x00	Passive Release	Interrupt	00x04	Machine Check	Abort, Fault or Trap	on Top of stack0x08	Kernel Stack Not Valid	Abort	00x10	Reserved orPrivilegedInstruction	Fault	00x18	Reserved Operand 	Fault	00x1C	Reserved addressingMode 	Fault	00x20	Access ControlViolation	Fault	20x24	Translation notvalid	Fault	20x28	Trace Pending	Fault	00x2c	Break point	Fault	00x34	Arithmetic	Trap or Fault	10x40	CHMK	Trap	10x44	CHME	Trap	10x48	CHMS	Trap	10x4C	CHMU	Trap	10x84...0xBC	Software Level 1Software level F	Interrupt	0Vector(offset from SCBB)	Name	type	number ofParameters0xC0	Interval Timer	Interrupt	00xF8	Console TerminalReceive	Interrupt	00xFC	Console TerminalTransmit	Interrupt	0			Exception or interrupt vectors must be long word aligned. The low two bits of a vector are used to determine the stack to be used when handling the exception or interrupt. If the low two bits are 00 the Kernel stack is used (unless the interrupt stack is already in use). If the low two bits are 01 the interrupt stack is used. If the low two bits are 10 or 11 a fault occurs.Appendix GSummary of Instruction SetInstruction		Arguments (mode.Size)		Opcodeacbb 		R.B, R.B, M.B, B.W	(0x9D)acbd 		R.D, R.D, M.D, B.W	(0x6F)acbf 		R.F, R.F, M.F, B.W	(0x4F)acbl 		R.L, R.L, M.L, B.W	(0xF1)acbw 		R.W, R.W, M.W, B.W	(0x3D)adawi 		R.W, M.W	(0x58)addb2 		R.B, M.B	(0x80)addb3 		R.B, R.B, W.B	(0x81)addd2 		R.D, M.D	(0x60)addd3 		R.D, R.D, W.D	(0x61)addf2 		R.F, M.F	(0x40)addf3 		R.F, R.F, W.F	(0x41)addl2 		R.L, M.L	(0xC0)addl3 		R.L, R.L, W.L	(0xC1)addp4 		R.W, A.B, R.W, A.B	(0x20)addp6 		R.W, A.B, R.W, A.B, R.W, A.B	(0x21)addw2 		R.W, M.W	(0xA0)addw3 		R.W, R.W, W.W	(0xA1)adwc 		R.L, M.L	(0xD8)aobleq 		R.L, M.L, B.B	(0xF3)aoblss 		R.L, M.L, B.B	(0xF2)ashl 		R.B, R.L, W.L	(0x78)ashp 		R.B, R.W, A.B, R.B, R.W, A.B	(0xF8)ashq 		R.B, R.Q, W.Q	(0x79)bbc 		R.L, R.B, B.B	(0xE1)bbcc 		R.L, R.B, B.B	(0xE5)bbcci 		R.L, R.B, B.B	(0xE7)bbcs 		R.L, R.B, B.B	(0xE3)bbs 		R.L, R.B, B.B	(0xE0)bbsc 		R.L, R.B, B.B	(0xE4)bbss 		R.L, R.B, B.B	(0xE2)bbssi 		R.L, R.B, B.B	(0xE6)bcc 		B.B	(0x1E)bcs 		B.B	(0x1F)beql 		B.B	(0x13)beql 		B.B	(0x13)bgeq 		B.B	(0x18)bgequ 		B.B	(0x1E)bgtr 		B.B	(0x14)bgtru 		B.B	(0x1A)bicb2 		R.B, M.B	(0x8A)bicb3 		R.B, R.B, W.B	(0x8B)bicl2 		R.L, M.L	(0xCA)bicl3 		R.L, R.L, W.L	(0xCB)bicpsw 		R.W	(0xB9)bicw2 		R.W, M.W	(0xAA)bicw3 		R.W, R.W, W.W	(0xAB)bisb2 		R.B, M.B	(0x88)bisb3 		R.B, R.B, W.B	(0x89)bisl2 		R.L, M.L	(0xC8)bisl3 		R.L, R.L, W.L	(0xC9)bispsw 		R.W	(0xB8)bisw2 		R.W, M.W	(0xA8)bisw3 		R.W, R.W, W.W	(0xA9)Instruction		Arguments (mode.Size)		Opcodebitb 		R.B, R.B	(0x93)bitl 		R.L, R.L	(0xD3)bitw 		R.W, R.W	(0xB3)blbs 		R.L, B.B	(0xE8)blbc 		R.L, B.B	(0xE9)bleq 		B.B	(0x15)blequ 		B.B	(0x1B)blss 		B.B	(0x19)blssu 		B.B	(0x1F)bneq 		B.B	(0x12)bneq 		B.B	(0x12)bpt 			(0x3)brb 		B.B	(0x11)brw 		B.W	(0x31)bsbb 		B.B	(0x10)bsbw 		B.W	(0x30)bvc 		B.B	(0x1C)bvs 		B.B	(0x1D)callg 		A.B, A.B	(0xFA)calls 		R.L, A.B	(0xFB)caseb 		R.B, R.B, R.B	(0x8F)casel 		R.L, R.L, R.L	(0xCF)casew 		R.W, R.W, R.W	(0xAF)chme 		R.W	(0xBD)chmk 		R.W	(0xBC)chms 		R.W	(0xBE)chmu 		R.W	(0xBF)clrb 		W.B	(0x94)clrd 		W.D	(0x7C)clrf 		W.F	(0xD4)clrl 		W.L	(0xD4)clrq 		W.Q	(0x7C)clrw 		W.W	(0xB4)cmpb 		R.B, R.B	(0x91)cmpc3 		R.W, A.B, A.B	(0x29)cmpc5 		R.W, A.B, R.B, R.W, A.B	(0x2D)cmpd 		R.D, R.D	(0x71)cmpf 		R.F, R.F	(0x51)cmpl 		R.L, R.L	(0xD1)cmpp3 		R.W, A.B, A.B	(0x35)cmpp4 		R.W, A.B, R.W, A.B	(0x37)cmpv 		R.L, R.B, R.B, R.L	(0xEC)cmpw 		R.W, R.W	(0xB1)cmpzv 		R.L, R.B, R.B, R.L	(0xED)crc 		A.B, R.L, R.W, A.B	(0xB)cvtbd 		R.B, W.D	(0x6C)cvtbf 		R.B, W.B	(0x4C)cvtbl 		R.B, W.L	(0x98)cvtbw 		R.B, W.W	(0x99)cvtdb 		R.D, W.B	(0x68)cvtdf 		R.D, W.F	(0x76)cvtdl 		R.D, W.L	(0x6A)cvtdw 		R.D, W.W	(0x69)cvtfb 		R.F, W.B	(0x48)cvtfd 		R.F, W.D	(0x56)cvtfl 		R.F, W.L	(0x4A)cvtfw 		R.F, W.W	(0x49)cvtlb 		R.L, W.B	(0xF6)cvtld 		R.L, W.D	(0x6E)Instruction		Arguments (mode.Size)		Opcodecvtlf 		R.L, W.F	(0x4E)cvtlp 		R.L, R.W, A.B	(0xF9)cvtlw 		R.L, W.W	(0xF7)cvtpl 		R.W, A.B, W.L	(0x36)cvttp 		R.W, A.B, A.B, R.W, A.B	(0x26)cvtpt 		R.W, A.B, A.B, R.W, A.B	(0x24)cvtps 		R.W, A.B, R.W, A.B	(0x8)cvtrdl 		R.D, W.L	(0x6B)cvtrfl 		R.F, W.L	(0x4B)cvtsp 		R.W, A.B, R.W, A.B	(0x9)cvtwb 		R.W, W.B	(0x33)cvtwd 		R.W, W.D	(0x6D)cvtwf 		R.W, W.F	(0x4D)cvtwl 		R.W, W.L	(0x32)decb 		M.B	(0x97)decl 		M.L	(0xD7)decw 		M.W	(0xB7)divb2 		R.B, M.B	(0x86)divb3 		R.B, R.B, W.B	(0x87)divd2 		R.D, M.D	(0x66)divd3 		R.D, R.D, R.D	(0x67)divf2 		R.F, M.F	(0x46)divf3 		R.F, R.F, W.F	(0x47)divl2 		R.L, M.L	(0xC6)divl3 		R.L, R.L, W.L	(0xC7)divp 		R.W, A.B, R.W, A.B, R.W, A.B	(0x27)divw2 		R.W, M.W	(0xA6)divw3 		R.W, R.W, W.W	(0xA7)editpc 		R.W, A.B, A.B, A.B	(0x38)ediv 		R.L, R.Q, W.L, W.L	(0x7B)emodd 		R.D, R.B, R.D, W.L, W.D	(0x74)emodf 		R.F, R.B, R.F, W.L, W.F	(0x54)emul 		R.L, R.L, R.L, W.Q	(0x7A)extv 		R.L, R.B, R.B, W.L	(0xEE)extzv 		R.L, R.B, R.B, W.L	(0xEF)ffc 		R.L, R.B, R.B, W.L	(0xEB)ffs 		R.L, R.B, R.B, W.L	(0xEA)halt 			(0x0)incb 		M.B	(0x96)incl 		M.L	(0xD6)incw 		M.W	(0xB6)index 		R.L, R.L, R.L, R.L, R.L, W.L	(0xA)insqhi 		A.B, A.Q	(0x5C)insqti 		A.B, A.Q	(0x5D)insque 		A.B, A.B	(0xE)insv 		R.L, R.L, R.B, W.B	(0xF0)jmp 		A.B	(0x17)jsb 		A.B	(0x16)ldpctx 			(0x6)locc 		R.B, R.W, A.B	(0x3A)matchc 		R.W, A.B, R.W, A.B	(0x39)mcomb 		R.B, W.B	(0x92)mcoml 		R.L, W.L	(0xD2)mcomw 		R.W, W.W	(0xB2)mfpr 		R.L, W.L	(0xDB)mnegb 		R.B, W.B	(0x8E)mnegd 		R.D, W.D	(0x72)mnegf 		R.F, W.F	(0x52)mnegl 		R.L, W.L	(0xCE)Instruction		Arguments (mode.Size)		Opcodemnegw 		R.W, W.L	(0xAE)movab 		A.B, W.L	(0x9E)movad 		A.D, W.L	(0x7E)movaf 		A.F, W.L	(0xDE)moval 		A.L, W.L	(0xDE)movaq 		A.Q, W.L	(0x7E)movaw 		A.W, W.L	(0x3E)movb 		R.B, W.B	(0x90)movc3 		R.W, A.B, A.B	(0x28)movc5 		R.W, A.B, R.B, R.W, A.B	(0x2C)movd 		R.D, W.D	(0x70)movf 		R.F, W.F	(0x50)movl 		R.L, W.L	(0xD0)movp 		R.W, A.B, A.B	(0x34)movpsl 		W.L	(0xDC)movq 		R.Q, W.Q	(0x7D)movtc 		R.W, A.B, R.B, A.B, R.W, A.B	(0x2E)movtuc 		R.W, A.B, R.B, A.B, R.W, A.B	(0x2F)movw 		R.W, W.W	(0xB0)movzbl 		R.B, W.L	(0x9A)movzbw 		R.B, W.W	(0x9B)movzwl 		R.W, W.L	(0x3C)mtpr 		R.L, R.L	(0xDA)mulb2 		R.B, M.B	(0x84)mulb3 		R.B, R.B, W.B	(0x85)muld2 		R.D, M.D	(0x64)muld3 		R.D, R.D, W.D	(0x65)mulf2 		R.F, M.F	(0x44)mulf3 		R.F, R.F, W.F	(0x45)mull2 		R.L, M.L	(0xC4)mull3 		R.L, R.L, W.L	(0xC5)mulp 		R.W, A.B, R.W, A.B, R.W, A.B	(0x25)mulw2 		R.W, M.W	(0xA4)mulw3 		R.W, R.W, W.W	(0xA5)nop 			(0x1)polyd 		R.D, R.W, A.B	(0x75)polyf 		R.F, R.W, A.B	(0x55)popr 		R.W	(0xBA)prober 		R.B, R.W, A.B	(0xC)probew 		R.B, R.W, A.B	(0xD)pushab 		A.B	(0x9F)pushad 		A.D	(0x7F)pushaf 		A.F	(0xDF)pushal 		A.L	(0xDF)pushaq 		A.Q	(0x7F)pushaw 		A.W	(0x3F)pushl 		R.L	(0xDD)pushr 		R.W	(0xBB)rei 			(0x2)remqhi 		A.Q, W.L	(0x5E)remqti 		A.Q, W.L	(0x5F)remque 		A.B, W.L	(0xF)ret 			(0x4)rotl 		R.B, R.L, W.L	(0x9C)rsb 			(0x5)sbwc 		R.L, M.L	(0xD9)scanc 		R.W, A.B, A.B, R.B	(0x2A)skpc 		R.B, R.W, A.B	(0x3B)sobgeq 		M.L, B.B	(0xF4)Instruction		Arguments (mode.Size)		Opcodesobgtr 		M.L, B.B	(0xF5)spanc 		R.W, A.B, A.B, R.B	(0x2B)subb2 		R.B, M.B	(0x82)subb3 		R.B, R.B, W.B	(0x83)subd2 		R.D, M.D	(0x62)subd3 		R.D, R.D, W.D	(0x63)subf2 		R.F, M.F	(0x42)subf3 		R.F, R.F, W.F	(0x43)subl2 		R.L, M.L	(0xC2)subl3 		R.L, R.L, W.L	(0xC3)subp4 		R.W, A.B, R.W, A.B	(0x22)subp6 		R.W, A.B, R.W, A.B, R.W, A.B	(0x23)subw2 		R.W, M.W	(0xA2)subw3 		R.W, R.W, W.W	(0xA3)svpctx 			(0x7)tstb 		R.B	(0x95)tstd 		R.D	(0x73)tstf 		R.F	(0x53)tstl 		R.L	(0xD5)tstw 		R.W	(0xB5)sys 		R.B	(0xFC)xorb2 		R.B, M.B	(0x8C)xorb3 		R.B, R.B, W.B	(0x8D)xorl2 		R.L, M.L	(0xCC)xorl3 		R.L, R.L, W.L	(0xCD)xorw2 		R.W, M.W	(0xAC)xorw3 		R.W, R.W, W.W	(0xAD)escd 			(0xFD)esce 			(0xFE)escf 			(0xFF)ModesR	Read Access (operand is not writen to)W	Write Access (operand is writen to but not read)M	Modify Access (operand is read used then writen to)A	Address (operand is an address)B	Read Access (operand is a Branch displacement)SizesB	Byte		(8 Bits)W	Word	(16 Bits)L	Long Word	(32 Bits)Q	Quad Word	(64 Bits)O	Oct Word	(128 Bits)F	Float		(32 Bits)D	Double	(64 Bits)G	GFloat	(64 Bits)H	HFloat	(128 Bits)Appendix HImplementation limitationsThe As assembler is based largely on the VMS macro assembler The two differ in some details:1.	The As assembler does not support macros.2.	As accepts some of the syntax of the Ultrix as assembler  For example, C style 	comments and the use of “$” to indicate an immediate operand, and “*” to 	indicate indirection.  3.	As does not support local labels.4.	There is a bug in As which sometimes causes it not to recognize 	expressions of the form expr operator expr unless there are spaces 	between the expressions and the operator.5.	The UNIX .text directive may be used in place of the VMS .code directive.The MacVAX simulator provides a large subset of the VAX architecture.  The following set of instructions which are unimplemented in this version of the simulator are:1.	All instructions to do with type D, G and H floating point 	data, e.g. movd, cvtld etc.2.	All packed decimal instructions, e.g. movp, cmpp3 etc.3.	The queue instructions, insqhi, insqti, remqhi and remqti4.	The F instructions emodf and cvtrfl.5.	The extended arithmetic instruction ediv.6.	The following character string instructions, movtc, movtuc, 	cmpc3, cmpc5, scanc, spanc, and matchc.7.	The special function instruction crc.8.	PSW bits IV, DV, FU are ignored.9.	Faults do not restore incremented or decremented registers to their old values.10.	Floating point traps and faults do not fault through the vector.13.	Translation buffer registers Do not exist.14.	FPD. String instructions are not interruptible.