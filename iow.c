#include 	<types.h>#include	<quickdraw.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include 	<retrace.h>#include 	<memory.h>#include	<StdIO.h>#define __IOW_C_#include "window.h"#include "iow.h"#include "mmemory.h"#include "docmds.h"#include	"aprintf.h"#pragma segment IOW_SERVICETEHandle TextH;address console_interrupt(void){	if( receive_interrupt )	{			clear_console_receive_interrupt();		if( transmit_interrupt )			set_console_transmit_interrupt();		return V_CTR;	}	else if ( transmit_interrupt )	{		clear_console_transmit_interrupt();		return V_CTT;	}	return (address) 0;}void set_console_transmit_interrupt(void){		IPR(SISR) |= CONSOLE_INTERRUPT_BIT; /*set the console IPL bit*/		transmit_interrupt = 1;}void clear_console_transmit_interrupt(void){		transmit_interrupt = 0;}void set_console_receive_interrupt(void){		IPR(SISR) |= CONSOLE_INTERRUPT_BIT; /*set the console IPL bit*/		receive_interrupt = 1;}void clear_console_receive_interrupt(void){		receive_interrupt = 0;}void process_output(void){	IPR(TXCS) |= (long)0x00000080; /*mark transmitter as ready*/	/*do something with IPR(TXDB) */	iow_putchar((char)IPR(TXDB));	if(IPR(TXCS) & 0x40)	{		set_console_transmit_interrupt();	}	next_transmit_interrupt = 0;}void iow_sys_putchar(	/*system call putchar*/	unsigned char c){	if(!(IPR(TXCS) & (long)0x00000080))	/*transmitter not ready*/	{		IPR(TXCS) |= (long)0x00000080; /*mark transmitter as ready*/		iow_putchar((char)IPR(TXDB));	}	iow_putchar((char)(IPR(TXDB) = c));	clear_console_transmit_interrupt();	next_transmit_interrupt = 0;}	void iow_click(	/*Handle clicks in the window*/	Point *p,	short modifiers){Boolean		shiftDown;		shiftDown = modifiers & shiftKey != 0;	/* extend if Shift is down */	TEClick(*p, shiftDown, TextH);}void iow_keypress(	/*Handles keypresses*/	long key){	IPR(RXDB) = key & BYTE_MASK;	if(IPR(RXCS) & 0x80) /*had an unread char in RXDB*/		IPR(RXDB) |= 0x8000;	IPR(RXCS) |= 0x80; /*set done bit*/	if(IPR(RXCS) & 0x40)	{		/*generate an interrupt*/		set_console_receive_interrupt();	}}char iow_sys_getchar(	/* system call getchar */	void){	clear_console_receive_interrupt(); 	/*clear the receive interrupt flag*/	if(IPR(RXCS) & 0x80) /*had an unread char in RXDB*/	{			IPR(RXCS) &= ~(long)0x00000080; /*zero the done bit*/		return((char)(IPR(RXDB) & BYTE_MASK));	}	else	{			while(!event_loop())			if(IPR(RXCS) & 0x80) /*got a char in RXDB*/			{					IPR(RXCS) &= ~(long)0x00000080; /*zero the done bit*/				return((char)(IPR(RXDB) & BYTE_MASK));			}		return(( char ) '\0');	}}void iow_undo_keypress(	void){	SysBeep(5);}void update_IO_window(	/*Handles update events*/	void){	if( ((WindowPeek) (ioWindow.windowptr))->visible == false )		return;	TEUpdate(&(ioWindow.usable), TextH);}void iow_init(void){Rect	txRect;GrafPtr savePort;	GetPort(&savePort);		SetPort(ioWindow.windowptr);		txRect = ioWindow.usable;	/*	InsetRect(&txRect, 4, 0); */		TextH = TENew(&txRect, &txRect);	/* Not growable, so destRect == viewRect */		(*TextH)->crOnly = -1;		SetCtlMax(ioWindow.vScroll, (short)(*TextH)->nLines );		iow_grow();	SetPort(savePort);}void iow_scroll(	short dh,	short dv){		TEScroll(dh,dv,TextH);}void iow_grow(void){	(*TextH)->viewRect = ioWindow.usable;	ioWindow.lsize = (short)(*TextH)->lineHeight;	ioWindow.nlines = ((short)(*TextH)->viewRect.bottom - (short)(*TextH)->viewRect.top) / (short)(*TextH)->lineHeight;}void iow_printf(	char *f,	...){char buff[512];long length;GrafPtr savePort;char *p;unsigned long *a1 = (unsigned long *) &f +  1;unsigned long *a2 = (unsigned long *) &f +  2;unsigned long *a3 = (unsigned long *) &f +  3;unsigned long *a4 = (unsigned long *) &f +  4;unsigned long *a5 = (unsigned long *) &f +  5;unsigned long *a6 = (unsigned long *) &f +  6;	GetPort(&savePort);		SetPort(ioWindow.windowptr);		length = sprintf(buff,f,*a1,*a2,*a3,*a4,*a5,*a6);		if((*TextH)->teLength + length >= 32767)			return;		TESetSelect((*TextH)->teLength,(*TextH)->teLength, TextH);		p = buff;		while(length--)		{			TEKey (*p++, TextH);			SetCtlMax(ioWindow.vScroll, (short)(*TextH)->nLines );			scrollwithinput();		}	SetPort(savePort);}void iow_putchar(	char c){GrafPtr savePort;	GetPort(&savePort);		SetPort(ioWindow.windowptr);		if((*TextH)->teLength + 1 >= 32767)			return;		TESetSelect((*TextH)->teLength,(*TextH)->teLength, TextH);		TEKey (c, TextH);		SetCtlMax(ioWindow.vScroll, (short)(*TextH)->nLines );		scrollwithinput();	SetPort(savePort);}	void activate_io_window(	/*Handles activate events*/	long is_active){#pragma unused(is_active)}void clear_io_window(	void){GrafPtr savePort;WindowPtr	hold_whichWindow = whichWindow;	GetPort(&savePort);		SetPort(ioWindow.windowptr);		TESetSelect(0,32767,TextH);		TEDelete(TextH);		SetCtlValue(ioWindow.vScroll, 0);		whichWindow = ioWindow.windowptr;		ScrollBits();		whichWindow = hold_whichWindow;		SetCtlMax(ioWindow.vScroll, (short)(*TextH)->nLines );	SetPort(savePort);}void scrollwithinput(void){short dh, dv;int line_depth;Point oldOrigin;short control_value = GetCtlValue(ioWindow.vScroll);short cur_line = (short)(*TextH)->nLines ;short num_slines = ((short)(*TextH)->viewRect.bottom - (short)(*TextH)->viewRect.top) / (short)(*TextH)->lineHeight;	if(cur_line == control_value + num_slines + 1)		SetCtlValue(ioWindow.vScroll, ++control_value );	else if(cur_line < control_value + 1)		SetCtlValue(ioWindow.vScroll, control_value = cur_line );	else if(cur_line > control_value + num_slines + 1)		SetCtlValue(ioWindow.vScroll, control_value = cur_line );	else		return;	line_depth = ioWindow.lsize;	/*depth in pixels of a line*/		oldOrigin = ioWindow.theOrigin;	/*note previous position*/	dh = 0;	ioWindow.theOrigin.v = control_value;	/*based on the position of */	dv = (short)(*TextH)->lineHeight * (oldOrigin.v - ioWindow.theOrigin.v);	/*calc amount needed to shift to new spot*/	TEScroll(dh, dv ,TextH);}void iow_cut(void){OSErr err;	if ( (err = ZeroScrap()) == noErr ) 	{		TECut(TextH);	/* after copying, export the TE scrap */		if ( (err = TEToScrap()) != noErr ) 		{			aprintf("Unable to complete copy\nError %d",err);			ZeroScrap();		}	}	else		aprintf("Unable to ZeroScrap\nError %d",err);}void iow_copy(void){OSErr err;	if ( (err = ZeroScrap()) == noErr ) 	{		TECopy(TextH);	/* after copying, export the TE scrap */		if ( (err = TEToScrap()) != noErr ) 		{			aprintf("Unable to complete copy\nError %d",err);			ZeroScrap();		}	}	else		aprintf("Unable to ZeroScrap\nError %d",err);}void file_save(void){MFILE *file_info;	if((file_info = mcreat("File Name","Output",'EDIT','TEXT')) != 0)	{		HLock((*TextH)->hText);		mwrite(file_info->fd, *(*TextH)->hText, (*TextH)->teLength);		HUnlock((*TextH)->hText);		mclose(file_info ); 				}}