#include	<types.h>#include	<quickdraw.h>#include 	<fonts.h>#include	<controls.h>#include	<resources.h>#include	<packages.h>#include 	"controldef.h"pascal longButtonArray(	short varCode,	ControlHandle theControl,	short message,	long param){#pragma unused (varCode)Rect pr; 							/*Picture Rectangle*/Rect cr; 							/*control Rectangle*/Rect dr; 							/*destination rectangle*/RgnHandle rgnH;Point *p;	if((*theControl)->contrlData == 0) 		(*theControl)->contrlData = GetResource ( 'PICT',(short) BUTTON_ARRAY_RID );	pr = ( ( (PicPtr)( *( (*theControl)->contrlData ) ) )->picFrame );	cr = (*theControl)->contrlRect;	dr = cr;		/*zero origin of picture rectangle*/	pr.right -= pr.left;	pr.bottom -= pr.top;	pr.left = 0;	pr.top = 0;		/*calculate destination rectangle*/	dr.right = dr.left + pr.right;	dr.bottom = dr.top + pr.bottom;			switch(message)	{	case drawCntl:		if((*theControl)->contrlVis)		{			rgnH = NewRgn();			GetClip(rgnH);			ClipRect(&cr);			if((*theControl)->contrlHilite < 254)			{				switch(param & 0xFFFF)				{				case in0:				case inMyUpPage:				case inUpInstruction:				case inUpByte:				case inDownByte:				case inDownInstruction:				case inMyDownPage:				case inPC:				case inAddress:				case 129:				case 0: /*draw all of control*/				default:					DrawPicture((PicHandle)((*theControl)->contrlData), &dr );					break;				}				switch((*theControl)->contrlHilite)				{				case in0:				case inMyUpPage:				case inUpInstruction:				case inUpByte:				case inDownByte:				case inDownInstruction:				case inMyDownPage:				case inPC:				case inAddress:					dr.top = (short)((*theControl)->contrlHilite - in0) * (short)15;					dr.bottom = dr.top + 15;					dr.left += 1;					InvertRect(&dr);					break;				case 129: /*thumb*/				case 0: /*No Highlight*/				default:					break;				}			}			else			{				EraseRect(&dr);				FrameRect(&dr);			}			SetClip(rgnH);			DisposeRgn(rgnH);		}						return 0;		case testCntl: /*which part of control*/		if((*theControl)->contrlVis)		{			p = (Point *) &param;			if(PtInRect(*p, &dr))				return ((short)(p->v - dr.top) / (short)15) + in0;		}		return 0;		case calcCRgns: /*returns region occupied by Control 24 bit call only*/		/*param is a region handle */		/*Param hit bit set means indicator only*/		param &= 0x00FFFFFF; /*needed for 24bit mode. One tech note suggests using 7FFFFFFF*/		/*	Debugger(); */	case calcThumbRgn: /*returns region occupied by Control 32 bit call*/	case calcCntlRgn: /*returns region occupied by Control 32 bit call*/		if(dr.right > cr.right)			dr.right = cr.right;		if(dr.bottom > cr.bottom)			dr.bottom = cr.bottom;		RectRgn((RgnHandle) param,&dr);		return 0;		case initCntl: /*Initialize control*/		/*(*theControl)->contrlData = GetResource ( 'PICT',(short) BUTTON_ARRAY_RID );*/		return 0;		case dispCntl: /*release any private memory*/		if((*theControl)->contrlData != 0) 			ReleaseResource((*theControl)->contrlData);		return 0;		case posCntl: /*shift indicator*/		return 0;		case thumbCntl: /*calc slop and limiting rects*/		return 0;		case dragCntl: /*drag indicator or whole control*/		return 0;		case autoTrack: /*track control function*/		/* must do param &= 0xFFFF; if using param*/		return 0;		default:		return 0;	}	}