#include <types.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<StdLib.h>#include	<String.h>#include	<StdIO.h>#define __REGW_C_#include "main.h"#include "window.h"#include "mmemory.h"#include "defines.h"#include "regw.h"#include "aprintf.h"#include "progw.h"#include "vax_to_68000.h"static unsigned long pwr10(	register unsigned x){register unsigned i = 1;	while(x-- > 0)	i *= 10;	return(i);}static void udec_putrnible(	long n){register unsigned long shift = pwr10(9 - regw_regnible);register unsigned long b = vax_regs[regw_reg].contents.as_ulong;				vax_regs[regw_reg].contents.as_ulong = (b - (((b / shift) % 10) * shift)) + (n * shift);}static void char_putrbyte(	long n){register long shift = ( 3 - regw_regnible) * 8;		vax_regs[regw_reg].contents.as_ulong &= ~( BYTE_MASK << shift);		vax_regs[regw_reg].contents.as_ulong |= (n & BYTE_MASK) << shift;	}static void dec_putrnible(	long n){register unsigned long shift = pwr10(9 - regw_regnible);long c = vax_regs[regw_reg].contents.as_long;register unsigned long b = abs(c);				vax_regs[regw_reg].contents.as_long = c;		b = (b - (((b / shift) % 10) * shift)) + (n * shift);		c = (( c < 0 )? -b:b);		vax_regs[regw_reg].contents.as_long = c;}static void hex_putrnible(	long n){register long shift = ( 7 - regw_regnible) * 4;		vax_regs[regw_reg].contents.as_ulong &= ~( NIBBLE_MASK << shift);		vax_regs[regw_reg].contents.as_ulong |= (n & NIBBLE_MASK) << shift;	}void regw_click(	Point *p,	short modifiers){#pragma unused(modifiers)register short line_size =  regWindow.lsize;register long column;	regw_cline = p->v / line_size + regWindow.theOrigin.v ;		if(regw_cline >= 8)	{	regw_reg = -1;		SysBeep(5);	}	else	{		regw_byte = (p->h - 4) / CharWidth('0');		if(regw_byte >= COLUMN1 && regw_byte <= ECOLUMN1)		{	regw_reg = regw_cline * 2;			column = COLUMN1;		}		else if(regw_byte >= COLUMN2 && regw_byte <= ECOLUMN2)		{	regw_reg = regw_cline * 2 + 1;			column = COLUMN2;		}		else		{	regw_reg = -1;			SysBeep(5);			regw_cline++;			update_register_window();			return;		}		switch(vax_regs[regw_reg].dis_mode)		{		case DEC_FORMAT :		case UDEC_FORMAT:				regw_regnible = regw_byte - column;				break;		case CHAR_FORMAT:				if(regw_byte >= column + 4)				{	regw_reg = -1;					SysBeep(5);				}				else					regw_regnible = regw_byte - column;				break;		case HEX_FORMAT: 				if(regw_byte >= column + 2)				regw_regnible = regw_byte - column - 2;				else				{	regw_reg = -1;					SysBeep(5);				}				break;		case FLOAT_FORMAT:				regw_regnible = regw_byte - column;				break;		default:				regw_reg = -1;				SysBeep(5);				break;		}	}		regw_cline++;	update_register_window();	return;}static void draw_r_cursor(void){register short line_size =  regWindow.lsize;Rect regw_r;	if(regw_reg == -1)		return;	regw_r.left = regw_byte * CharWidth('0') + 4;	regw_r.right = regw_r.left + CharWidth('0');	regw_r.bottom = (regw_cline - regWindow.theOrigin.v)  * line_size + regWindow.forigin;				regw_r.top	= regw_r.bottom - line_size;	regw_r.bottom -= regWindow.leading;	InvertRect(&regw_r);}void regw_keypress(	long key){	if(regw_reg == -1)		return;	/*move screen if not displayed*/	if(key == '\b' && regw_regnible)	{		regw_regnible--;		regw_byte--;	}	else if(key == '-')		vax_regs[regw_reg].contents.as_long = -vax_regs[regw_reg].contents.as_long;	else if(key == '~')		vax_regs[regw_reg].contents.as_ulong = ~vax_regs[regw_reg].contents.as_ulong;	else	{		switch(vax_regs[regw_reg].dis_mode)		{		case	DEC_FORMAT:			if(key >= '0' && key <= '9' ) 				dec_putrnible(key - '0');			else			{				SysBeep(5);				return;			}			if(regw_regnible < 9)			{				regw_regnible++;				regw_byte++;			}			break;		case	UDEC_FORMAT:			if(key >= '0' && key <= '9' ) 				udec_putrnible(key - '0');			else			{				SysBeep(5);				return;			}			if(regw_regnible < 9)			{				regw_regnible++;				regw_byte++;			}			break;		case	HEX_FORMAT:			if(key >= '0' && key <= '9' ) 				hex_putrnible(key - '0');			else if(key >= 'a' && key <= 'f')				hex_putrnible(key - 'W' );			else if(key >= 'A' && key <= 'F')				hex_putrnible(key - '7' );			else			{				SysBeep(5);				return;			}			if(regw_regnible < 7)			{				regw_regnible++;				regw_byte++;			}			break;		case CHAR_FORMAT:			char_putrbyte(key);			if(regw_regnible < 3)			{				regw_regnible++;				regw_byte++;			}			break;		case FLOAT_FORMAT:		default:			aprintf("No editing in this display mode");			break;		}	}	put_PC_in_progwindow();	update_prog_reg_display();}void regw_undo_keypress(void){}void reg_display_mode(	register long mode){register long lastmode = vax_regs[regw_reg].dis_mode;	if(regw_reg != -1)	{		switch(vax_regs[regw_reg].dis_mode = mode)		{		case DEC_FORMAT:		case UDEC_FORMAT:			if(lastmode == HEX_FORMAT)				regw_regnible += 2;			break;		case CHAR_FORMAT:			if(lastmode != CHAR_FORMAT)			{				if(lastmode == HEX_FORMAT)					regw_regnible += 2;				while(regw_regnible > 3)				{	regw_regnible--;					regw_byte--;				}			}			break;					case HEX_FORMAT:			if(lastmode != HEX_FORMAT)				if((regw_regnible -= 2) < 0)					while(regw_regnible)					{	regw_regnible++;						regw_byte++;					}			break;		case FLOAT_FORMAT:			if(lastmode == HEX_FORMAT)				regw_regnible += 2;			break;		default:			SysBeep(5);		}		update_register_window();	}}static char *RegDisp[] = {	"R0:  ","R1:  ","R2:  ","R3:  ","R4:  ","R5:  ","R6:  ","R7:  ",							"R8:  ","R9:  ","R10: ","R11: ","AP:  ","FP:  ","SP:  ","PC:  ",							"PSW: ","PSL: ","KSP  ","ESP  ","SSP  ","USP  ","ISP  ","MME  ",							"P0BR ","P0LR ","P1BR ","P1LR ","SBR  ","SLR  ","PCBB ","SCBB ",							"ASTR ","SISR ","IPLR ","ICCS ","NICR ","ICR  ","RXCS ","RXDB ",							"TXCS ","TXDB "};							static char ipr_regnum[] = { KSP,  ESP,  SSP,  USP,  ISP,  MME,							 P0BR, P0LR, P1BR, P1LR, SBR,  SLR,  PCBB, SCBB,							 ASTR, SISR, IPLR, ICCS, NICR, ICR,  RXCS, RXDB,							 TXCS, TXDB};static char mode_as_char[] = { 'K','E','S','U' };static char *Reg_display_formats[] = /*order important. see #defines in defines.h*/{	"%s%+10.10d    ",	"%s %10.10u    ",	"%s 0x%8.8x    ",	"%s\"%4.4s\"       ",	"%s%-14.14s "};	void update_register_window(void){short lbase;short last_line; short lineno = 0;RgnHandle	hold_h;long i;long j;char buff[48];register short line_size =  regWindow.lsize;register short v = line_size;union{	unsigned long x;	unsigned char xx[4];}temp;unsigned long hold_SISR = IPR(SISR);GrafPtr savePort;	if( ((WindowPeek) (regWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(regWindow.windowptr);	hold_h = NewRgn();	GetClip(hold_h);	ClipRect(&regWindow.usable);			lbase = regWindow.theOrigin.v ;	last_line = regWindow.nlines + lbase;	for(i = 0; i < 16; i += 2)	{		if(lineno >= lbase && lineno < last_line)		{			MoveTo(4, v);			temp.x = vax_regs[i].contents.as_ulong;			for(j = 0; j < 4; j++)				temp.xx[j] = ( temp.xx[j] < 0x7f && temp.xx[j] > 0x1f ) ? temp.xx[j]:0xff;			sprintf(buff,Reg_display_formats[vax_regs[i].dis_mode],						 RegDisp[i], 						vax_regs[i].dis_mode == CHAR_FORMAT ? temp.xx : 						(vax_regs[i].dis_mode == FLOAT_FORMAT ? 						f2s(vax_regs[i].contents.as_v_float):						(void *)vax_regs[i].contents.as_ulong) );			temp.x = vax_regs[i+1].contents.as_ulong;			for(j = 0; j < 4; j++)				temp.xx[j] = ( temp.xx[j] < 0x7f && temp.xx[j] > 0x1f ) ? temp.xx[j]:0xff;			sprintf(&buff[ECOLUMN1+5],Reg_display_formats[vax_regs[i+1].dis_mode],						RegDisp[i+1],						vax_regs[i+1].dis_mode == CHAR_FORMAT ? temp.xx : 						(vax_regs[i+1].dis_mode == FLOAT_FORMAT ? 						f2s(vax_regs[i+1].contents.as_v_float):						(void *)vax_regs[i+1].contents.as_ulong) );			DrawText(buff,(short)0,(short) strlen(buff));			if(regw_reg == i || regw_reg == (i + 1))				draw_r_cursor();			v += line_size;		}		lineno++;	}	if(lineno >= lbase && lineno < last_line)	{		MoveTo(4,v);		sprintf(buff,"%s %c%c%c%c%c%c%c%c       ",RegDisp[i],			vax_psl & DOFTRAP ?		'D':' ',			vax_psl & FUFTRAP ?		'F':' ',			vax_psl & IOFTRAP ?		'I':' ',			vax_psl & TRACE ?		'T':' ',			vax_psl & CARRY ?		'C':' ',			vax_psl & OVERFLOW ?	'V':' ',			vax_psl & ZERO ?		'Z':' ',			vax_psl & NEGATIVE ?	'N':' ');		sprintf(&buff[ECOLUMN1+5],"%s 0x%8.8x ", RegDisp[i+1],  PSL);		DrawText(buff,(short)0,(short) strlen(buff));		v += line_size;	}	lineno++;		if(lineno >= lbase && lineno < last_line)	{		MoveTo(4, v);		sprintf(buff,"PSHW:  %c %c %s %s %s%c %s%c %s%2.2x",			CM ?		'C':' ',			TP ?		'T':' ',			FPD ?		"FPD":"   ",			IS ?		"IS":"  ",			"CMD=",mode_as_char[CMD],					"PMD=",mode_as_char[PMD],			"IPL=",IPL);		for(j = strlen(buff); j < 40; j++)			buff[j] = ' ';		buff[j] = '\0';		DrawText(buff,(short)0,(short) 40);		v += line_size;	}	lineno++;		/*internal processor registers*/	IPR(SISR) &= 0xFFFE; /*Blat hardware interrupt bits I'm storing in this register*/	IPR(IPLR) = IPL;	 /*Fudge the IPLR to match IPL*/	if(IS)				 /*Fudge IPR(Stack Pointer) to match SP*/		IPR(ISP) = SP;	else		IPR(CMD) = SP;	for(i = 18; i < 42; i += 2)	{		if(lineno >= lbase && lineno < last_line)		{			MoveTo(4, v);			temp.x = IPR(ipr_regnum[i-18]);			for(j = 0; j < 4; j++)				temp.xx[j] = ( temp.xx[j] < 0x7f && temp.xx[j] > 0x1f ) ? temp.xx[j]:0xff;			sprintf(buff,Reg_display_formats[ipr[ipr_regnum[i-18]].dis_mode],						 RegDisp[i], 						ipr[ipr_regnum[i-18]].dis_mode == CHAR_FORMAT ? temp.xx : 						(ipr[ipr_regnum[i-18]].dis_mode == FLOAT_FORMAT ? 						f2s(ipr[ipr_regnum[i-18]].contents.as_v_float):						(void *)ipr[ipr_regnum[i-18]].contents.as_ulong) );			temp.x = IPR(ipr_regnum[i-17]);;			for(j = 0; j < 4; j++)				temp.xx[j] = ( temp.xx[j] < 0x7f && temp.xx[j] > 0x1f ) ? temp.xx[j]:0xff;			sprintf(&buff[ECOLUMN1+5],Reg_display_formats[ipr[ipr_regnum[i-17]].dis_mode],						RegDisp[i+1],						ipr[ipr_regnum[i-17]].dis_mode == CHAR_FORMAT ? temp.xx : 						(ipr[ipr_regnum[i-17]].dis_mode == FLOAT_FORMAT ? 						f2s(ipr[ipr_regnum[i-17]].contents.as_v_float):						(void *)ipr[ipr_regnum[i-17]].contents.as_ulong) );			drawstring(buff);			if(regw_reg == i || regw_reg == (i + 1))				draw_r_cursor();			v += line_size;		}		lineno++;	}	IPR(SISR) = hold_SISR; /*restore hardware interrupt bits I'm storing in this register*/		SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);}void activate_register_window(	long is_active){	if(is_active)	{		EnableItem (MyMenus[optionMenu], DisplayHexCommand);		EnableItem (MyMenus[optionMenu], DisplaydecCommand);		EnableItem (MyMenus[optionMenu], DisplayudecCommand);		EnableItem (MyMenus[optionMenu], DisplayasciiCommand);		EnableItem (MyMenus[optionMenu], DisplayfloatCommand);		DisableItem(MyMenus[runMenu],    watchCommand);	}	else	{		DisableItem(MyMenus[optionMenu], DisplayHexCommand);		DisableItem(MyMenus[optionMenu], DisplaydecCommand);		DisableItem(MyMenus[optionMenu], DisplayudecCommand);		DisableItem(MyMenus[optionMenu], DisplayasciiCommand);		DisableItem(MyMenus[optionMenu], DisplayfloatCommand);		EnableItem (MyMenus[runMenu],    watchCommand);		regw_reg = -1;		/*update_register_window();*/	}}void fix_scrollbars_regw(void){	SetCtlMax(regWindow.vScroll, 22); }void regw_init(void){	SetCtlMin(regWindow.vScroll, 0); 	fix_scrollbars_regw();	SetCtlValue(regWindow.vScroll,0);}