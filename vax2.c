#include	<types.h>#include	<quickdraw.h>#include	<windows.h>#include	<OSutils.h>#include	<controls.h>#include 	<ToolUtils.h>#include 	<ctype.h>#include	<StdLib.h>#include	<StdIO.h>//#include	<desk.h>#include	<menus.h>#define VAX_C#include 	"mmemory.h"#include 	"window.h"#include 	"xfc.h"#include 	"arithmetic_fault.h"#include	"exception.h"#include 	"vax.h"#include 	"iow.h"#include 	"func.h"#include	"clock.h"#include	"docmds.h"#include	"execute.h"#include	"vax_to_68000.h"#include	"macio.h"#include	"vaxmacio.h"#include	"progw.h"#include	"stackw.h"#include	"aprintf.h"#include	"sysw.h"#include	"process.h"#include	"macdev.h"#include	"main.h"#include	"symbol_tab.h"#pragma segment VaxIns2/*Character Instructions --------------------------------------------- */static unsigned long movcx(	register unsigned long src,	register unsigned long dst,	register unsigned long len){register unsigned long i;	if(dst < src)	{		for( i = 0; i < len; i++)	 	{	 		vax_putb(vax_fetchb(src++),dst++);			if(stop == 1)			{	R1 = src;				R3 = dst;				return ( i+1 );			}		}	}	else if(dst > src)	{		src += len;		dst += len;	 	for( i = 0; i < len; i++)		{	 		vax_putb(vax_fetchb(--src),--dst);			if(stop == 1)			{	R1 = src;				R3 = dst;				return ( i+1 );			}		}	}	return(len);}static unsigned long mem_fill(	register unsigned long dst,	char fill,	register unsigned long len){register unsigned long i;	for( i = 0; i < len; i++)	{	 	vax_putb(fill,dst++);			if(stop == 1)			{					R3 = dst;				return ( i+1 );			}	}	return(len);}void movc3(char * notused){#pragma unused(notused)register unsigned long len = (unsigned long)vax_fetchw(opaddr[0]);register address src = (unsigned long)opaddr[1];register address dst = (unsigned long)opaddr[2];register unsigned long i;	N = C = V = 0;	Z = 1;	if((i = movcx(src,dst,len))  != len)	{	/*had an interrupt of some kind*/		R2 = R0 = len - i;	}	else	{	/*normal copy*/		R2 = R0 = 0;		R1 = src + len;		R3 = dst + len;	}	R5 = R4 = 0;}void movc5(char * notused){#pragma unused(notused)unsigned long srclen = (unsigned long)vax_fetchw(opaddr[0]);register address src = (unsigned long)opaddr[1];byte fill = vax_fetchb(opaddr[2]);unsigned long dstlen = (unsigned long)vax_fetchw(opaddr[3]);register address dst = (unsigned long)opaddr[4];register unsigned long len;register unsigned long i;	if(dstlen < srclen)	{		len = dstlen;		C = Z = V = 0;		N = (word) srclen < (word) dstlen;		if((i = movcx(src,dst,len)) != len)		{	/*had an interrupt of some kind*/			R2 = R0 = len - i;		}		else		{	/*normal copy*/			R0 = srclen - dstlen;			R2 = 0;			R1 = src + len;			R3 = dst + dstlen;		}	}	else if(dstlen > srclen)	{		len = srclen;		R0 = 0;		C = 1;		Z = V = 0;		N = (word) srclen < (word) dstlen;		if((i = movcx(src,dst,len)) != len)		{	/*had an interrupt of some kind*/			R0 = len - i;			R2 = dstlen - i;		}		else		{			if((i = mem_fill(dst + len,fill,dstlen - srclen)) != len)			{	/*had an interrupt of some kind*/				R0 = 0;				R2 = dstlen - srclen - i;			}			else			{	/*normal copy*/				R1 = src + len;				R3 = dst + dstlen;				R0 = 0;				R2 = 0;			}		}			}	else //(dstlen == srclen)	{		N = C = V = 0;		Z = 1;		len = srclen;		if((i = movcx(src,dst,len))  != len)		{	/*had an interrupt of some kind*/			R2 = R0 = len - i;		}		else		{	/*normal copy*/			R2 = R0 = 0;			R1 = src + len;			R3 = dst + len;		}	}	R5 = R4 = 0;}void locc(char * notused){#pragma unused(notused)register char to_find = vax_fetchb(opaddr[0]);register unsigned long len = (unsigned long)vax_fetchw(opaddr[1]);register unsigned long addr = opaddr[2];register char nextchar;	N = C = V = 0;	while(len--)	{		 nextchar = vax_fetchb(addr) ;		 if(stop == 1)		 {		 	R0 = len;			R1 = addr + 1;		   return;		 }		 else		 {		 	if(nextchar == to_find)			{				R0 = len + 1;				R1 = addr;				Z = 0;				return;			}			addr++;		}	}	R0 = 0;	R1 = addr;	Z = 1;}void skpc(char * notused){#pragma unused(notused)register char to_find = vax_fetchb(opaddr[0]);register unsigned long len = (unsigned long)vax_fetchw(opaddr[1]);register unsigned long addr = opaddr[2];register char nextchar;	N = C = V = 0;	while(len--)	{		 nextchar = vax_fetchb(addr) ;		 if(stop == 1)		 {		 	R0 = len;			R1 = addr + 1;		   return;		 }		 else		 {		 	if(nextchar != to_find)			{				R0 = len + 1;				R1 = addr;				Z = 0;				return;			}			addr++;		}	}	R0 = 0;	R1 = addr;	Z = 1;}/*void cmpc3(char * notused){#pragma unused(notused)register unsigned long len = (unsigned long) vax_fetchw(opaddr[0]);register unsigned long src1 = (unsigned long)opaddr[1];register unsigned long src2 = (unsigned long)opaddr[2];	V = 0;}*//*all cases of case*/void caseb(char * notused){#pragma unused(notused)long diff  = vax_fetchb(opaddr[0]) - vax_fetchb(opaddr[1]);long limit = vax_fetchb(opaddr[2]);unsigned long ulimit = limit & BYTE_MASK;	if(LEQU(diff,ulimit))		PC += (long) vax_fetchw( PC + diff * 2);	else		PC += ulimit * 2 + 2;	SETNZ( diff , limit );	V = 0;	C = LSSU( diff , ulimit );}void casew(char * notused){#pragma unused(notused)long diff  = vax_fetchw(opaddr[0]) - vax_fetchw(opaddr[1]);long limit = vax_fetchw(opaddr[2]);unsigned long ulimit = limit & WORD_MASK;	if(LEQU(diff,ulimit))		PC += (long) vax_fetchw( PC + diff * 2);	else		PC += ulimit * 2 + 2;	SETNZ( diff , limit );	V = 0;	C = LSSU( diff , ulimit );}void casel(char * notused){#pragma unused(notused)long diff  = vax_fetchl(opaddr[0]) - vax_fetchl(opaddr[1]);long limit = vax_fetchl(opaddr[2]);	if(LEQU(diff,limit))		PC += (long) vax_fetchw( PC + diff * 2);	else		PC += limit * 2 + 2;	SETNZ( diff , limit );	V = 0;	C = LSSU( diff , limit );}/*		Procedure Calls	------------------------------------------ */void jsb(char * notused){#pragma unused(notused)	SP -= 4;	vax_putl( PC, SP );	PC = opaddr[0];}void rsb(char * notused){#pragma unused(notused)	PC = vax_fetchl( SP );	SP += 4;}	static void process_entry_mask(	long s	/*calls s == 1, callg s == 0*/){word entry_mask = vax_fetchw(opaddr[1]);word p;long r;union{	unsigned long	x;	struct	{		unsigned long	spa:2;		unsigned long	SorG:1;		unsigned long 	bit28:1;		unsigned long	mask:12;		unsigned long   psw: 16;	}xx;}xxx;			if(entry_mask & 0x3000)	{	/*manual says these bits must be zero*/		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		stop = 1;		return;	}	xxx.xx.spa = SP & 3;/*count thy decrements*/	xxx.xx.SorG = s;	xxx.xx.bit28 = 0;	xxx.xx.mask = entry_mask & 0xFFF;	/*low 12 bits of entry mask*/	xxx.xx.psw = PSW & 0xFFE0;				/*psw part of psl with low 5 bits cleared*/	SP &= ~3;	 /*align stack pointer to a long boundary*/		for( r = 11, p = 0x800; p ; p >>= 1, --r )	/*push onto stack marked registers*/		if( entry_mask & p )		{			SP -= 4;			vax_putl( vax_regs[ r ].contents.as_long, SP );		}	vax_psl &= ~NIBBLE_MASK;	/*Clear NZCV bits*/	SP -= 4;	vax_putl( PC, SP );	SP -= 4;	vax_putl( FP, SP );	SP -= 4;	vax_putl( AP, SP );	SP -= 4;	vax_putl(xxx.x,SP);	SP -= 4;	vax_putl(0L, SP);	FP = SP;	IV = (entry_mask >> 14) & NIBBLE_MASK;	DV = (entry_mask >> 15) & NIBBLE_MASK;	FU = 0;}	void calls(char * notused){#pragma unused(notused)long hold_ap;	hold_ap = SP -= 4;	vax_putl(vax_fetchl(opaddr[0]), SP);	process_entry_mask(1);	AP = hold_ap;	PC = opaddr[1] + 2;}void callg(char * notused){#pragma unused(notused)	process_entry_mask(0);	AP = opaddr[0];	PC = opaddr[1] + 2;}void ret(char * notused){#pragma unused(notused)word entry_mask;word p;long r;union{	unsigned long	x;	struct	{		unsigned long	 spa:2;		unsigned long	 SorG:1;		unsigned long 	 bit28:1;		unsigned long	 mask:12;		unsigned long    psw: 16;	}xx;}xxx;	SP = FP + 4; /*set SP to pickup the saved mask and psw*/	xxx.x = vax_fetchl(SP);	SP += 4;	AP = vax_fetchl(SP);	SP += 4;	FP = vax_fetchl(SP);	SP += 4;	PC = vax_fetchl(SP);	SP += 4;	entry_mask = xxx.xx.mask;	for( r = 0, p = 0x1; p <= 0x800 ; p <<= 1, r++ )	/*pop off of stack marked registers*/		if( entry_mask & p )		{			vax_regs[ r ].contents.as_long = vax_fetchl( SP );			SP += 4;		}	SP |= xxx.xx.spa;	/*drop stack alignment*/	PSW = xxx.xx.psw & BYTE_MASK;	if(xxx.xx.SorG)		SP += (vax_fetchl(SP) & BYTE_MASK) * 4 + 4; /*was a calls instruction pop the arguments*/	if(xxx.xx.psw & HI_BYTE_MASK)	{	/*manual says these bits must be zero*/		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		stop = 1;		return;	}}	/*Queue Instructions*/static address	Validate_address(	/*Returns physical address if address can be accessed with mode to for sizeof(long)*/	/*the return address should only be used if aligned == 1*/	/*Returns ERROR if can't access address for sizeof(long) with mode*/	/*if aligned is 1 addr must be long word aligned*/	/*Used for validating queue commands can be completed*/	address addr,	long aligned,	long mode){address phys_addr = 0;	switch(aligned)	{	case 0:	/*Long word, unaligned*/		if((addr & ~REG_MASK) == REGBASE)	/*Accept the fake addresses used for registers*/			break;		if(check_reference( addr++, CMD, mode, 0) == ERROR )  /*check we can write to the first byte*/			return ERROR;	/*failed*/		if(check_reference( addr++, CMD, mode, 0) == ERROR )  /*check we can write to the second byte*/			return ERROR;	/*failed*/		if(check_reference( addr++, CMD, mode, 0) == ERROR )  /*check we can write to the third byte*/			return ERROR;	/*failed*/		if(check_reference( addr  , CMD, mode, 0) == ERROR )  /*check we can write to the fourth byte*/			return ERROR;	/*failed*/		break;		case 1: /*Aligned to long word*/		if(addr & 0x3)	/*check for long word aligned*/		{			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);			return ERROR;		}		if(( phys_addr = check_reference( addr, CMD, mode, 0)) == ERROR )  /*check we can write to the first byte*/			return ERROR;	/*failed*/		break;	case 2:	/*aligned quad word*/		if(addr & 0x7)	/*check for quad word aligned*/		{			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);			return ERROR;		}		if(( phys_addr = check_reference( addr, CMD, mode, 0)) == ERROR )  /*check we can write to the first byte*/			return ERROR;	/*failed*/		break;	default:		aprintf("Internal MACVAX BUG: Bad case in Validate_Address().");		break;	}	return phys_addr;}void insque(char * notused){#pragma unused(notused)address entry  = (unsigned long) opaddr[0];	/*new entry being added to the queue*/address pred   = (unsigned long) opaddr[1];	/*Member item is being added after*/address succ;				/*Member item is being added before*/address entry_r_forw;		/*Real address of entry forward link*/address entry_r_back; 		/*Real address of entry backward link*/address pred_r_forw;		/*Real address of predecessor forward link*/address succ_r_back;		/*Real address of successor backward link*//*unsigned int old_ipl = IPL;	/*Save ipl as we alter it */	/*turn all interrupts off here*/	/*IPL = 0x1F;*/		/*need to verify all addresses being accessed are valid*/		if( ( entry_r_forw = Validate_address(entry,1,WR) ) == ERROR	||  ( entry_r_back = Validate_address(entry + 4,1,WR))  == ERROR	||  ( pred_r_forw  = Validate_address(pred,1,WR) ) == ERROR )	{		/*IPL = old_ipl;*/		return;	}	succ = (address) vax_fetchl(pred);	if( ( succ_r_back = Validate_address(succ + 4,1,WR) ) == ERROR )	{		/*IPL = old_ipl;*/		return;	}	/*We now know we can access all needed addresses*/			vax_putliR(succ,  entry_r_forw);	/*fill in forward pointer of entry*/	vax_putliR(pred,  entry_r_back);	/*fill in backward pointer of entry*/	vax_putliR(entry, pred_r_forw);		/*fill in forward pointer of pred*/	vax_putliR(entry, succ_r_back); 	/*fill in backward pointer of succ*/		N = LSS((long)succ, (long)pred);	Z = EQL(succ, pred);	V = 0;	C = LSSU(succ,pred);		/*IPL = old_ipl;*/}void remque(char * notused){#pragma unused(notused)address entry  = (unsigned long) opaddr[0];		/*new entry being added to the queue*/address addr = (unsigned long) opaddr[1]; 		/*Address to write entry address to*/	address pred;					/*Member item is being added after*/address succ;					/*Member item is being added before*/address entry_r_forw;			/*Real address of entry forward link*/address entry_r_back; 			/*Real address of entry backward link*/address pred_r_forw;			/*Real address of predecessor forward link*/address succ_r_back;			/*Real address of successor backward link*//*unsigned int old_ipl = IPL;		/*Save IPL as we change it*/	/*turn all interrupts off here*/	/*IPL = 0x1F;*/		/*need to verify all addresses being accessed are valid*/		if( ( entry_r_forw = Validate_address(entry,1,RD) ) == ERROR	||  ( entry_r_back = Validate_address(entry + 4,1,RD))  == ERROR 	||  Validate_address(addr,0,WR)  == ERROR )	{		/*IPL = old_ipl;*/		return;	}		pred = 	vax_fetchliR( entry_r_back );	succ =  vax_fetchliR( entry_r_forw );		if( ( succ_r_back  = Validate_address(succ + 4,1,WR) ) == ERROR 	||  ( pred_r_forw  = Validate_address(pred,1,WR) ) == ERROR )	{		/*IPL = old_ipl;*/		return;	}		/*We now know we can access all needed addresses*/			vax_putliR(succ,  pred_r_forw);	/*fill in forward pointer of entry*/	vax_putliR(pred,  succ_r_back);	/*fill in backward pointer of entry*/	vax_putl(entry,addr);		N = LSS((long)succ, (long)pred);	Z = EQL(succ, pred);	V = EQL(entry, pred);	/*only item in queue*/	C = LSSU(succ,pred);		/*IPL = old_ipl;*/}// HALT & NOPvoid halt(char * notused){#pragma unused(notused)	if(is_a_system)	{		/*behave as a real halt*/		if(CMD != KSP)		{			N = Z = V = C = 0;			reserved_or_priviledged("halt");			return;		}		else			stop = 1;	}	else	/*Halt for the user*/		stop = 1;}	void nop(char * notused){#pragma unused(notused)}/*move to and from processor registers*/void mtpr(char * notused){#pragma unused(notused)register long source = vax_fetchl(opaddr[0]);register long regnum = vax_fetchl(opaddr[1]);void reserved_or_priviledged(char *p);	if(CMD != KSP)	{		reserved_or_priviledged("mtpr");		return;	}	V = C = 0;	SETNZ(source, 0 );	switch(regnum)	{	case	SCBB:		if((source & 0xC00001FF)		|| source >= IPR(MVMEM) )		{			aprintf("Invalid Value for SCBB %8.8X\nHalting CPU",source);			stop = 1;		}		else			IPR(regnum) = source;		break;	case PCBB:	/*don't let a bad address be put intp PCBB*/		if(source < 0 || source > REAL_MEM_SIZE)			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else			IPR(regnum) = source;		break;	case MME:		if(source & ~1)			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else 		{			IPR(MME) = source;			set_maxscroll_sysw();			cdlines();			sklines();			syslines();		}					break;	case P0BR:		if((source & R_SPACE) == S_SPACE	/*in system space*/		&& (!(source & 0x3)) 				/*Aligned*/			  )			IPR(regnum) = source;		else			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	case P1BR:		if(((unsigned long)source >= (unsigned)0x7f800000) /*Vaild address base for P1BR*/		&& (source & R_SPACE) != R_SPACE					/*Not in R Space*/		&& (!(source & 0x3))								/*Aligned*/		  )			IPR(regnum) = source;		else			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	case P0LR:		IPR(P0LR) = source & PAGE_LENGTH_MASK;		cdlines();		set_maxscroll_sysw();		break;	case P1LR:		IPR(P1LR) = source & PAGE_LENGTH_MASK;		sklines();		set_maxscroll_sysw();		break;	case SBR:		if ( (unsigned long) source < REAL_MEM_SIZE		&&   (!(source & 0x3))			)			IPR(SBR) = source;		else			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	case SLR:		IPR(SLR) = source & PAGE_LENGTH_MASK;		syslines();		set_maxscroll_sysw();		break;	case KSP:	case ESP:	case SSP:	case USP:	case ISP:		IPR(IS ? 0x4: CMD) = SP;	/*save current SP*/		IPR(regnum) = source;		SP = IPR(IS ? 0x4: CMD);	/*Restore Current SP incase it changed*/		break;	case SISR:		IPR(regnum) = source & SISR_MASK;		break;	case SIRR:		IPR(SISR) |= (1 << (source & NIBBLE_MASK)) & SISR_MASK;		break;	case TODR:	/*time of year*/		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	case NICR :	/*(write only) next interval count register*/		IPR(NICR) = source; /*load it*/		break;	case ICCS :	/*interval clock control/status register*/		if(ICCS_MBZ(source))			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else		{			if(ICCS_ERR(source))				IPR(ICCS) &= ~ICCS_ERR_BIT; /*clear bit if set in source*/						/*do this before INT_ENB bit so we don't generate an unexpected interrupt*/			if(ICCS_INT(source))				IPR(ICCS) &= ~ICCS_INT_BIT; /*clear bit if set in source*/						IPR(ICCS) &= ~ICCS_INT_ENB_BIT; 	/*clear the bit*/			IPR(ICCS) |= ICCS_INT_ENB(source);	/*set it if appropriate*/			if( ICCS_INT_ENB(source) && ICCS_INT( IPR(ICCS) ) )	/*if interrupt enable is being set && interrupt bit is set generate an interrupt*/				IPR(SISR) |= ICR_INTERRUPT_BIT; /*IPL 24*/						/*Must be before SGL bit code so clock_tick() works*/			IPR(ICCS) &= ~ICCS_RUN_BIT; 	/*clear the run bit*/			IPR(ICCS) |= ICCS_RUN(source);	/*set it if appropriate*/			/*Must come after RUN bit code so clock_tick() works*/			if(ICCS_SGL(source) && ICCS_RUN(source) == 0)	/*(write only bit) single inc of ICR if run bit clear*/				clock_tick(ICCS_SGL_BIT,1);					/*using NEW RUN bit not old one*/						if(ICCS_XFR(source))	   /*(write only) transfer NICR to ICR*/				IPR(ICR) = IPR(NICR); /*Question which if this occurs before or after SGL action*/												 }		 break;					case MVCS :	/*MACVAX control/status register*/		if(MVCS_MBZ(source))			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else		{			if(MVCS_ERR(source))				IPR(MVCS) &= ~MVCS_ERR_BIT; /*clear bit if set in source*/						/*do this before INT_ENB bit so we don't generate an unexpected interrupt*/			if(MVCS_INT(source))				IPR(MVCS) &= ~MVCS_INT_BIT; /*clear bit if set in source*/						IPR(MVCS) &= ~MVCS_INT_ENB_BIT; 	/*clear the bit*/			IPR(MVCS) |= MVCS_INT_ENB(source);	/*set it if appropriate*/			if( MVCS_INT_ENB(source) && MVCS_INT( IPR(MVCS) ) )	/*if interrupt enable is being set && interrupt bit is set generate an interrupt*/				IPR(SISR) |= MACVAX_INTERRUPT_BIT; /*IPL 23*/					 }		 break;					case RXCS:	/*Console Receive Control/Status */		if(source & ~(long)0x40) /*attempt to set bits other than interrupt enabled*/			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else		{			IPR(RXCS) = (source & 0x40)  | (IPR(RXCS) & 0x80);			if((IPR(RXCS) & 0x80) && (source & 0x40)) /*done and interrupt enabled*/			{	/*generate interrupt*/				set_console_receive_interrupt(); /*set the console IPL bit*/			}		}		break;	case TXCS:	/*Console Transmit Control/Status */		if(source & ~(long)0x40) /*attempt to set bits other than interrupt enabled*/			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else		{			IPR(TXCS) = (source & 0x40)  | (IPR(TXCS) & 0x80);			if((IPR(TXCS) & 0x80) && (source & 0x40)) /*ready and interrupt enabled*/			{	/*generate interrupt*/				set_console_transmit_interrupt(); /*set the console IPL bit*/			}		}		break;	case TXDB:	/*Console Transmit Data Buffer (write only)*/		if(source & ~BYTE_MASK) /*more than just data present*/			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else		{		short variation;			if((IPR(TXCS) & 0x80))  /*transmitter is not ready. ie. has a char in buffer*/			{	/*Generate delay until char output*/				/*The If is so we don't delay forever if constantly overwritting buffer*/				variation = Random();				next_transmit_interrupt = ( variation & 0x3F ) + 20;			}			IPR(TXDB) = source;			IPR(TXCS) &= ~(long)0x80; /*mark transmitter as not ready*/		}		break;	case IPLR:		IPL = source & 0x1F;		break;	case ASTR:		IPR(ASTR) = source & 0x7;		break;		case IORST:/*(write only) unibus reset*/		if(source & ~1) 		/*Top bits MBZ*/			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break; /*Otherwise ignore for the moment*/			case MVPID:	/*Set the current index for the user symbol table info*/		use_user_symbol_table(source);		break;			case MCESR:	/*machine check error summary register*/		if( source & ~(EXBUF_ERR | TB_ERR | BUS_ERROR) )			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		else 		{			if(source & EXBUF_ERR)				IPR(MCESR) &= ~EXBUF_ERR;			if(source & TB_ERR)				IPR(MCESR) &= ~TB_ERR;			if(source & BUS_ERROR)			{				IPR(MCESR) &= ~BUS_ERROR;				IPR(MCSR) &= ~MCSR_BUS_ERR;			}		}		break;				case CSRS :	/*TU58 Control Storage Receive Status*/	case CSTS: 	/*TU58 Control Storage Transmit Status*/	case CSTD:	/*(write only) TU58 Control Storage Transmit Data*/	case CAER:	/*cache error register*/	case CADR:	/*cache disbale register*/	case TBDR:	/*Translation buffer disable register*/	case PMR:	/*performance Monitor*/		case TBIA:	/*(write only) Translation Buffer Invalidate all*/	case TBIS:	/*(write only) Translation Buffer Invalidate Single*/	case TBHP:	/*(write only) Probe Translatiob Buffer for TB Hit*/		break; /*Ignore writes to these registers*/		case MVCR:	/*MacVAX command register (Read Only*/	case KFP:	/*MACVAX Frame pointer holding registers (READ ONLY)*/	case EFP:	case SFP:	case UFP:	case IFP:	case TBD:	/*This along with P0BR are used to probe the Translation Buffer*/				/*Only valid for diagnostics when MME == 0 (Not implemented)*/	case ACCS:	/*(Read Only)*/	case CSRD:	/*(Read Only) TU58 Control Storage Receive Data*/	case MCSR:	/*(Read Only)*/	case SID:	/*(Read Only)*/	case ICR  :	/*interval count register (read only)*/	case RXDB:	/*Console Receive Data Buffer (read only)*/	case MVMEM:	/*MACVAX Available physical memory (Read only)*/	default:		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	}}void mfpr(char * notused){#pragma unused(notused)long regnum = vax_fetchl(opaddr[0]);unsigned long time = 0;long dst = 0;void reserved_or_priviledged(char *p);		if(CMD != KSP)	{		reserved_or_priviledged("mfpr");		return;	}	V = C = 0;	switch(regnum)	{	case KSP:	case ESP:	case SSP:	case USP:	case ISP:		if(IS)			IPR(ISP) = SP;		else			IPR(CMD) = SP;	case P0BR:	case P0LR:	case P1BR:	case P1LR:	case SBR:	case SLR:	case SCBB:	case PCBB:	case MME:	case MCESR:	/*machine check error summary register*/	case MCSR:	/*machine Check Status register*/	case CSRD: /*(Read Only) TU58 Control Storage Receive Data*/	case CSRS :	/*TU58 Control Storage Receive Status*/	case CSTS: 	/*TU58 Control Storage Transmit Status*/	case CAER:	/*cache error register*/	case CADR:	/*cache disable register*/	case TBDR:	/*Translation buffer disable register*/	case ACCS:	/*Accelerator Control/Status*/	case PMR:	/*Performance Monitor Enable Register*/	case SID:	/*System Identification*/	case RXCS:	/*Console Receive Control/Status */	case TXCS:	/*Console Transmit Control/Status */	case MVCR:	/*MacVAX command register*/	case MVCS:	/*MacVAX command status register*/	case MVPID:	/*Get the current index for the user symbol table info*/	case MVMEM:	/*MACVAX Available physical memory (Read only)*/		vax_putl(dst = IPR(regnum),opaddr[1]);		break;	case KFP:	case EFP:	case SFP:	case UFP:	case IFP:		if(IS)			IPR(IFP) = FP;		else			IPR(CMD+KFP) = FP;		vax_putl(dst = IPR(regnum),opaddr[1]);		break;	case SISR:		vax_putl(dst = IPR(regnum) & SISR_MASK ,opaddr[1]);		break;	case TODR:	/*time of year*/		(void) ReadDateTime (&time) ;		vax_putl(dst = (time * 100) ,opaddr[1]);		break;	case RXDB:	/*Console Receive Data Buffer (read only)*/		vax_putl(dst = IPR(RXDB),opaddr[1]);		IPR(RXCS) &= ~(long)0x80; /*zero the done bit*/		break;	case IPLR:		vax_putl(dst = IPL,opaddr[1]);		break;	case ICCS :	/*interval clock control/status register*/		vax_putl(dst = IPR(ICCS) /*& ~ ( ICCS_SGL_BIT | ICCS_XFR_BIT ) not needed as we never set these bits*/, opaddr[1]);		break;	case ICR  :	/*interval count register (read only)*/		vax_putl(dst = IPR(ICR) , opaddr[1]);		break;	case ASTR:		vax_putl(dst = IPR(ASTR) & 0x7, opaddr[1]);		break;		case TBIA:	/*(write only) Translation Buffer Invalidate all*/	case TBIS:	/*(write only) Translation Buffer Invalidate Single*/	case TBHP:	/*(write only) Probe Translatiob Buffer for TB Hit*/	case CSTD:	/*(write only) TU58 Control Storage Transmit Data*/	case IORST:	/*(write only) unibus reset*/	case TBD:	/*Translation buffer data register, only valid when MME == 0. Used for diagnostics.(Not implemented)*/	case SIRR :	/*(write only) Software Interrupt Request Reg*/	case NICR :	/*(write only) next interval count register*/	case TXDB:	/*Console Transmit Data Buffer (write only)*/	default:		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		break;	SETNZ(dst, 0 );	}}void rei(char * notused){#pragma unused(notused)psl_type new_psl;address new_pc;		new_pc = vax_fetchl(SP);	SP += 4;	new_psl.psl_as_int = vax_fetchl(SP);	SP += 4;	if((new_psl.psl_by_bit.cnt_mode < CMD )	|| (new_psl.psl_by_bit.is == 1 && IS == 0)	|| (new_psl.psl_by_bit.is == 1 && new_psl.psl_by_bit.cnt_mode != KSP)	|| (new_psl.psl_by_bit.is == 1 && new_psl.psl_by_bit.ipl == 0)	|| (new_psl.psl_by_bit.ipl != 0 && new_psl.psl_by_bit.cnt_mode != KSP)	|| (new_psl.psl_by_bit.prev_mode < new_psl.psl_by_bit.cnt_mode)	|| (new_psl.psl_by_bit.ipl > IPL)	|| (new_psl.psl_by_bit.mbz != 0 )	|| (new_psl.psl_by_bit.mbz2 != 0 )	|| (new_psl.psl_by_bit.cm == 1 /* Don't have CM mode in this vax		&& (  new_psl.psl_by_bit.ivflag != 0			|| new_psl.psl_by_bit.fuflag != 0			|| new_psl.psl_by_bit.dvflag != 0			|| new_psl.psl_by_bit.fpd != 0			|| new_psl.psl_by_bit.is != 0 			|| new_psl.psl_by_bit.cnt_mode != USP) */		)	)		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);	else 	{		if( IS == 1 )		{			IPR(ISP) = SP;			IPR(IFP) = FP; /*for stackw*/		}		else		{			IPR(CMD) = SP;			IPR(CMD+KFP) = FP; /*for stackw*/		}		if(TP)			new_psl.psl_by_bit.tp = 1;		PC = new_pc;		psl = new_psl;		if(IS == 0)		{			SP = IPR(CMD);			/*check ASTLVL and interrupt at IPL 2*/			if(CMD >= IPR(ASTR) && vax_fetchliR(IPR(SCBB) + V_SWI2))/********Tempory hack for marking code with no AST vector*/				IPR(SISR) |= 0x4; 		}	}}void chmx(	long mode){long code = (long) vax_fetchw(  opaddr[ 0 ] );long newmode = (mode < CMD) ? mode:CMD ; /*New Mode must be greater than existing mode*/vector handler_address;unsigned long old_psl = PSL;	if(IS)	{	aprintf("Can't Change Mode while using Interrupt stack");		stop = 1;		return;	}	IPR(CMD) = SP;	IPR(CMD+KFP) = FP; /*for stackw*/	PMD = CMD;	CMD = newmode;	SP = IPR(newmode);	SP -= 4;	vax_putl( old_psl, SP );	SP -= 4;	vax_putl( PC, SP );	SP -= 4;	vax_putl( code, SP );	CM = TP = FPD = DV = FU = IV = T = N = Z = V = C = 0;	handler_address.vector_as_long = vax_fetchliR(IPR(SCBB) + V_CHMK + (newmode*sizeof(vector)));	PC = HANDLER_ADDRESS(handler_address);	if(SERVICED_ON(handler_address) != USE_KSP)	{			aprintf("bits 0 and 1 of the CHMx trap vector must be 0");		stop = 1;	}	if(PC == 0)	{	aprintf("CHMx instruction\nHalted No Vector defined");		rei("rei");		stop = 1;	}}void chmk(char * notused){#pragma unused(notused)	chmx(KSP);}void chme(char * notused){#pragma unused(notused)	chmx(ESP);}void chms(char * notused){#pragma unused(notused)	chmx(SSP);}void chmu(char * notused){#pragma unused(notused)	chmx(USP);}void prober(char * notused){#pragma unused(notused)char mode = vax_fetchb(opaddr[0]) & 0x3;unsigned long len = (unsigned long) vax_fetchw(opaddr[1]);unsigned long base = (unsigned long) opaddr[2];short hold = exceptions_on;	mode = mode > PMD ? mode : PMD;	C = V = N = 0;	exceptions_on = 0;	if(check_reference(base,mode,RD,0) == ERROR 	|| check_reference(base + len - 1,mode,RD,0) == ERROR)		Z = 1;	else		Z = 0;	exceptions_on = hold;}void probew(char * notused){#pragma unused(notused)char mode = vax_fetchb(opaddr[0]) & 0x3;unsigned long len = (unsigned long) vax_fetchw(opaddr[1]);unsigned long base = (unsigned long) opaddr[2];short hold = exceptions_on;	mode = mode > PMD ? mode : PMD;	C = V = N = 0;	exceptions_on = 0;	if(check_reference(base,mode,WR,0) == ERROR 	|| check_reference(base + len - 1,mode,WR,0) == ERROR)		Z = 1;	else		Z = 0;	exceptions_on = hold;}void xfc(char * notused){#pragma unused(notused)unsigned char syscode = (unsigned char) vax_fetchb(opaddr[0]);unsigned long  time = 0;unsigned char c;long i;char buff[16],*p;unsigned long current_pos;	N = Z = V = C = 0;	switch(syscode)	{	case	READCHAR:	/*reads char from keyboard into r1 (no echo)*/		R0 = iow_sys_getchar();		break;	case	WRITECHAR:		/*outputs char in r1 to window*/ 		iow_sys_putchar((char)( R0 & BYTE_MASK ));		break;	case	READLINE:	/*Reads a line into address specified in r0, length into r1*/		R1 = 0;		while((c = iow_sys_getchar()) && c != '\015') //Yes 1 ='s		{				if(c == '\010')			{				if(R1)				{					iow_sys_putchar(c);					R0--;					R1--;				}			}			else			{				if(vax_putb(c,R0++) == -1)				{						break;				}				iow_sys_putchar(c);				R1++;			}			update_memdisplay(ANDREG);		}		iow_sys_putchar('\n');		break;	case	WRITESTRING:		/*outputs a string. Address in r1, for length R2*/		while(R1 && (c = vax_fetchb(R0))) //Yes 1 ='s		{	R1--;			R0++;			iow_sys_putchar(c);		}		break;	case	ADTOI:			/*converts a char string into a number*/		p = buff;		i = 0;		while((*p = vax_fetchb(R0)) && isspace(*p)) R0++; //Yes 1 ='s		if(*p)		{			while( i++ < 10 && (*p = vax_fetchb(R0)) && (*p >= '0' && *p <= '9')) //Yes 1 ='s			{	R0++;				p++;			}			*p = '\0';			sscanf(buff,"%d",&i);		}		R1 = i;		break;	case	AHTOI:			/*converts a char string into a number*/		p = buff;		i = 0;		while((*p = vax_fetchb(R0)) && isspace(*p)) R0++; //Yes 1 ='s		if(*p)		{			while( i++ < 8 && (*p = vax_fetchb(R0)) //Yes 1 ='s					&& (  (*p >= '0' && *p <= '9') 						|| (*p >= 'a' && *p <= 'f') 						|| (*p >= 'A' && *p <= 'F') ) )			{	p++;				R0++;			}			*p = '\0';			sscanf(buff,"%x",&i);		}		R1 = i;		break;	case	ITOAH:			/*converts a number into a hex char string*/		sprintf(buff,"%X",R1);		for(p = buff;*p;p++)			if(vax_putb(*p,R0++) == -1)			{					break;			}		break;	case	ITOAD:			/*converts a number into a decimal char string*/		sprintf(buff,"%d",R1);		for(p = buff;*p;p++)			if(vax_putb(*p,R0++) == -1)			{					break;			}		break;	case UPDATE_WINDOWS:			put_PC_in_progwindow();			update_display();			break;	case PROG_TO_FRONT:	case REG_TO_FRONT:	case MEML_TO_FRONT:	case IO_TO_FRONT:				if(window[syscode-PROG_TO_FRONT].secure == 1)					break;	/*can't open a secure window*/				ShowHide(window[syscode-PROG_TO_FRONT].windowptr,true);				SelectWindow(window[syscode-PROG_TO_FRONT].windowptr);				break;	case MEM_TO_FRONT:				if(hex_mem_dump)				{					if(dumphWindow.secure == 1)						break;	/*can't open a secure window*/					ShowWindow(dumphWindow.windowptr);					SelectWindow(dumphWindow.windowptr);				}				else				{					if(dumpdWindow.secure == 1)						break;	/*can't open a secure window*/					ShowWindow(dumpdWindow.windowptr);					SelectWindow(dumpdWindow.windowptr);				}				break;	case SYSW_TO_FRONT:				if(sysWindow.secure == 1)					break;	/*can't open a secure window*/				ShowHide(sysWindow.windowptr,true);				SelectWindow(sysWindow.windowptr);				break;	case STACKW_TO_FRONT:				if(stackWindow.secure == 1)					break;	/*can't open a secure window*/				ShowHide(stackWindow.windowptr,true);				SelectWindow(stackWindow.windowptr);				break;	case PROG_CLOSE:	case REG_CLOSE:	case MEML_CLOSE:	case IO_CLOSE:				SendBehind(window[syscode-PROG_CLOSE].windowptr,0L);				HideWindow(window[syscode-PROG_CLOSE].windowptr);				break;	case MEM_CLOSE:				if(hex_mem_dump)				{					SendBehind(dumphWindow.windowptr,0L);					HideWindow(dumphWindow.windowptr);				}				else				{					SendBehind(dumpdWindow.windowptr,0L);					HideWindow(dumpdWindow.windowptr);				}				break;	case SYSW_CLOSE:				SendBehind(sysWindow.windowptr,0L);				HideWindow(sysWindow.windowptr);				break;	case STACKW_CLOSE:				SendBehind(stackWindow.windowptr,0L);				HideWindow(stackWindow.windowptr);				break;	case OPEN_MAC_FILE:				R0 = open_mac_file();				put_PC_in_progwindow();				update_display();				break;	case CREATE_MAC_FILE:				R0 = create_mac_file(R1);				put_PC_in_progwindow();				update_display();				break;	case OPEN_NAMED_FILE:				R0 = open_named_mac_file(R1);				break;	case CLOSE_MAC_FILE:				R0 = close_mac_file(R0);				break;	case READ_MAC_FILE:				R2 = read_mac_file(R0,R1,R2);				break;	case WRITE_MAC_FILE:				R2 = write_mac_file(R0,R1,R2);				break;	case SEEK_MAC_FILE:				R1 = seek_mac_file(R0,R1,R2);				break;	case GET_FILENAME_FD:				R2 = get_mac_filename_fd(R0,R1);				break;	case FIND_FILE:	/*find the file using a standard file dialog box*/				R0 =  find_mac_file("",R1);				put_PC_in_progwindow();				update_display();				break;	case GET_DIR_ID:	/*Takes a pascal string pointer in R1 and */						/*returns the mac directory id (vrefnum) in R0*/				/*R0 = m_get_vRefNum(R1);*/				aprintf("GET_DIR_ID Not implemented yet");				R0 = 0;				break;	case GET_ADIR_ID:	/*returns the applications mac directory id (vrefnum) in R0*/				R0 = appl_vrefnum;				break;	case GET_CDIR_ID:	/*returns the current mac directory id (vrefnum) in R0*/				R0 = current_vrefnum;				break;	case ALLOC_MEM:				if(is_a_system == 0)					R0 = alloc_cd(PAGE_SIZE , UW) ;				break;	case FREE_MEM:				if(is_a_system == 0)					free_p0_page();				break;	case CLEAR_IOW:				clear_io_window();				break;	case MAC_TIME:				(void) ReadDateTime( &time );				R0 = time;				break;			/*Below this point All XFC's are for Kernel Mode ONLY*/		case SYSTEM:				if(CMD != KSP)				{					reserved_or_priviledged("xfc ATTACH_SYMBOL_TABLE");					return;				}				is_a_system = 1;				EnableItem(MyMenus[fileMenu], (short)shutdownCommand);				break;	case REBOOT:				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc REBOOT");					return;				}				boot();				break;					case CREATE_USER_SYMBOL_TABLE: /*File descriptor in R0. Returns reference number in R1*/				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc CREATE_USER_SYMBOL_TABLE");					return;				}				if((current_pos = get_pos_mac(R0)) == -1)	/*remember where they were*/					R1 = -3;				else				{					seek_mac_file(R0,0,0);					R1 = create_symbol_table(MFILE_mac(R0),0);	/*Read in the symbol table*/					seek_mac_file(R0,current_pos,0);		/*restore current file pos*/				}				break;	case CREATE_SYS_SYMBOL_TABLE:    /*File descriptor in R0. Returns reference number in R1*/				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc CREATE_SYS_SYMBOL_TABLE");					return;				}				if((current_pos = get_pos_mac(R0)) == -1)	/*remember where they were*/					R1 = -3;				else				{					seek_mac_file(R0,0,0);					R1 = create_symbol_table(MFILE_mac(R0),1);	/*Read in the symbol table*/					seek_mac_file(R0,current_pos,0);		/*restore current file pos*/				}				break;	case FREE_SYMBOL_TABLE: /*Prog descriptor in R0. Returns result code in R1*/				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc FREE_SYMBOL_TABLE");					return;				}				R1 = free_symboltable(R0);				break;	case USE_USER_SYMBOL_TABLE: 		/*Prog descriptor in R0. Returns result code in R1*/				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc USE_SYMBOL_TABLE");					return;				}				R1 = use_user_symbol_table(R0);				break;	case DUP_USER_SYMBOL_TABLE: 		/*Prog descriptor in R0. Returns new Descriptor in R1*/				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc DUP_USER_SYMBOL_TABLE");					return;				}				R1 = duplicate_symbol_table(R0);				break;	case GET_FILENAME_PD:				if(is_a_system == 0 || CMD != KSP)				{					reserved_or_priviledged("xfc GET_FILENAME_PD");					return;				}				R2 = get_mac_filename_pd(R0,R1);				break;	case DISPLAY_DIALOG:				if(CMD != KSP)				{					reserved_or_priviledged("xfc DISPLAY_DIALOG");					return;				}				display_dialog(R0);				put_PC_in_progwindow();				update_display();				break;	case CLEAR_WATCHPOINTS:		/* Virtual addr -> R0, length -> R1  */				if(CMD != KSP)				{					reserved_or_priviledged("xfc DISPLAY_DIALOG");					return;				}				clear_range_watch_points(R0, R1);				break;					case SET_WATCHPOINTS:		/* Virtual addr -> R0, length -> R1  */				if(CMD != KSP)				{					reserved_or_priviledged("xfc DISPLAY_DIALOG");					return;				}				set_range_watch_points(R0, R1);				break;	default:			reserved_or_priviledged("unimplemented xfc call");		break;	}}void bpt(char * notused){#pragma unused(notused)	exception(FAULT,V_BPI,"bpt",0,0);}void svpctx(char * notused){#pragma unused(notused)	if(CMD != KSP)	{		reserved_or_priviledged("svpctx");		return;	}		/*note the PCBB of the process who's state is being saved*/	/*This is for our MACVAX's process switching control on the bottom*/	/*of the program window*/	Process_Control_Block[IPR(MVPID)] = IPR(PCBB);		vax_putliR(R0,IPR(PCBB) + PCB_R0);	vax_putliR(R1,IPR(PCBB) + PCB_R1);	vax_putliR(R2,IPR(PCBB) + PCB_R2);	vax_putliR(R3,IPR(PCBB) + PCB_R3);	vax_putliR(R4,IPR(PCBB) + PCB_R4);	vax_putliR(R5,IPR(PCBB) + PCB_R5);	vax_putliR(R6,IPR(PCBB) + PCB_R6);	vax_putliR(R7,IPR(PCBB) + PCB_R7);	vax_putliR(R8,IPR(PCBB) + PCB_R8);	vax_putliR(R9,IPR(PCBB) + PCB_R9);	vax_putliR(R10,IPR(PCBB) + PCB_R10);	vax_putliR(R11,IPR(PCBB) + PCB_R11);	vax_putliR(R12,IPR(PCBB) + PCB_R12);	vax_putliR(R13,IPR(PCBB) + PCB_R13);	vax_putliR(vax_fetchl( SP ),IPR(PCBB) + PCB_R15);	SP += 4;	vax_putliR(vax_fetchl( SP ),IPR(PCBB) + PCB_PSL);	SP += 4;	if(IS == 0)	{		IPR(CMD) = SP;		/*ensure we are saving the current SP*/		IPR(CMD+KFP) = FP; /*ensure saving the current FP*/	}	vax_putliR(IPR(KSP),IPR(PCBB) + PCB_KSP);	vax_putliR(IPR(ESP),IPR(PCBB) + PCB_ESP);	vax_putliR(IPR(SSP),IPR(PCBB) + PCB_SSP);	vax_putliR(IPR(USP),IPR(PCBB) + PCB_USP);	vax_putliR(IPR(P0BR),IPR(PCBB) + PCB_P0BR);	/*AST Level is stored in bits 24:26 of P0LR in PCB; bits 31:27 MBZ*/	/*These bits are not saved by the svpctx instruction to save overhead*/	vax_putliR(IPR(P0LR) | (vax_fetchliR(IPR(PCBB) + PCB_P0LR) & ~PAGE_LENGTH_MASK) ,IPR(PCBB) + PCB_P0LR);	vax_putliR(IPR(P1BR),IPR(PCBB) + PCB_P1BR);	/*Performance Monitor Enable is bit 31 of P1LR in PCB; bits 22:30 MBZ*/	/*These bits are not saved by the svpctx instruction to save overhead*/	vax_putliR(IPR(P1LR) | (vax_fetchliR(IPR(PCBB) + PCB_P1LR) & ~PAGE_LENGTH_MASK), IPR(PCBB) + PCB_P1LR);	vax_putliR(IPR(MVPID), IPR(PCBB) + PCB_PID); /*Our own addition to the process control block*/	vax_putliR(IPR(KFP),IPR(PCBB) + PCB_KFP);	vax_putliR(IPR(EFP),IPR(PCBB) + PCB_EFP);	vax_putliR(IPR(SFP),IPR(PCBB) + PCB_SFP);	vax_putliR(IPR(UFP),IPR(PCBB) + PCB_UFP);	/*IF not on the interrupt stack we switch to it as the other stack pointers are now invalid because we are between processes*/	if(!IS)	{		SP = IPR(ISP);		IS = 1;	}	if(IPL == 0) IPL = 1;}void ldpctx(char * notused){#pragma unused(notused)unsigned long tmp;	if(CMD != KSP)	{		reserved_or_priviledged("ldpctx");		return;	}	/*Next four are A hack for the stackw to help find the first frame pointer*/	IPR(KFP) = vax_fetchliR(IPR(PCBB) + PCB_KFP);	IPR(EFP) = vax_fetchliR(IPR(PCBB) + PCB_EFP);	IPR(SFP) = vax_fetchliR(IPR(PCBB) + PCB_SFP);	IPR(UFP) = vax_fetchliR(IPR(PCBB) + PCB_UFP);	IPR(KSP) = vax_fetchliR(IPR(PCBB) + PCB_KSP);	IPR(ESP) = vax_fetchliR(IPR(PCBB) + PCB_ESP);	IPR(SSP) = vax_fetchliR(IPR(PCBB) + PCB_SSP);	IPR(USP) = vax_fetchliR(IPR(PCBB) + PCB_USP);	R0 = vax_fetchliR(IPR(PCBB) + PCB_R0);	R1 = vax_fetchliR(IPR(PCBB) + PCB_R1);	R2 = vax_fetchliR(IPR(PCBB) + PCB_R2);	R3 = vax_fetchliR(IPR(PCBB) + PCB_R3);	R4 = vax_fetchliR(IPR(PCBB) + PCB_R4);	R5 = vax_fetchliR(IPR(PCBB) + PCB_R5);	R6 = vax_fetchliR(IPR(PCBB) + PCB_R6);	R7 = vax_fetchliR(IPR(PCBB) + PCB_R7);	R8 = vax_fetchliR(IPR(PCBB) + PCB_R8);	R9 = vax_fetchliR(IPR(PCBB) + PCB_R9);	R10 = vax_fetchliR(IPR(PCBB) + PCB_R10);	R11 = vax_fetchliR(IPR(PCBB) + PCB_R11);	R12 = vax_fetchliR(IPR(PCBB) + PCB_R12);	/*Argument pointer*/	R13 = vax_fetchliR(IPR(PCBB) + PCB_R13);	/*frame_pointer*/	tmp = (unsigned long) vax_fetchliR(IPR(PCBB) + PCB_P0BR);	if( (tmp & R_SPACE) == S_SPACE 	/*in system space*/		&& (!(tmp & 0x3)) 			/*Aligned*/		  )		{		IPR(P0BR) = tmp;				tmp = (unsigned long) vax_fetchliR(IPR(PCBB) + PCB_P0LR);		IPR(P0LR) = tmp & PAGE_LENGTH_MASK;		IPR(ASTR) = (tmp >> 24 )  & 0x7;				tmp =  (unsigned long) vax_fetchliR(IPR(PCBB) + PCB_P1BR);		if(((unsigned long)tmp >= (unsigned long)0x7f800000) /*Vaild address base for P1BR*/		&& (tmp & R_SPACE) != R_SPACE					/*Not in R Space*/		&& (!(tmp & 0x3))								/*Aligned*/	 	  )		{			IPR(P1BR) = tmp;						tmp = (unsigned long)  vax_fetchliR(IPR(PCBB) + PCB_P1LR) ;			IPR(P1LR) = tmp & PAGE_LENGTH_MASK;		}		else		{			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		}	}	else	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);	}		/*Our own addition to the process control block*/	use_user_symbol_table(vax_fetchliR(IPR(PCBB) + PCB_PID));	if(IS)	{	IPR(ISP) = SP;		IPR(IFP) = FP;	/*Hack for stackw*/		SP = IPR(KSP);		IS = 0;	}	SP -= 4;	vax_putl(vax_fetchliR(IPR(PCBB) + PCB_PSL),SP);	SP -= 4;	vax_putl(vax_fetchliR(IPR(PCBB) + PCB_R15),SP);		cdlines();	sklines();	set_maxscroll_sysw();}/*the unimplemented instructions*/void unimplemented(char *cause){	aprintf("Reserved operand Fault\n\nUnimplemented instruction: %s",cause);	stop = 1;}void Subset_emulation(	char *cause){	/*need to fill in this stuff*/	/*Vector V_SE*/	aprintf("Subset Emulation exception: Trap Not defined%s",cause);	stop = 1;}