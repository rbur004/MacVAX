#include 	<types.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#define OBSOLETE 1#include	<SegLoad.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include 	<strings.h>#include	<StdLib.h>#define _STARTUP_C_#include 	"macio.h"#include 	"globals.h"#include 	"window.h"#include 	"startup.h"#include	"docmds.h"#include	"settings.h"#include	"aprintf.h"#include	"process.h"#include	"progw.h"#include 	"main.h"#include 	"mmalloc.h"#ifdef C68Klong process_finder_info(void){short message;	/*print or open?*/short count;	/*number of args*/AppFile thefile;long num_files = 0;MFILE *fsym;	CountAppFiles(&message,&count);	if(message)	{		aprintf("No Print Option"); //Haven't implemented printing		exit(0);	}	if(count > 1)	{		aprintf("Only one file may be opened at a time."); 		return -1;	}	if(count)	{		GetAppFiles(1, &thefile );		p2cstr(thefile.fName);		if(thefile.fType == 'AOUT')		{			if((fsym = mopen_na((char *)thefile.fName,thefile.vRefNum)) != (MFILE *)0)			{					setwtitle(progWindow.windowptr, fsym->name);				new_process( fsym );				put_PC_in_progwindow();				return 1;			}			else			{				return -1;			}		}		if(thefile.fType == 'BOOT')		{			if((fsym = mopen_na((char *)thefile.fName,thefile.vRefNum)) != (MFILE *)0)			{					boot_file(fsym);				return 1;			}			else			{				return -1;			}		}		else		{			aprintf("File %s: type not 'AOUT' or 'BOOT'", &thefile.fName);			return -1;		}	}	return 0;}#elsevoid init_AE( void ){	AEInstallEventHandler(kCoreEventClass,  kAEOpenApplication,             	NewAEEventHandlerProc(AEOpenApplication),       nil,false);			// run	AEInstallEventHandler(kCoreEventClass,  kAEQuitApplication,			NewAEEventHandlerProc(AEQuitApplication),       nil, false);		// quit	AEInstallEventHandler(kCoreEventClass,  kAEOpenDocuments,        	NewAEEventHandlerProc(AEOpenDocument),    nil,false);				// open	AEInstallEventHandler(kCoreEventClass,  kAEPrintDocuments,              	NewAEEventHandlerProc(AEPrintHandler),     nil,false);				// (print)}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEOpenApplication                AppleEvent message saying that the application        has been opened with no documents.                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEOpenApplication( 	AppleEvent *theAppleEvent, 	AppleEvent* reply, 	long refCon){        // I have yet to see the point in calling GetMissingParams.        /*!!NewDocument();*/        return( noErr );}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEQuitApplication                AppleEvent message telling this app to quit                Parameters:        - one, a boolean indicating whether or not to save          all documents        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEQuitApplication( 	const AppleEvent *message, 	const AppleEvent *reply, 	long refcon )                   {	quit();    return( noErr ); //Never will get called, but compiler likes to think we return something.}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        DummyHandler        Used for Apple event handlers that need to be handled        as a requirement, but don' actually do anything.        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEPrintHandler( 	AppleEvent *theAppleEvent, 	AppleEvent *reply,	long refCon ){#pragma unused (theAppleEvent,reply,refCon)	aprintf("No Print Option");	return(errAEEventNotHandled);}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEOpenDocument                Replaces calls to CountAppFiles and GetAppFiles since they're not        supported under Apple's universal headers 2.1 (glue was missing).                !! Also gives the user the ability to change the image while        !! the program is running whether this is useful or not.                --        An Apple Event containing a list (AEDescList) of aliases        to files. This function goes through the list        and extracts the aliases as FSSpecs (letting the Apple Event        Manager do the coercion).                This code was primarily pinched from '7Edit', an AppleEvent        example on the AppleEvent SDK                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEOpenDocument( 	const AppleEvent *message, 	const AppleEvent *reply, 	long refcon ){#pragma unused (reply, refcon)long        index;long        itemsInList;AEKeyword   keywd;OSErr       result;AEDescList  docList;long        actSize;DescType    typeCode;FSSpec      theFSSpec;MFILE *fsym;OSErr error = 0;FInfo fndrInfo;                	docList.dataHandle = nil;		/* Get the list descriptor */	result = AEGetParamDesc( message, keyDirectObject, typeAEList, &docList );	if( result != noErr )	    return( result );		/* Count how many elements there are */	result = AECountItems( &docList, &itemsInList);			if( result == noErr && itemsInList > 0 )	{	    				if(itemsInList > 1)		{			aprintf("AEOpenDocument\nWarning: Only one file may be opened at a time.\nWill open first valid file"); 		}				/* Now walk through the list extracting the elements */		for( index = 1; index <= itemsInList; index++ )		{		    result = AEGetNthPtr( &docList, index, typeFSS, &keywd, &typeCode,		                                              (Ptr)&theFSSpec, sizeof(theFSSpec), &actSize ) ;		    if( result == noErr )		    {				p2cstr(theFSSpec.name);				if((result = FSpGetFInfo(&theFSSpec, &fndrInfo)) == noErr)				{					if(fndrInfo.fdType == 'AOUT')					{						if((fsym = mopen_na((char *)&theFSSpec.name,theFSSpec.vRefNum)) != (MFILE *)0)						{								setwtitle(progWindow.windowptr, fsym->name);							new_process( fsym );							put_PC_in_progwindow();							result = noErr;						}						else						{							result = -1;						}						break;					}					else if(fndrInfo.fdType == 'BOOT')					{						if((fsym = mopen_na((char *)&theFSSpec.name,theFSSpec.vRefNum)) != (MFILE *)0)						{								boot_file(fsym);							result = noErr;						}						else						{							result = -1;						}						break;					}				}				else				{					aprintf("AEOpenDocument\nFile %s: Couldn't get Finder Info\n(err %d)", &theFSSpec.name, result);					break;				}		    }		    else			{				aprintf("AEOpenDocument\nCouldn't get AE Info\n(err %d)", result);				break;			}		}	}		if( docList.dataHandle != nil )	    (void) AEDisposeDesc( &docList );	            	return( result );}#endif