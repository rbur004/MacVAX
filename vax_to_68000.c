#define _VAX_TO_68000_C_#include	<stdlib.h>#include	<StdIO.h>#include "mmemory.h"#include "arithmetic_fault.h"#include "vax_to_68000.h"long floating_underflow = 0;longv2m_long(	long I){long mac_l;register unsigned char *p = (unsigned char *) &mac_l;register unsigned char *q = ((unsigned char *) &I) + 3;	*p++ = *q;*p++ = *--q;*p++ = *--q;*p = *--q;	return(mac_l);}shortv2m_short(	short s){short mac_s;register unsigned char *p = (unsigned char *) &mac_s;register unsigned char *q = ((unsigned char *) &s) + 1;	*p++ = *q;*p++ = *--q;	return(mac_s);}/*float utilities*/extended f2e(	v_float f){union{	extended e;	struct	{		union		{			unsigned short sign_exponent;			struct			{				unsigned long sign:1;				unsigned long exponent:15;			}se_bb;		}se;		union		{			unsigned long   fract_l;			struct			{				unsigned long i:1;				unsigned long fract_1:7;				unsigned long fract2:8;				unsigned long fract3:8;				unsigned long rest:8;			}f1_bb;		}f1;		unsigned long fract4;	}e_bb;} ext;	if(f.f_bb.exponent)	{		ext.e_bb.se.se_bb.sign = f.f_bb.sign;		ext.e_bb.se.se_bb.exponent = 16254 + f.f_bb.exponent ;		ext.e_bb.f1.f1_bb.i = 1;		ext.e_bb.f1.f1_bb.fract_1 = f.f_bb.fract_1;		ext.e_bb.f1.f1_bb.fract2 = f.f_bb.fract2;		ext.e_bb.f1.f1_bb.fract3 = f.f_bb.fract3;		ext.e_bb.f1.f1_bb.rest = 0;		ext.e_bb.fract4 = 0;	}	else		ext.e = 0;#ifdef DEBUG	aprintf("%e\n%4.4x %8.8x %8.8x",		ext.e,ext.e_bb.se.sign_exponent, ext.e_bb.f1.fract_l, ext.e_bb.fract4);#endif	return(ext.e);}unsigned long e2f(	extended e){union{	extended e;	struct	{		union		{			unsigned short sign_exponent;			struct			{				unsigned long sign:1;				unsigned long exponent:15;			}se_bb;		}se;		union		{			unsigned long   fract_l;			struct			{				unsigned long i:1;				unsigned long fract_1:7;				unsigned long fract2:8;				unsigned long fract3:8;				unsigned long rest:8;			}f1_bb;		}f1;		unsigned long fract4;	}e_bb;} ext;v_float f;	ext.e = e;	if(ext.e_bb.se.se_bb.exponent < 16254)		/*underflow*/	{	floating_underflow = 1;		return 0;	}	else		floating_underflow = 0;		if(ext.e_bb.se.se_bb.exponent > 16509)	/*overflow*/	{	f.f = 0;		f.f_bb.sign = 1;		return(f.f);	}	f.f_bb.sign = ext.e_bb.se.se_bb.sign;	f.f_bb.exponent = ext.e_bb.se.se_bb.exponent - 16254  ;	if(ext.e_bb.f1.f1_bb.i == 1)	{		f.f_bb.fract_1 = ext.e_bb.f1.f1_bb.fract_1;		f.f_bb.fract2 = ext.e_bb.f1.f1_bb.fract2;		f.f_bb.fract3 = ext.e_bb.f1.f1_bb.fract3;	}	else	{		floating_underflow = 1;		return(0);	}	return(f.f);}char *f2s(	v_float f){static char fbuff[16];		if(f.f_bb.exponent == 0)			if(f.f_bb.sign == 0)				sprintf(fbuff,"+0.0000000e+00");			else				sprintf(fbuff,"ReservedOperand");		else			sprintf(fbuff,"%+.7e",f2e(f));		return(fbuff);}