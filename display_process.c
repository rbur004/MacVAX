#include "display_process.h"#include "mmemory.h"#include "symbol_tab.h"#include "window.h"#include "sysw.h"static reg_type	running_vax_regs[48];		/*16 usual regs and 32 temp regs*/static reg_type	running_ipr[NUM_IPRS];static psl_type 	running_psl;static int nothing_to_do = 1;static address pcbb;short display_process_id = 0x80;static void save_running_registers(void){int i;	running_psl = psl;		for(i = 0; i < 16; i++)		running_vax_regs[i] = vax_regs[i];			running_ipr[KSP] = ipr[KSP];	running_ipr[ESP] = ipr[ESP];	running_ipr[SSP] = ipr[SSP];	running_ipr[USP] = ipr[USP];	running_ipr[P0BR] = ipr[P0BR];	running_ipr[P0LR] = ipr[P0LR];	running_ipr[ASTR] = ipr[ASTR];			running_ipr[P1BR] = ipr[P1BR];	running_ipr[P1LR] = ipr[P1LR];	running_ipr[PMR] = ipr[PMR];	 	running_ipr[MVPID] = ipr[MVPID]; /*Our own addition to the process control block*/	running_ipr[KFP] = ipr[KFP];	running_ipr[EFP] = ipr[EFP];	running_ipr[SFP] = ipr[SFP];	running_ipr[UFP] = ipr[UFP];	running_ipr[PCBB] = ipr[PCBB];	}static void restore_running_registers(void){int i;	psl = running_psl;		for(i = 0; i < 16; i++)		vax_regs[i] = running_vax_regs[i];			ipr[KSP] = running_ipr[KSP];	ipr[ESP] = running_ipr[ESP];	ipr[SSP] = running_ipr[SSP];	ipr[USP] = running_ipr[USP];	ipr[P0BR] = running_ipr[P0BR];	ipr[P0LR] = running_ipr[P0LR];	ipr[ASTR] = running_ipr[ASTR];			ipr[P1BR] = running_ipr[P1BR];	ipr[P1LR] = running_ipr[P1LR];	ipr[PMR] = running_ipr[PMR];		ipr[MVPID] = running_ipr[MVPID]; /*Our own addition to the process control block*/	ipr[KFP] = running_ipr[KFP];	ipr[EFP] = running_ipr[EFP];	ipr[SFP] = running_ipr[SFP];	ipr[UFP] = running_ipr[UFP];		ipr[PCBB] = running_ipr[PCBB];}void save_display_process_ctx(void){	if(nothing_to_do)		return;			vax_putliR(R0, pcbb + PCB_R0);	vax_putliR(R1, pcbb + PCB_R1);	vax_putliR(R2, pcbb + PCB_R2);	vax_putliR(R3, pcbb + PCB_R3);	vax_putliR(R4, pcbb + PCB_R4);	vax_putliR(R5, pcbb + PCB_R5);	vax_putliR(R6, pcbb + PCB_R6);	vax_putliR(R7, pcbb + PCB_R7);	vax_putliR(R8, pcbb + PCB_R8);	vax_putliR(R9, pcbb + PCB_R9);	vax_putliR(R10, pcbb + PCB_R10);	vax_putliR(R11, pcbb + PCB_R11);	vax_putliR(R12, pcbb + PCB_R12);	vax_putliR(R13, pcbb + PCB_R13);	vax_putliR(R15, pcbb + PCB_R15);	vax_putliR(vax_psl,  pcbb + PCB_PSL);	if(IS == 0)	{		IPR(CMD) = SP;		/*ensure we are saving the current SP*/		IPR(CMD+KFP) = FP; /*ensure saving the current FP*/	}	vax_putliR(IPR(KSP), pcbb + PCB_KSP);	vax_putliR(IPR(ESP), pcbb + PCB_ESP);	vax_putliR(IPR(SSP), pcbb + PCB_SSP);	vax_putliR(IPR(USP), pcbb + PCB_USP);		vax_putliR(IPR(P0BR), pcbb + PCB_P0BR);	/*AST Level is stored in bits 24:26 of P0LR in PCB; bits 31:27 MBZ*/	/*These bits are not saved by the svpctx instruction to save overhead*/	/*we need to here in case the user changes them on us*/	vax_putliR(IPR(P0LR) | ((IPR(ASTR) << 24) & 0x07000000) , pcbb + PCB_P0LR);	vax_putliR(IPR(P1BR), pcbb + PCB_P1BR);	/*Performance Monitor Enable is bit 31 of P1LR in PCB; bits 22:30 MBZ*/	/*These bits are not saved by the svpctx instruction to save overhead*/	/*we need to here in case the user changes them on us*/	vax_putliR(IPR(P1LR) | (IPR(PMR) ? 0x80000000:0),  pcbb + PCB_P1LR);	vax_putliR(IPR(MVPID),  pcbb + PCB_PID); /*Our own addition to the process control block*/	vax_putliR(IPR(KFP), pcbb + PCB_KFP);	vax_putliR(IPR(EFP), pcbb + PCB_EFP);	vax_putliR(IPR(SFP), pcbb + PCB_SFP);	vax_putliR(IPR(UFP), pcbb + PCB_UFP);		restore_running_registers();	use_user_symbol_table(IPR(MVPID));	cdlines();	sklines();	set_maxscroll_sysw();	nothing_to_do = 1;}void load_display_process_ctx(void){unsigned long tmp;	if(nothing_to_do == 0)	{	/*This shouldn't ever happen, but just in case*/		save_display_process_ctx();	}			if(display_process_id == 0 || process_table[display_process_id & 0x7f] == 0)	{		nothing_to_do = 1;		return;	}		pcbb = Process_Control_Block[display_process_id & 0x7f];	if(pcbb == 0xffffffff || pcbb == IPR(PCBB))	{		nothing_to_do = 1;		return;	}	else		nothing_to_do = 0;		save_running_registers();		IPR(PCBB) = pcbb;	/*Next four are A hack for the stackw to help find the first frame pointer*/	IPR(KFP) = vax_fetchliR(pcbb + PCB_KFP);	IPR(EFP) = vax_fetchliR(pcbb + PCB_EFP);	IPR(SFP) = vax_fetchliR(pcbb + PCB_SFP);	IPR(UFP) = vax_fetchliR(pcbb + PCB_UFP);	IPR(KSP) = vax_fetchliR(pcbb + PCB_KSP);	IPR(ESP) = vax_fetchliR(pcbb + PCB_ESP);	IPR(SSP) = vax_fetchliR(pcbb + PCB_SSP);	IPR(USP) = vax_fetchliR(pcbb + PCB_USP);	R0 = vax_fetchliR(pcbb + PCB_R0);	R1 = vax_fetchliR(pcbb + PCB_R1);	R2 = vax_fetchliR(pcbb + PCB_R2);	R3 = vax_fetchliR(pcbb + PCB_R3);	R4 = vax_fetchliR(pcbb + PCB_R4);	R5 = vax_fetchliR(pcbb + PCB_R5);	R6 = vax_fetchliR(pcbb + PCB_R6);	R7 = vax_fetchliR(pcbb + PCB_R7);	R8 = vax_fetchliR(pcbb + PCB_R8);	R9 = vax_fetchliR(pcbb + PCB_R9);	R10 = vax_fetchliR(pcbb + PCB_R10);	R11 = vax_fetchliR(pcbb + PCB_R11);	R12 = vax_fetchliR(pcbb + PCB_R12);	/*Argument pointer*/	R13 = vax_fetchliR(pcbb + PCB_R13);	/*frame_pointer*/	IPR(P0BR) = (unsigned long) vax_fetchliR(pcbb + PCB_P0BR);			tmp = (unsigned long) vax_fetchliR(pcbb + PCB_P0LR);	IPR(P0LR) = tmp & PAGE_LENGTH_MASK;	IPR(ASTR) = (tmp >> 24 )  & 0x7;			IPR(P1BR) =  (unsigned long) vax_fetchliR(pcbb + PCB_P1BR);	tmp = (unsigned long) vax_fetchliR(pcbb + PCB_P1LR);	IPR(P1LR) = tmp & PAGE_LENGTH_MASK;	IPR(PMR) = (tmp & 0x80000000) ? 1:0;				use_user_symbol_table(vax_fetchliR(pcbb + PCB_PID));	if(IS)	{	IPR(ISP) = SP;		IPR(IFP) = FP;	/*Hack for stackw*/		SP = IPR(KSP);		IS = 0;	}	else		SP = IPR(CMD);	vax_psl = vax_fetchliR(pcbb + PCB_PSL);	R15 = vax_fetchliR(pcbb + PCB_R15);		cdlines();	sklines();	set_maxscroll_sysw();}void init_display_process(void){	nothing_to_do = 1;	display_process_id = 0x80;}