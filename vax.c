#include	<types.h>#include	<quickdraw.h>#include	<windows.h>#include	<OSutils.h>#include	<controls.h>#include 	<ToolUtils.h>#include 	<ctype.h>#include	<StdLib.h>#include	<StdIO.h>#include	<menus.h>//#include	<desk.h>#define VAX_C#include 	"mmemory.h"#include 	"window.h"#include 	"xfc.h"#include 	"arithmetic_fault.h"#include	"exception.h"#include 	"vax.h"#include 	"iow.h"#include 	"func.h"#include	"clock.h"#include	"docmds.h"#include	"execute.h"#include	"vax_to_68000.h"#include	"macio.h"#include	"vaxmacio.h"#include	"progw.h"#include	"stackw.h"#include	"aprintf.h"#include	"sysw.h"#include	"process.h"#include	"macdev.h"#include	"main.h"#include	"symbol_tab.h"	#pragma segment VaxIns/* ---- MOVE ---- */void movb(char * notused){#pragma unused(notused)byte source = vax_fetchb( opaddr[ 0 ] );	vax_putb( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}void movw(char * notused){#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] );	vax_putw( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}void movl(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );	vax_putl( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}void movq(char * notused) {#pragma unused(notused)quad source;		source = vax_fetchq( opaddr[ 0 ] );	vax_putq( source, opaddr[ 1 ] );	N = source.long1 < 0 ;	Z = source.long1 == 0 && source.long0 == 0;	V = 0;}void movf(char * notused){#pragma unused(notused)v_float source;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	vax_putl(source.f, opaddr[1]);	N = source.f_bb.sign;	Z = source.f_bb.exponent;	V = 0;}void movpsl(char * notused) {#pragma unused(notused)	vax_putl( PSL, opaddr[ 0 ] );}/* ---- PUSH LONG	---- */void pushl(char * notused) {#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );	SP -= 4;	vax_putl( source, SP );	SETNZ( source, 0 );	V = 0;}/*	---- ClEAR	---- */void clrb(char * notused){#pragma unused(notused)	vax_putb( 0, opaddr[ 0 ] );	N = V = 0;	Z = 1;}void clrw(char * notused){#pragma unused(notused)	vax_putw( 0, opaddr[ 0 ] );	N = V = 0;	Z = 1;}void clrl(char * notused){#pragma unused(notused)	vax_putl( 0, opaddr[ 0 ] );	N = V = 0;	Z = 1;}void clrq(char * notused){#pragma unused(notused)	vax_putq( quad_zero, opaddr[ 0 ] );	N = V = 0;	Z = 1;}/* ---- Move Negated ----------------------------------------------- */void mnegb(char * notused){#pragma unused(notused)byte source = vax_fetchb( opaddr[ 0 ] ) ;byte dest = -source;	V = source == (char) S_MIN_BYTE;	SETNZ( dest, 0 );	C = NEQ( dest, 0 );	vax_putb( dest, opaddr[ 1 ] );	/* ( - smallest negative ) = smallest negative */	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mnegw(char * notused){#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] ) ;word dest = -source;	V = source == S_MIN_WORD;	vax_putw(dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	C = NEQ( dest, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mnegl(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );long dest = -source;	V = source == S_MIN_LONG;	vax_putl( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	C = NEQ( dest, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mnegf(char * notused){#pragma unused(notused)v_float source;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	if(source.f_bb.exponent != 0)	{		source.f_bb.sign = source.f_bb.sign ? 0:1;		vax_putl(source.f, opaddr[1]);	}	N = source.f_bb.sign;	Z = source.f_bb.exponent;	V = 0;	C = 0;}/* ---- Move Complemented ----------------------------------------------- */void mcomb(char * notused){#pragma unused(notused)byte source = ~ vax_fetchb( opaddr[ 0 ] );	vax_putb( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}void mcomw(char * notused){#pragma unused(notused)word source = ~ vax_fetchw( opaddr[ 0 ] );	vax_putw( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}void mcoml(char * notused){#pragma unused(notused)long source = ~ vax_fetchl( opaddr[ 0 ] );	vax_putl( source, opaddr[ 1 ] );	SETNZ( source, 0 );	V = 0;}/* ---- Convert ---- */void cvtbw(char * notused){#pragma unused(notused)word dest = ( word ) vax_fetchb( opaddr[ 0 ] );	vax_putw( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = C = 0;}void cvtbl(char * notused){#pragma unused(notused)long dest = ( long ) vax_fetchb( opaddr[ 0 ] );	vax_putl( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = C = 0;}void cvtwb(char * notused){#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] );byte dest = ( byte ) source;word top = source & HI_BYTE_MASK;	vax_putb( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = dest < 0 ? (unsigned short) top != HI_BYTE_MASK:top != 0;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtwl(char * notused){#pragma unused(notused)long dest = ( long ) vax_fetchw( opaddr[ 0 ] );	vax_putl( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = C = 0;}void cvtlb(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );byte dest = ( byte ) source;long top = source  & ~BYTE_MASK;	vax_putb( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = dest < 0 ? top != ~BYTE_MASK:top != 0;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtlw(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );word dest = ( word ) source;long top = source  & HI_WORD_MASK;	vax_putw( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = dest < 0 ? top != HI_WORD_MASK:top != 0;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtbf(char * notused){#pragma unused(notused)extended source ;v_float dest;	source = vax_fetchb( opaddr[ 0 ] );	dest.f = e2f(source);	vax_putl( dest.f, opaddr[ 1 ] );	N = dest.f_bb.sign;	Z = dest.f_bb.exponent == 0 && N == 0;	V = 0;	C = 0;}void cvtwf(char * notused){#pragma unused(notused)extended source ;v_float dest;	source = vax_fetchw( opaddr[ 0 ] );	dest.f = e2f(source);	vax_putl( dest.f, opaddr[ 1 ] );	N = dest.f_bb.sign;	Z = dest.f_bb.exponent == 0 && N == 0;	V = 0;	C = 0;}void cvtlf(char * notused){#pragma unused(notused)extended source ;v_float dest;	source = vax_fetchl( opaddr[ 0 ] );	dest.f = e2f(source);	vax_putl( dest.f, opaddr[ 1 ] );	N = dest.f_bb.sign;	Z = dest.f_bb.exponent == 0 && N == 0;	V = 0;	C = 0;}void cvtfb(char * notused){#pragma unused(notused)v_float source;extended e_source;byte dest;	source.f  = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	e_source = f2e(source);	dest = (byte) e_source;	vax_putb( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = e_source > (extended)S_MAX_BYTE || e_source < (extended)S_MIN_BYTE ;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtfw(char * notused){#pragma unused(notused)v_float source;extended e_source;word dest;	source.f  = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	e_source = f2e(source);	dest = (word) e_source;	vax_putw( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = e_source > (extended)S_MAX_WORD || e_source < (extended)S_MIN_WORD ;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtfl(char * notused){#pragma unused(notused)v_float source;extended e_source;long dest;	source.f  = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	e_source = f2e(source);	dest = (long) e_source;	vax_putl( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = e_source > (extended)S_MAX_LONG || e_source < (extended)S_MIN_LONG;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void cvtrfl(char * notused){#pragma unused(notused)v_float source;extended e_source;long dest;	source.f  = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	e_source = f2e(source);	dest = (long) (e_source + 0.5);	vax_putl( dest, opaddr[ 1 ] );	SETNZ( dest, 0 );	V = e_source > (extended)S_MAX_LONG || e_source < (extended)S_MIN_LONG;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/*		Move Zero Extended	------------------------------------- */void movzbw(char * notused){#pragma unused(notused)word dest = ( unsigned short ) vax_fetchb( opaddr[ 0 ] ) & BYTE_MASK;	vax_putw( dest, opaddr[ 1 ] );	N = V = 0;	Z = EQL( dest, 0 );}void movzbl(char * notused){#pragma unused(notused)long dest = ( unsigned long ) vax_fetchb( opaddr[ 0 ] ) & BYTE_MASK;	vax_putl( dest, opaddr[ 1 ] );	N = V = 0;	Z = EQL( dest, 0 );}void movzwl(char * notused){#pragma unused(notused)long dest = ( unsigned long ) vax_fetchw( opaddr[ 0 ] ) & WORD_MASK;	vax_putl( dest, opaddr[ 1 ] );	N = V = 0;	Z = EQL( dest, 0 );}/*		Compares	-------------------------------------------- */void cmpb(char * notused){#pragma unused(notused)byte source1 = vax_fetchb( opaddr[ 0 ] );byte source2 = vax_fetchb( opaddr[ 1 ] );	SETNZ( source1, source2 );	V = 0;	C = LSSU( source1, source2 );}void cmpw(char * notused){#pragma unused(notused)word source1 = vax_fetchw( opaddr[ 0 ] ) ;word source2 = vax_fetchw( opaddr[ 1 ] );	SETNZ( source1, source2 );	V = 0;	C = LSSU( source1, source2 );}void cmpl(char * notused){#pragma unused(notused)long source1 = vax_fetchl( opaddr[ 0 ] );long source2 = vax_fetchl( opaddr[ 1 ] );	SETNZ( source1, source2 );	V = 0;	C = LSSU( source1, source2 );}void cmpq(char * notused){#pragma unused(notused)quad source1;quad source2;	source1 = vax_fetchq( opaddr[ 0 ] );	source2 = vax_fetchq( opaddr[ 1 ] );	N =    source1.long1 < source2.long1	  || ( source1.long1 == source2.long1 	  && ((unsigned long) source1.long0 < (unsigned long) source2.long0) );	Z = source1.long1 == source2.long1 && source1.long0 == source2.long0;	C = ((unsigned long)source1.long1 < (unsigned long)source2.long1)	  || ( source1.long1 == source2.long1 	  && ((unsigned long) source1.long0 < (unsigned long) source2.long0) );	V = 0;}void cmpf(char * notused){#pragma unused(notused)v_float source1 ;v_float source2;v_float result;	source1.f  = vax_fetchl( opaddr[ 0 ] );	if(source1.f_bb.sign == 1 && source1.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	source2.f = vax_fetchl( opaddr[ 1 ] );	if(source2.f_bb.sign == 1 && source2.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(source1) - f2e(source2));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;}/*		Increment	---------------------------------------------- */void incb(char * notused){#pragma unused(notused)byte source = vax_fetchb( opaddr[ 0 ] );	C = ( (unsigned char)source == U_MAX_BYTE);	V = (source == S_MAX_BYTE);	vax_putb( ++source, opaddr[ 0 ] );	SETNZ( source, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void incw(char * notused){#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] );	C = ((unsigned short) source == U_MAX_WORD);	V = source == S_MAX_WORD;	vax_putw( ++source, opaddr[ 0 ] );	SETNZ( source, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void incl(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );	C = source == U_MAX_LONG;	V = source == S_MAX_LONG;	vax_putl( ++source, opaddr[ 0 ] );	SETNZ( source, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/*		Test ----------------------------------------------------- */void tstb(char * notused){#pragma unused(notused)	SETNZ( vax_fetchb( opaddr[ 0 ] ), 0 );	V = C = 0;}void tstw(char * notused){#pragma unused(notused)	SETNZ( vax_fetchw( opaddr[ 0 ] ), 0 );	V = C = 0;}void tstl(char * notused){#pragma unused(notused)	SETNZ( vax_fetchl( opaddr[ 0 ] ), 0 );	V = C = 0;}	void tstf(char * notused){#pragma unused(notused)v_float source ;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	N = source.f_bb.sign;	Z = source.f_bb.exponent == 0 && N == 0;	V = 0;	C = 0;}/*		Add	----------------------------------------------------- */void addb2(char * notused){#pragma unused(notused)byte source = vax_fetchb( opaddr[ 0 ] );byte dest = vax_fetchb( opaddr[ 1 ] );byte result = source + dest;		vax_putb(result, opaddr[ 1 ] );	SETNZ(result, 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned char) source > (unsigned char)(U_MAX_BYTE) - (unsigned char) dest);*/	C = (unsigned char) result < (unsigned char) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void addb3(char * notused){#pragma unused(notused)byte source = vax_fetchb( opaddr[ 0 ] );byte dest = vax_fetchb( opaddr[ 1 ] );byte result = source + dest;	vax_putb( (byte)(result & BYTE_MASK), opaddr[ 2 ] );	SETNZ( (byte)(result & BYTE_MASK), 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned char) source > (unsigned char)(U_MAX_BYTE) - (unsigned char) dest);*/	C = (unsigned char) result < (unsigned char) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void  adawi(char *notused){#pragma unused(notused) 	get_interlock();	if( (opaddr[ 1 ] & 0x1)	&&	(opaddr[ 1 ] & ~REG_MASK) != REGBASE )		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);	else		addw2("adawi");	free_interlock();}void addw2(char * notused) {#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] );word dest = vax_fetchw( opaddr[ 1 ] );word result = source + dest;	vax_putw( result , opaddr[ 1 ] );	SETNZ( result, 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/* C = ((unsigned short) source > (unsigned short)(U_MAX_WORD) - (unsigned short) dest); */	C = (unsigned short) result < (unsigned short) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void addw3(char * notused){#pragma unused(notused)word source = vax_fetchw( opaddr[ 0 ] );word dest = vax_fetchw( opaddr[ 1 ] );word result = source + dest;	vax_putw( result , opaddr[ 2 ] );	SETNZ( result, 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned short) source > (unsigned short)(U_MAX_WORD) - (unsigned short) dest);*/	C = (unsigned short) result < (unsigned short) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void addl2(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );long dest = vax_fetchl( opaddr[ 1 ] );long result = source + dest;	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = result < 0 ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned long) source > (unsigned long)(U_MAX_LONG) - (unsigned long) dest);*/	C = (unsigned long) result < (unsigned long) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void addl3(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );long dest = vax_fetchl( opaddr[ 1 ] );long result = source + dest;	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned long) source > (unsigned long)(U_MAX_LONG) - (unsigned long) dest);*/	C = (unsigned long) result < (unsigned long) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void addf2(char * notused){#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(source) + f2e(dest));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 1 ] );}void addf3(char * notused) {#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(source) + f2e(dest));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 2 ] );}/*		Add with Carry 	------------------------------------------- */void adwc(char * notused){#pragma unused(notused)long source = vax_fetchl( opaddr[ 0 ] );long dest = vax_fetchl( opaddr[ 1 ] );long result = source + dest + C;	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = result < 0  ? (source > 0 && dest > 0 ) : (source < 0 && dest  < 0 );	/*C = ((unsigned long) source > (unsigned long)(U_MAX_LONG) - (unsigned long) dest);*/	C = (unsigned long) result < (unsigned long) source;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/*		Subtract		---------------------------------------------- */void subb2(char * notused){#pragma unused(notused)byte sub = vax_fetchb( opaddr[ 0 ] );byte dif = vax_fetchb( opaddr[ 1 ] );byte result = dif - sub;	vax_putb( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && dif > 0 ) ||		  ( result > 0 && sub > 0 && dif < 0 ) );	C = ( unsigned long) sub > ( unsigned long) dif;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subb3(char * notused){#pragma unused(notused)byte sub = vax_fetchb( opaddr[ 0 ] );byte min = vax_fetchb( opaddr[ 1 ] );byte result = min - sub;	vax_putb( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && min > 0 ) ||		  ( result > 0 && sub > 0 && min < 0 ) );	C = ( unsigned long) sub > ( unsigned long) min;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subw2(char * notused){#pragma unused(notused)word sub = vax_fetchw( opaddr[ 0 ] );word dif = vax_fetchw( opaddr[ 1 ] );word result = dif - sub;	vax_putw( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && dif > 0 ) ||		  ( result > 0 && sub > 0 && dif < 0 ) );	C = ( unsigned long) sub > ( unsigned long) dif;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subw3(char * notused){#pragma unused(notused)word sub = vax_fetchw( opaddr[ 0 ] );word min = vax_fetchw( opaddr[ 1 ] );word result = min - sub;	vax_putw( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && min > 0 ) ||		  ( result > 0 && sub > 0 && min < 0 ) );	C = ( unsigned long) sub > ( unsigned long) min;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subl2(char * notused){#pragma unused(notused)long sub = vax_fetchl( opaddr[ 0 ] );long dif = vax_fetchl( opaddr[ 1 ] );long result = dif - sub;	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && dif > 0 ) ||		  ( result > 0 && sub > 0 && dif < 0 ) );	C = ( unsigned long) sub > ( unsigned long) dif;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subl3(char * notused){#pragma unused(notused)long sub = vax_fetchl( opaddr[ 0 ] );long min = vax_fetchl( opaddr[ 1 ] );long result = min - sub;	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && min > 0 ) ||		  ( result > 0 && sub > 0 && min < 0 ) );	C = ( unsigned long) sub > ( unsigned long) min;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void subf2(char * notused){#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) - f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 1 ] );}void subf3(char * notused) {#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) - f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 2 ] );}/*		Decrement	----------------------------------------------- */void decb(char * notused){#pragma unused(notused)byte dif = vax_fetchb( opaddr[ 0 ] );	V = dif == S_MIN_BYTE;	C = dif == 0;	vax_putb( --dif, opaddr[ 0 ] );	SETNZ( dif, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void decw(char * notused){#pragma unused(notused)word dif = vax_fetchw( opaddr[ 0 ] );	V = dif == S_MIN_WORD;	C = dif == 0;	vax_putw( --dif, opaddr[ 0 ] );	SETNZ( dif, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void decl(char * notused){#pragma unused(notused)long dif = vax_fetchl( opaddr[ 0 ] );	V = dif == S_MIN_LONG;	C = dif == 0;	vax_putl( --dif, opaddr[ 0 ] );	SETNZ( dif, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/* 	Subtract with Carry 	--------------------------------------- */void sbwc(char * notused){#pragma unused(notused)long sub = vax_fetchl( opaddr[ 0 ] );long min = vax_fetchl( opaddr[ 1 ] );long result = min - sub - C;	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = (  ( result < 0 && sub < 0 && min > 0 ) ||		  ( result > 0 && sub > 0 && min < 0 ) );	C = ( unsigned long) result > ( unsigned long) min;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/*		Multiply	---------------------------------------------- */void mulb2(char * notused){#pragma unused(notused)extended prod = vax_fetchb( opaddr[ 0 ] ) * vax_fetchb( opaddr[ 1 ] );	vax_putb( ( byte ) prod, opaddr[ 1 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_BYTE || prod < S_MIN_BYTE;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mulb3(char * notused){#pragma unused(notused)extended prod = vax_fetchb( opaddr[ 0 ] ) * vax_fetchb( opaddr[ 1 ] );	vax_putb( ( byte ) prod, opaddr[ 2 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_BYTE || prod < S_MIN_BYTE;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mulw2(char * notused){#pragma unused(notused)extended prod = vax_fetchw( opaddr[ 0 ] ) * vax_fetchw( opaddr[ 1 ] );	vax_putw( ( word ) prod, opaddr[ 1 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_WORD || prod < S_MIN_WORD;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mulw3(char * notused){#pragma unused(notused)extended prod = vax_fetchw( opaddr[ 0 ] ) * vax_fetchw( opaddr[ 1 ] );	vax_putw( ( word ) prod, opaddr[ 2 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_WORD || prod < S_MIN_WORD;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mull2(char * notused){#pragma unused(notused)extended prod = vax_fetchl( opaddr[ 0 ] ) * vax_fetchl( opaddr[ 1 ] );	vax_putl( ( long ) prod, opaddr[ 1 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_LONG || prod < S_MIN_LONG;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void mull3(char * notused){#pragma unused(notused)extended prod = vax_fetchl( opaddr[ 0 ] ) * vax_fetchl( opaddr[ 1 ] );	vax_putl( ( long ) prod, opaddr[ 2 ] );	SETNZ( prod,  0 );	V = prod > S_MAX_LONG || prod < S_MIN_LONG;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void emul(char * notused){#pragma unused(notused)sl t;sl u;sl x;sl y;unsigned long z;sl r[2];quad result;	x.l = (ul) vax_fetchl( opaddr[ 0 ] );	y.l = (ul) vax_fetchl( opaddr[ 1 ] );	z   = (ul) vax_fetchl( opaddr[ 2 ] );		/* multiply lo by lo */	r[1].l =  (ul)lo(x) * (ul)lo(y);		/* multiply lo * hi */	u.l = ( (ul) lo(x) * (ul) hi(y) ) ;	t.l = u.l + (ul) hi(r[1]);	if( t.l < u.l)		hi(r[0]) = 1;		/*multiply hi * lo */	u.l = ((ul) hi(x) * (ul) lo(y));	t.l = u.l + t.l;	if( t.l < u.l ) hi(r[0])++;	hi(r[1]) = lo(t);	lo(r[0]) = hi(t);			/* multiply hi * hi */	t.l = ((ul)hi(x) * (ul)hi(y) ) + r[0].l;	r[0] = t;		if(y.l & LONG_HI_BIT)	{		/* Got sign extend problems to handle*/		t.l = ((ul)lo(x) * (ul)0xffff);		hi(t) += lo(t) ;		hi(t) += ((ul) hi(x) * (ul)0xffff) & 0xffff;		r[0].l += t.l;	}	if(x.l & LONG_HI_BIT)	{		t.l = ((ul)lo(y) *  (ul)0xffff);		hi(t) += lo(t) ;		hi(t) += ((ul) hi(y) * (ul)0xffff) & 0xffff;		r[0].l += t.l;	}			result.long0 = r[1].l + z;	if(result.long0 < r[1].l)	{		r[0].l++;	}	if(z & LONG_HI_BIT)		result.long1 = (long) (r[0].l + U_MAX_LONG);	else		result.long1 = (long) r[0].l;			C = 0;	V = 0;	Z = result.long1 == 0 && result.long0 == 0;	N = result.long1 < 0;		vax_putq( result, opaddr[ 3 ]);}void mulf2(char * notused){#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) * f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 1 ] );}void mulf3(char * notused) {#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) * f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 2 ] );}void polyf(char * notused) { /*should be interruptable. But is not*/#pragma unused(notused)v_float arg ; /*as in the arg = x in c[2]x**2 + c[1]x + c[0]*/extended x;	  /*mac version of arg*/unsigned short degree = vax_fetchw(opaddr[1]); /*of the poly*/address table = opaddr[ 2 ]; /*address of the table of coefficients*/v_float c; /*next coefficient*/v_float result ;long underflow_occured = 0;	if(degree > 31)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	R1 = 0;	 /*These get blatted reguardless of the result*/	R2 = 0;	C = 0;		arg.f = vax_fetchl( opaddr[ 0 ] );	if(arg.f_bb.sign == 1 && arg.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	x = f2e(arg);		c.f = vax_fetchl( table );	if(c.f_bb.sign == 1 && c.f_bb.exponent == 0)	{		R3 = table;		R0 = c.f; /*reserved operand*/		N = 1; Z = 0; V = 1;		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	table += 4;	/*Next float address*/	result = c; /*first time through*/	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = 0;	/*must be as we didn't Trap above*/		while ( degree--) 	{		c.f = vax_fetchl( table );		if(c.f_bb.sign == 1 && c.f_bb.exponent == 0)		{			R3 = table;			R0 = c.f; /*reserved operand*/			exception(FAULT,V_RO,"Reserved Operand Fault",0,0);			return;		}		table += 4;	/*Next float address*/		result.f = e2f((f2e(result) * x) + f2e(c));				N = result.f_bb.sign;		Z = result.f_bb.exponent == 0 && N == 0;		V = result.f_bb.exponent == 0 && N;		if(V)		{			R3 = table;			R0 = result.f; /*reserved operand*/			arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );			return	;		}			if(floating_underflow)		{			underflow_occured = 1;			result.f = 0;		}	}		if(stop_writes == 0)	{		R0 = result.f;		R3 = table;	} 		if(FU && underflow_occured)	{		arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );		return;	}}/*		Divide	------------------------------------------------- */void divb2(char * notused){#pragma unused(notused)byte dividend = vax_fetchb( opaddr[ 1 ] );byte divisor = vax_fetchb( opaddr[ 0 ] );byte quo;	V = ( dividend == S_MIN_BYTE && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0)	{		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putb( quo  = dividend / divisor, opaddr[ 1 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divb3(char * notused){#pragma unused(notused)byte dividend = vax_fetchb( opaddr[ 1 ] );byte divisor = vax_fetchb( opaddr[ 0 ] );byte quo ;	V = ( dividend == S_MIN_BYTE && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0)	{		vax_putb( dividend, opaddr[ 2 ] );		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putb( quo = dividend / divisor, opaddr[ 2 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divw2(char * notused){#pragma unused(notused)word dividend = vax_fetchw( opaddr[ 1 ] );word divisor = vax_fetchw( opaddr[ 0 ] );word quo ;	V = ( dividend == S_MIN_WORD && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0)	{		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putw( quo = dividend / divisor, opaddr[ 1 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divw3(char * notused){#pragma unused(notused)word dividend = vax_fetchw( opaddr[ 1 ] );word divisor = vax_fetchw( opaddr[ 0 ] );word quo ;	V = ( dividend == S_MIN_WORD && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0)	{		vax_putw( dividend, opaddr[ 2 ] );		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putw( quo = dividend / divisor, opaddr[ 2 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divl2(char * notused){#pragma unused(notused)long dividend = vax_fetchl( opaddr[ 1 ] );long divisor = vax_fetchl( opaddr[ 0 ] );long quo ;	V = ( dividend == S_MIN_LONG && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0)	{		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putl( quo = dividend / divisor, opaddr[ 1 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divl3(char * notused){#pragma unused(notused)long dividend = vax_fetchl( opaddr[ 1 ] );long divisor = vax_fetchl( opaddr[ 0 ] );long quo ;	V = ( dividend == S_MIN_LONG && divisor == - 1 ) || ( divisor == 0 );	if( V && divisor == 0 )	{		vax_putl( dividend, opaddr[ 2 ] );		arithmetic_fault( INTEGER_DIVIDE_BY_ZERO_TRAP,"Integer Divide By Zero" );		return;	}	vax_putl( quo = dividend / divisor, opaddr[ 2 ] );	SETNZ( quo, 0 );	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void divf2(char * notused){#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) / f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		if(source.f == 0)		{			arithmetic_fault( FLOATING_DIVIDE_BY_ZERO_FAULT,"Floating Divide By Zero Fault" );		}		else		{			arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		}		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 1 ] ); /*1986 handbook says this should be here*/											 /*The 1977 handbook says it should be before the if(V)*/}void divf3(char * notused) {#pragma unused(notused)v_float source ;v_float dest;v_float result;	source.f = vax_fetchl( opaddr[ 0 ] );	if(source.f_bb.sign == 1 && source.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	dest.f  = vax_fetchl( opaddr[ 1 ] );	if(dest.f_bb.sign == 1 && dest.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	result.f = e2f(f2e(dest) / f2e(source));	N = result.f_bb.sign;	Z = result.f_bb.exponent == 0 && N == 0;	V = result.f_bb.exponent == 0 && N;	C = 0;	if(V)	{		if(source.f == 0)		{			arithmetic_fault( FLOATING_DIVIDE_BY_ZERO_FAULT,"Floating Divide By Zero Fault" );		}		else		{			arithmetic_fault( FLOATING_OVERFLOW_FAULT,"Floating Overflow Fault" );		}		return	;	}		if(FU && floating_underflow)	{			arithmetic_fault( FLOATING_UNDERFLOW_FAULT,"Floating Underflow Fault" );			return;	}	vax_putl( result.f, opaddr[ 2 ] ); /*1986 handbook says this should be here*/											 /*The 1977 handbook says it should be before the if(V)*/}/*		Bit Test		---------------------------------------------- */void bitb(char * notused){#pragma unused(notused)	SETNZ( (vax_fetchb( opaddr[ 0 ] ) & vax_fetchb( opaddr[ 1 ] )), 0 );	V = 0;}void bitw(char * notused){#pragma unused(notused)	SETNZ( (vax_fetchw( opaddr[ 0 ] ) & vax_fetchw( opaddr[ 1 ] )), 0 );	V = 0;}void bitl(char * notused){#pragma unused(notused)	SETNZ( (vax_fetchl( opaddr[ 0 ] ) & vax_fetchl( opaddr[ 1 ] )), 0 );	V = 0;}/* 	Bit Set 	-------------------------------------------------- */void bisb2(char * notused){#pragma unused(notused)byte result = vax_fetchb( opaddr[ 0 ] ) | vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void bisb3(char * notused){#pragma unused(notused)byte result = vax_fetchb( opaddr[ 0 ] ) | vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void bisw2(char * notused){#pragma unused(notused)word result = vax_fetchw( opaddr[ 0 ] ) | vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void bisw3(char * notused){#pragma unused(notused)word result = vax_fetchw( opaddr[ 0 ] ) | vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void bisl2(char * notused){#pragma unused(notused)long result = vax_fetchl( opaddr[ 0 ] ) | vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void bisl3(char * notused){#pragma unused(notused)long result = vax_fetchl( opaddr[ 0 ] ) | vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void  bispsw(char * notused){#pragma unused(notused)word mask = vax_fetchw(opaddr[ 0 ]);	if(mask & HI_BYTE_MASK)		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);	else		PSW |= mask;}/* 	Bit Clear	---------------------------------------------- */void bicb2(char * notused){#pragma unused(notused)byte result = ~ vax_fetchb( opaddr[ 0 ] ) & vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 1 ] );	SETNZ( result, 0);	V = 0;}void bicb3(char * notused){#pragma unused(notused)byte result = ~ vax_fetchb( opaddr[ 0 ] ) & vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void bicw2(char * notused){#pragma unused(notused)word result = ~ vax_fetchw( opaddr[ 0 ] ) &  vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void bicw3(char * notused){#pragma unused(notused)word result = ~ vax_fetchw( opaddr[ 0 ] ) & vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void bicl2(char * notused){#pragma unused(notused)long result = ~ vax_fetchl( opaddr[ 0 ] ) &  vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void bicl3(char * notused){#pragma unused(notused)long result = ~ vax_fetchl( opaddr[ 0 ] ) & vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void  bicpsw(char * notused){#pragma unused(notused)word mask = vax_fetchw(opaddr[ 0 ]);	if(mask & HI_BYTE_MASK)		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);	else		PSW &= ~mask;}/*		Exclusive Or	---------------------------------------------- */void xorb2(char * notused){#pragma unused(notused)byte result = vax_fetchb( opaddr[ 0 ] ) ^ vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void xorb3(char * notused){#pragma unused(notused)byte result = vax_fetchb( opaddr[ 0 ] ) ^ vax_fetchb( opaddr[ 1 ] );	vax_putb( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void xorw2(char * notused){#pragma unused(notused)word result = vax_fetchw( opaddr[ 0 ] ) ^ vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void xorw3(char * notused){#pragma unused(notused)word result = vax_fetchw( opaddr[ 0 ] ) ^ vax_fetchw( opaddr[ 1 ] );	vax_putw( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}void xorl2(char * notused){#pragma unused(notused)long result = vax_fetchl( opaddr[ 0 ] ) ^ vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 1 ] );	SETNZ( result, 0 );	V = 0;}void xorl3(char * notused){#pragma unused(notused)long result = vax_fetchl( opaddr[ 0 ] ) ^ vax_fetchl( opaddr[ 1 ] );	vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}/*		Arithmetic shift	------------------------------------------- */void ashl(char * notused) {#pragma unused(notused)byte count = vax_fetchb( opaddr[ 0 ] );long source = vax_fetchl( opaddr[ 1 ] );long result;unsigned long mask;	if( count < 0 ) 	{			if(count < -31)			count = 31;		else			count = -count;		result = source >> count;		V = 0;	}	else if( count > 0 )	{		if(count >= 32)		{			result = 0;			mask = S_MAX_LONG;		}		else		{			result = source << count;			mask = ~( ( 1 << (31 - count) ) - 1 ) & S_MAX_LONG;		}		V = (source & mask) != ((source & LONG_HI_BIT) ? mask : 0);	}	else	{		result = source;		V = 0;	}	vax_putl( ( long ) result, opaddr [ 2 ] );	SETNZ( result, 0 );	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}void ashq(char * notused) {#pragma unused(notused)quad xxx, mask;byte count = vax_fetchb( opaddr[ 0 ] );quad source;quad result;	source = vax_fetchq( opaddr[ 1 ] );	if( count < 0 )	{		count = -count;		xxx = source;		if(count < 32)			xxx.long0 = ((unsigned long) xxx.long0 >> count) | (xxx.long1 << (32 - count));		else if(count < 64)		{			xxx.long0 = xxx.long1 >> (count - 32);		}		else			xxx.long0 = xxx.long1 >> 32;		xxx.long1 >>= count;		result =  xxx;		V = 0;	}	else if( count > 0 ) 	{		xxx = source;		mask = quad_zero;		if(count < 32)		{			mask.long1 = LONG_HI_BIT >> (32 - count);			V = (xxx.long1 & mask.long1) != ((xxx.long1 & LONG_HI_BIT) ?  mask.long1:0);			xxx.long1 = (xxx.long1 << count) | ((unsigned long)xxx.long0 >> (32 - count));		}		else if( count < 64)		{			mask.long0 = LONG_HI_BIT >> (64 - count);			mask.long1 = U_MAX_LONG;			V = ( (xxx.long1 & mask.long1) != ((xxx.long1 & LONG_HI_BIT) ?  mask.long1:0) ) 				|| ( (xxx.long0 & mask.long0) != ((xxx.long1 & LONG_HI_BIT) ? mask.long0:0) );			xxx.long1 = (xxx.long0 << (count - 32));		}		else			{	mask.long1 = U_MAX_LONG;			V = (xxx.long1 != ((xxx.long1 & LONG_HI_BIT) ? mask.long1:0)) 				|| (xxx.long0 != ((xxx.long1 & LONG_HI_BIT) ? mask.long1:0));			xxx = quad_zero;		}		xxx.long0 <<= count;		result =  xxx;	}	else 	{		result = source;		V = 0;	}	vax_putq( result, opaddr [ 2 ] );	N = result.long1 < 0 ;	Z = result.long1 == 0 && result.long0 == 0;	C = 0;	if(IV && V)		arithmetic_fault( INTEGER_OVERFLOW_TRAP,"Integer Overflow Trap" );}/* 	Rotate	-------------------------------------------------- */void rotl(char * notused){#pragma unused(notused)byte count = vax_fetchb( opaddr[ 0 ] ) & 31;long source = vax_fetchl( opaddr[ 1 ] );long result;	if(count > 0)		result = (source << count) | ( ( source >> ( 32 - count )) & ((1 << count) - 1) );	else if(count < 0)		result = (source << (32 - count)) | ( ( source >> count ) & ((1 << (32 - count)) - 1) );	else		result = source;		vax_putl( result, opaddr[ 2 ] );	SETNZ( result, 0 );	V = 0;}/*		Push Registers	------------------------------------------- */void pushr(char * notused) {#pragma unused(notused)word mask = vax_fetchw ( opaddr [ 0 ] );unsigned short p;long r;address hold_sp = SP;	for( r = 14, p = 0x4000; p ; p >>= 1, --r )		if( mask & p )		{			hold_sp -= 4;			vax_putl( vax_regs[ r ].contents.as_long, hold_sp );		}		SP = hold_sp;	/*need to do this so we save the right SP*/}/* 	Pop Registers	------------------------------------------- */void popr(char * notused) {#pragma unused(notused)word mask = vax_fetchw( opaddr [ 0 ] );word p;long r;	for( r = 0, p = 0x01; p != 0x4000; p <<= 1, r++ )	{			if( mask & p )		{				vax_regs[ r ].contents.as_long = vax_fetchl( SP );			SP += 4;		}	}	if( 0x4000 & mask )	/*special case for the SP*/		SP = vax_fetchl( SP );}	/* Compute Index */void index(char * notused){#pragma unused(notused)long subscript = vax_fetchl(opaddr[ 0 ]);long low = vax_fetchl(opaddr[ 1 ]);long high = vax_fetchl(opaddr[ 2 ]);long size = vax_fetchl(opaddr[ 3 ]);long indexin = vax_fetchl(opaddr[ 4 ]);long indexout = (indexin + subscript) * size;	vax_putl(indexout, opaddr[5]);	SETNZ( indexout, 0 );	if(subscript < low || subscript > high)	{		arithmetic_fault(SUBSCRIPT_RANGE_TRAP,"INDEX: subscript out of range");	}		}/* 	Push, Move Address 	----------------------------------------- *//* Only need one. Given the address. Move it to another address. */void movax(char * notused){#pragma unused(notused)address source = opaddr[ 0 ];	vax_putl( source, opaddr[ 1 ] );	SETNZ( (long) source, 0 );	V = 0;}void pusha(char * notused){#pragma unused(notused)address source = opaddr[ 0 ];	SP -= 4;	vax_putl( source, SP);	SETNZ( (long) source, 0 );	V = 0;}/*		Branch ( on condition )  	------------------------------------ */void bneq(char * notused){#pragma unused(notused)	if( !Z )		PC = opaddr[ 0 ];}void bnequ(char * notused){#pragma unused(notused)	if( !Z )		PC = opaddr[ 0 ];}void beql(char * notused){#pragma unused(notused)	if( Z )		PC = opaddr[ 0 ];}void beqlu(char * notused){#pragma unused(notused)	if( Z )		PC = opaddr[ 0 ];}void bgtr(char * notused){#pragma unused(notused)	if( !(N || Z) )		PC = opaddr[ 0 ];}void bleq(char * notused){#pragma unused(notused)	if( N || Z )		PC = opaddr[ 0 ];}void bgeq(char * notused){#pragma unused(notused)	if( !N )		PC = opaddr[ 0 ];}void blss(char * notused){#pragma unused(notused)	if( N )		PC = opaddr[ 0 ];}void bgtru(char * notused){#pragma unused(notused)	if( !(C || Z) )		PC = opaddr[ 0 ];}void blequ(char * notused){#pragma unused(notused)	if( C || Z )		PC = opaddr[ 0 ];}void bvc(char * notused){#pragma unused(notused)	if( !V )		PC = opaddr[ 0 ];}void bvs(char * notused){#pragma unused(notused)	if( V )		PC = opaddr[ 0 ];}void bgequ(char * notused){#pragma unused(notused)	if( !C )		PC = opaddr[ 0 ];}void bcc(char * notused){#pragma unused(notused)	if( !C )		PC = opaddr[ 0 ];}void blssu(char * notused){#pragma unused(notused)	if( C )		PC = opaddr[ 0 ];}void bcs(char * notused){#pragma unused(notused)	if( C )		PC = opaddr[ 0 ];}/*branch on low bit set or clear*/void blbs(char * notused){#pragma unused(notused)long src = vax_fetchl( opaddr[ 0 ] );	if(src & 1)		PC = opaddr [ 1 ] ;}void blbc(char * notused){#pragma unused(notused)long src = vax_fetchl( opaddr[ 0 ] );	if(!(src & 1))		PC = opaddr [ 1 ] ;}/*		Branch, Jump	------------------------------------------- */void brb(char * notused){#pragma unused(notused)	PC = opaddr [ 0 ] ;}void brw(char * notused){#pragma unused(notused)	PC = opaddr [ 0 ] ;}void jmp(char * notused){#pragma unused(notused)	PC = opaddr[ 0 ];}/*Loop Control*/	void acbb(char * notused){#pragma unused(notused)byte limit = vax_fetchb( opaddr[ 0 ] );byte add = vax_fetchb( opaddr[ 1 ] );byte index = vax_fetchb( opaddr[ 2 ] );byte result = index + add;		vax_putb( result, opaddr[ 2 ] );	V = result & BYTE_HI_BIT ? (add > 0 && index > 0 ) : (add < 0 && index  < 0 );	SETNZ( result, 0 );	if(  (add > 0 && LEQ(result,limit))	  || (add < 0 && GEQ(result,limit)) )		PC = opaddr[ 3 ];}void acbw(char * notused){#pragma unused(notused)word limit = vax_fetchw( opaddr[ 0 ] );word add = vax_fetchw( opaddr[ 1 ] );word index = vax_fetchw( opaddr[ 2 ] );word result = index + add;		vax_putw( result, opaddr[ 2 ] );	V = result & WORD_HI_BIT ? (add > 0 && index > 0 ) : (add < 0 && index  < 0 );	SETNZ( result, 0 );	if(  (add > 0 && LEQ(result,limit))	  || (add < 0 && GEQ(result,limit)) )		PC = opaddr[ 3 ];}void acbl(char * notused){#pragma unused(notused)long limit = vax_fetchl( opaddr[ 0 ] );long add = vax_fetchl( opaddr[ 1 ] );long index = vax_fetchl( opaddr[ 2 ] );long result = index + add;		vax_putl( result, opaddr[ 2 ] );	V = result & LONG_HI_BIT ? (add > 0 && index > 0 ) : (add < 0 && index  < 0 );	SETNZ( result, 0 );	if(  (add > 0 && LEQ(result,limit))	  || (add < 0 && GEQ(result,limit)) )		PC = opaddr[ 3 ];}void acbf(char * notused){#pragma unused(notused)v_float limit;v_float add ;v_float index;		limit.f = vax_fetchl( opaddr[ 0 ] );	if(limit.f_bb.sign == 1 && limit.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	add.f = vax_fetchl( opaddr[ 1 ] );	if(add.f_bb.sign == 1 && add.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	index.f = vax_fetchl( opaddr[ 2 ] );	if(index.f_bb.sign == 1 && index.f_bb.exponent == 0)	{		exception(FAULT,V_RO,"Reserved Operand Fault",0,0);		return;	}	index.f = e2f(f2e(index) + f2e(add));	vax_putl( index.f, opaddr[ 2 ] );	N = index.f_bb.sign;	Z = index.f_bb.exponent == 0 && N == 0;	V = index.f_bb.exponent == 0 && N;	if( !V 	  && ((e2f(add.f) > 0 && LEQ(e2f(index.f),e2f(limit.f)))	  || (e2f(add.f) < 0 && GEQ(e2f(index.f),e2f(limit.f))) ))		PC = opaddr[ 3 ];}void aobleq(char * notused){#pragma unused(notused)long limit = vax_fetchl( opaddr[ 0 ] );long index = vax_fetchl( opaddr[ 1 ] );	V = index == S_MAX_LONG;	vax_putl( ++index, opaddr[ 1 ] );	SETNZ( index, 0 );	if(LEQ(index,limit))		PC = opaddr[ 2 ];}void aoblss(char * notused){#pragma unused(notused)long limit = vax_fetchl( opaddr[ 0 ] );long index = vax_fetchl( opaddr[ 1 ] );	V = index == S_MAX_LONG;	vax_putl( ++index, opaddr[ 1 ] );	SETNZ( index, 0 );	if(LSS(index,limit))		PC = opaddr[ 2 ];}void sobgeq(char * notused){#pragma unused(notused)long index = vax_fetchl( opaddr[ 0 ] );	V = index == S_MIN_LONG;	vax_putl( --index, opaddr[ 0 ] );	SETNZ( index, 0 );	if(GEQ(index,0))		PC = opaddr[ 1 ];}void sobgtr(char * notused){#pragma unused(notused)long index = vax_fetchl( opaddr[ 0 ] );	V = index == S_MIN_LONG;	vax_putl( --index, opaddr[ 0 ] );	SETNZ( index, 0 );	if(GTR(index,0))		PC = opaddr[ 1 ];}/* Bit Field Intstructions */void extv(char * notused){#pragma unused(notused)unsigned char size = (unsigned char) vax_fetchb(opaddr[1]);long result = vax_fetchv(opaddr[2],vax_fetchl(opaddr[0]),size);		if(size && result & (1 << (size - 1)))		result |= ~((1 << (size - 1) ) - 1);	vax_putl(result,opaddr[3]);	V = C = 0;	SETNZ( result,  0 );}void extzv(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[2],vax_fetchl(opaddr[0]),(unsigned char)vax_fetchb(opaddr[1]));		vax_putl(result,opaddr[3]);	V = C = 0;	SETNZ( result,  0 );}void insv(char * notused){#pragma unused(notused)long src = vax_fetchl(opaddr[0]);		vax_putv(src,opaddr[3],vax_fetchl(opaddr[1]), (unsigned char) vax_fetchb(opaddr[2]));	N = Z = V = C = 0;}/* find fist set or clear bit*/void ffs(char * notused){#pragma unused(notused)unsigned char size = (unsigned char) vax_fetchb(opaddr[1]) ;long offset = vax_fetchl(opaddr[0]);long result = vax_fetchv(opaddr[2],offset,size);		Z = 1;	while(size > 0)	{				if(result & 1)		{			Z = 0;			break;		}		else		{			offset++;			size--;			result >>= 1;		}	}	vax_putl(offset ,opaddr[3]);	N = V = C = 0;}void ffc(char * notused){#pragma unused(notused)unsigned char size = (unsigned char) vax_fetchb(opaddr[1]);long offset = vax_fetchl(opaddr[0]);long result = vax_fetchv(opaddr[2],offset,size);		Z = 1;	while(size > 0)	{				if(result & 1)		{			offset++;			size--;			result >>= 1;		}		else		{			Z = 0;			break;		}		}	vax_putl(offset,opaddr[3]);	N = V = C = 0;}/* Bit Field Compare instructions */void cmpv(char * notused){#pragma unused(notused)unsigned char size = (unsigned char)vax_fetchb(opaddr[1]);long result = vax_fetchv(opaddr[2],vax_fetchl(opaddr[0]),size);long src = vax_fetchl(	opaddr[3] );	if(size && result & (1 << (size - 1)))		result |= ~((1 << (size - 1) ) - 1);	SETNZ( result, src );	V = 0;	C = LSSU( result, src );}void cmpzv(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[2],vax_fetchl(opaddr[0]),(unsigned char)vax_fetchb(opaddr[1]));long src = vax_fetchl(	opaddr[3] );	SETNZ( result, src );	V = 0;	C = LSSU( result, src );}/* Branch on bit set or clear */void bbc(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result == 0)		PC = opaddr[2];}void bbcs(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result == 0)		PC = opaddr[2];	vax_putv(1,opaddr[1],vax_fetchl(opaddr[0]),1);}void bbcci(char * notused){#pragma unused(notused)	get_interlock();	bbcc("bbcci");	free_interlock();}void bbcc(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result == 0)		PC = opaddr[2];	vax_putv(0,opaddr[1],vax_fetchl(opaddr[0]),1);}void bbs(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result)		PC = opaddr[2];}void bbssi(char * notused){#pragma unused(notused)	get_interlock();	bbss("bbssi");	free_interlock();}void bbss(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result)		PC = opaddr[2];	vax_putv(1,opaddr[1],vax_fetchl(opaddr[0]),1);}void bbsc(char * notused){#pragma unused(notused)long result = vax_fetchv(opaddr[1],vax_fetchl(opaddr[0]),1);		if(result)		PC = opaddr[2];	vax_putv(0,opaddr[1],vax_fetchl(opaddr[0]),1);}