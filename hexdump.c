#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<StdIO.h>#define __HEXDUMP_C_#include "window.h"#include "main.h"#include "hexdump.h"#include "mmemory.h"#include "aprintf.h"#include "docmds.h"#pragma segment HEXWINDOWstatic void puthnible(		long n){char b;	b = vax_fetchb((dumphw_cline + dumphw_cbyte)) & ( dumphw_cshift ? NIBBLE_MASK : HI_NIBBLE_MASK);	vax_putb(((n & NIBBLE_MASK) << dumphw_cshift) | b, dumphw_cline + dumphw_cbyte) ;	}void dumphw_goto(	/*Shift the window origin to display address a*/	register address a){register address lbase;register address new_cline; 	lbase 		= a >> (unsigned long) 4; 		/* Gives us the line number*/ 	new_cline 	= a & ( ~NIBBLE_MASK );			/* Gives us the address of the first byte on the line*/	if(new_cline <= last_lbase_h)	{			dumphWindow.theOrigin.v = (short) lbase; /* This must loose bits if address a above 0xFFFFF (about 1M)? */	}	else if(new_cline >= first_stackaddress_h && new_cline <= last_sysbase_h)	{			dumphWindow.theOrigin.v = (short) ( lbase - (first_stackaddress_h >> (unsigned long)4) + (last_lbase_h >> (unsigned long)4) + 1); /* This must loose bits? */	}	else	{	aprintf("Can't goto address 0x%x",a);		/*SysBeep(5);*/		return;	}	SetCtlValue(dumphWindow.vScroll, dumphWindow.theOrigin.v);	*((unsigned *)(&dumphw_cline)) = new_cline; 	dumphw_cbyte =  a & NIBBLE_MASK; /*a - (unsigned)new_cline; of a % 16 */	if(in_ascii)	{		dumphw_byte = dumphw_cbyte + ASCII_START;		dumphw_cshift = 0;	}	else	{		dumphw_byte = dumphw_cbyte * 3 + 1;		dumphw_cshift = 4;	}}void dumphw_click(	/*Process a click in the window*/	Point *p,	short modifiers){#pragma unused(modifiers)register long cw = CharWidth('0');register short line_size = dumphWindow.lsize;register short column1 = cw * 8 + 4;	if( p->h > column1 && p->v > line_size)	{		dumphw_cline = dumphWindow.mbase + (p->v  / line_size) * 16 - 16 ;		if(dumphw_cline > last_lbase_h)			dumphw_cline = first_stackaddress_h + (dumphw_cline - last_lbase_h - 16);		dumphw_byte = (p->h - column1) / cw ;		in_ascii = (dumphw_byte >= ASCII_START && dumphw_byte <= ASCII_END);		if( dumphw_byte <= ASCII_END && ((dumphw_byte % 3) || in_ascii ))		{	/*valid click*/			if(in_ascii)			{				dumphw_cbyte = dumphw_byte - ASCII_START;				dumphw_cshift = 0;			}			else			{				if((dumphw_cbyte = dumphw_byte - dumphw_byte / 3) & 1)					dumphw_cshift = 4;				else					dumphw_cshift = 0;				dumphw_cbyte = (dumphw_cbyte - 1) / 2;			}		}		else			dumphw_cline = -1;		update_hexmem_window();		return;	}}static void draw_h_cursor(	/*draw the cursor*/	short v){register short cw 	     = CharWidth('0');register short line_size = dumphWindow.lsize;register short column1 	 = cw * 8 + 4;Rect 	 dumphw_r;	if(dumphw_cline == -1)		return;	dumphw_r.left 		=  (dumphw_byte * cw) + column1 ;	dumphw_r.right 		=  dumphw_r.left + cw;	dumphw_r.bottom 	=  v + dumphWindow.forigin;				dumphw_r.top		=  dumphw_r.bottom - line_size;	dumphw_r.bottom 	-= dumphWindow.leading;	InvertRect(&dumphw_r);}static void draw_h_watches(	/*Draw the watch point outlined boxes*/	char *box,	/*array of bytes with 1's set if a watch point box needed*/	short v		){register long i;register short cw = CharWidth('0');register short line_size =  dumphWindow.lsize;Rect dumphw_r;	for(i = 1; i < ASCII_START; i += 3)	{		if(*box++)		{			dumphw_r.left 		=  (i * cw) + (cw * 8) + 3;			dumphw_r.right 		=  dumphw_r.left + cw + cw + 2;			dumphw_r.bottom 	=  v + dumphWindow.forigin;						dumphw_r.top		=  dumphw_r.bottom - line_size;			dumphw_r.bottom 	-= dumphWindow.leading;			FrameRect(&dumphw_r);		}	}}address get_c_pos_h(	/*Return the cursor position	 */	/*Return -1 if the cursor is nil */	void){address loc;	if(dumphw_cline == -1)		return ERROR;	else	{		loc = ( address ) (dumphw_cline + dumphw_cbyte);		if(dumphw_cline < last_lbase_h)			return loc;		else if((unsigned long) dumphw_cline < last_sysbase_h)			return loc;		else			return ERROR; /*Should never be the case*/	}}void dumphw_keypress(	/*Handle Key presses when window is active*/	long key){	if(dumphw_cline == -1)		return;	if(ignore_mode == 1)		displaymode = 1;	/*move screen if not displayed*/	if(in_ascii)	{		vax_putb((char)( key & BYTE_MASK ),dumphw_cline + dumphw_cbyte); 		if(++dumphw_cbyte == 16)		{			dumphw_cbyte = 0;			dumphw_byte = ASCII_START;			dumphw_cline += 16;		}		else			dumphw_byte++;	}	else	{		if(key >= '0' && key <= '9' ) 		{			puthnible(key - '0');		}		else if(key >= 'a' && key <= 'f')		{			puthnible(key - 'W' );		}		else if(key >= 'A' && key <= 'F')		{			puthnible(key - '7' );		}		else		{	aprintf("Invalid Key");			/*SysBeep(5);*/			displaymode = 0;			return;		}		if(dumphw_cshift)		{				dumphw_byte++;				dumphw_cshift = 0;		}		else		{			if(++dumphw_cbyte == 16)			{				dumphw_byte = 1;				dumphw_cbyte = 0;				dumphw_cline += 16;			}			else			{				dumphw_byte += 2;			}			dumphw_cshift = 4;		}			}	update_memdisplay(NOTREG);	displaymode = 0;}void dumphw_undo_keypress(	/*Handle Undo's*/	void){}void update_hexmem_window(	/*Called in response to an update event*/	void){char 	buff[68]; /*48 for printing 16 hex numbers , 17 for 16 chars*/long 	i;long	j;long	c;RgnHandle	hold_h;short	w;register short 	 cw ;register address lbase;register short line_size = dumphWindow.lsize;register short v = line_size + line_size;register short column1;long		k;Rect 	r,	l;char 	box[16];GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long		hold_saw_watch_point = saw_watch_point;	if( ((WindowPeek) (dumphWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(dumphWindow.windowptr);		exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;		cw = CharWidth('0');	column1 = cw * 8 + 4;		hold_h = NewRgn();	GetClip(hold_h);	ClipRect(&dumphWindow.usable);	PenNormal();	MoveTo(column1 + cw ,line_size - dumphWindow.forigin);	DrawString((void *)"\p 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F");	MoveTo(4 ,line_size - 1);	w =  cw * 56 ;	PenSize(1,2);	Line(w,0);	PenNormal();	lbase = dumphWindow.theOrigin.v << 4;	dumphWindow.mbase = lbase;	r = dumphWindow.usable;	r.right = column1;	ClipRect(&r);	for(i = 0; i <= dumphWindow.nlines; i++)	{		if(lbase  > last_lbase_h )		{			lbase = first_stackaddress_h + (lbase - last_lbase_h - 16);			/*lbase = ( first_stackaddress_h & 0xF ) + (lbase - (last_lbase_h & 0xF ) );*/			for(;i <= dumphWindow.nlines; i++)			{				if(IPR(MME) == 0 || lbase > last_sysbase_h)				{					l.top 	 = 	v - line_size + dumphWindow.forigin;					l.bottom = 	dumphWindow.usable.bottom;					l.right  = 	column1;					l.left   = 	0;					EraseRect(&l);					break;				}				else				{					sprintf(buff,"%8.8x",lbase);					MoveTo(4, v);					DrawText(buff,(short)0,(short)8);					v += line_size;					lbase += 16;				}			}			break;		}		else		{			sprintf(buff,"%8.8x",lbase);			MoveTo(4,v);			DrawText(buff,(short)0,(short)8);			lbase += 16;			v += line_size;		}	}	lbase = dumphWindow.mbase;	v = line_size + line_size;	r.right = dumphWindow.usable.right;	r.left = column1 + 2;	ClipRect(&r);		for(i = 0; i <= dumphWindow.nlines; i++)	{		if(lbase  >= last_lbase_h )		{			if(lbase  == last_lbase_h)			{				l.right = dumphWindow.usable.right;				l.left = column1;				l.bottom = v + dumphWindow.forigin;				l.top = l.bottom - line_size - 1;				EraseRect(&l);				PenSize(1,2);				MoveTo(column1, v  - (line_size/2));				Line(cw * (ASCII_END + 1),0);				v += line_size;				lbase = first_stackaddress_h;				i++;			}			else				lbase = first_stackaddress_h + (lbase - last_lbase_h - 16);				/*lbase = (first_stackaddress_h & 0xF) + (lbase - (last_lbase_h & 0xF));*/			for(; i <= dumphWindow.nlines; i++)			{				if(IPR(MME) == 0 || lbase >= last_sysbase_h)				{					l.top 		= v - line_size + dumphWindow.forigin;					l.bottom 	= dumphWindow.usable.bottom;					l.left 		= column1;					l.right 	= dumphWindow.usable.right;					EraseRect(&l);					break;				}				else				{					for(j = 0,k = 0; j < 16; j++, k += 3)					{	saw_watch_point = 0;						c = ((long) vax_fetchb(lbase + j)) & BYTE_MASK;						sprintf(&buff[k]," %2.2X", c );						buff[j+ASCII_START] = (c < 0x7f && c > 0x1F) ? c:0xff;						box[j] = saw_watch_point;					}					buff[ASCII_START-1] = ' ';					MoveTo(column1, v);					DrawText(buff,(short)0,(short)ASCII_END + 1);					if(lbase == dumphw_cline)						draw_h_cursor(v);					draw_h_watches(box,v);					lbase += 16;					v += line_size;				}			}			break;		}		else		{			for(j = 0,k = 0; j < 16; j++, k += 3)			{	saw_watch_point = 0;				sprintf(&buff[k]," %2.2X", c = (((long) vax_fetchb(lbase + j)) & BYTE_MASK));				buff[j+ASCII_START] = (c < 0x7f && c > 0x1F) ? c:0xff;				box[j] = saw_watch_point;			}			buff[ASCII_START-1] = ' ';			MoveTo(column1, v);			DrawText(buff,(short)0,(short)ASCII_END + 1);			if(lbase == dumphw_cline)				draw_h_cursor(v);			draw_h_watches(box,v);			lbase += 16;			v += line_size;		}	}	SetClip(hold_h);	MoveTo(column1 ,0);	PenSize(2,1);	Line(0,dumphWindow.usable.bottom);	PenNormal();	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void activate_hexmem_window(	/*Called in response to an activate event*/	long is_active){	if(is_active)	{		EnableItem(MyMenus[optionMenu], DisplayHexCommand);		EnableItem(MyMenus[optionMenu], DisplaydecCommand);	}	else	{		DisableItem(MyMenus[optionMenu], DisplayHexCommand);		DisableItem(MyMenus[optionMenu], DisplaydecCommand);	}}