#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include 	<memory.h>//#include 	<OSEvents.h>#include	<Files.h>#include	<Strings.h>#include	<String.h>#include	<StdLib.h>#define __MAIN_C_#include	"main.h"#include 	"window.h"#include 	"defines.h"#include    "globals.h"#include 	"mmemory.h"#include 	"hexdump.h"#include 	"decdump.h"#include 	"lmem.h"#include 	"regw.h"#include	 "iow.h"#include 	"progw.h"#include 	"controldef.h"#include 	"gotod.h"#include 	"startup.h"#include 	"docmds.h"#include	"instrs.h"#include	"settings.h"#include	"process.h"//extern _DataInit();long main(void){unsigned 	long 		time;#ifdef TEST_FLOAT_CODE	int i;	extern extended flt_imm[64];#endif	/*	 * Initialization traps	 *///	UnloadSeg(_DataInit);	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	appl_fd = CurResFile();	GetVol((void *)0L,&appl_vrefnum); 	setupMenus();			/* Local procedure, below */	setupwindows();	setupioptab();	UnloadSeg(setupMenus);	init_vax_memory();	init_proc_tab();	#ifdef C68K	if(process_finder_info() <= 0)		freeallmem(1); 	/* Vax INIT. If process_finder_info() returns */						/* a 1 then this is done via runreset*/#else	freeallmem(1); 	/* Vax INIT. */	init_AE();#endif	run_wbtoggleREAD();		/* Start with Read and Write watchpoints enabled*/	run_wbtoggleWRITE();		/* Start with Read and Write watchpoints enabled*/		(void) ReadDateTime (&time) ;	qd.randSeed = (long) time;	#ifdef TEST_FLOAT_CODE	for(i = 0; i < 64; i++)		iow_printf("%d %e\n", i, flt_imm[i]);#endif	for ( ;; )	{		(void) event_loop();	}/*endfor Main Event loop*/	cleanup();				return 0;/* Return from main() to allow C runtime cleanup */}/* * Set the segment to Initialize.  BEWARE: leading and trailing white space * would be part of the segment name! */#pragma segment Initialize/* * Set up the Apple, File, and Edit menus. * If the MENU resources are missing, we die. */void setupMenus(void){long i;	/*	 * Set up the desk accessories menu.	 * The "About Sample..." item, followed by a grey line,	 * is presumed to be already in the resource.  We then	 * append the desk accessory names from the 'DRVR' resources.	 */	MyMenus[appleMenu] = GetMenu(appleMenuid);	AddResMenu(MyMenus[appleMenu], (ResType) 'DRVR');	InsertMenu(MyMenus[appleMenu],0);	for(i = 1; i < menuCount; i++)	{		MyMenus[i] = GetMenu(menuids[i]);		InsertMenu(MyMenus[i],0);	}	DrawMenuBar();}#pragma segment Version#include	<types.h>#include	<quickdraw.h>#include	<dialogs.h>/* * Display the About dialog. * Then wait for a click before returning. */void showAboutMeDialog(void){	GrafPtr 	savePort;	DialogPtr	theDialog;	short		itemHit;	char 		*version = (char *)"\p?";	Handle		versionH;	GetPort(&savePort);	if((versionH = GetResource('VSIM',(short)0)) != (Handle)0)	{		HLock(versionH);		version = (char *) *versionH;	}	ParamText((void *)version,(void *)"",(void *)"",(void *)"");	theDialog = GetNewDialog(aboutMeDLOG, nil, (WindowPtr) -1);	SetPort(theDialog);	do {		ModalDialog(nil, &itemHit);	} while (itemHit == 0);	CloseDialog(theDialog);	if(versionH != (Handle)0)	{		HUnlock(versionH);		ReleaseResource(versionH);	}	SetPort(savePort);	return;}/* * Back to the Main segment. */#pragma segment MENUSvoid appleDA (	long theItem){	Str255				daName;	GrafPtr 			savePort;	GetItem(MyMenus[appleMenu], theItem, daName);				GetPort(&savePort);				(void) OpenDeskAcc(daName);				SetPort(savePort);}void Transfer(	long theItem){Str255 ItemString;Handle strH;char *strHp;short strH_id = 1000 + theItem;unsigned long strH_len;long i;short cur_res_fd; /*temp to hold the current resource file fd*/	cleanup();	/*closes all open files etc*/	GetItem(MyMenus[TransferMenu], theItem, ItemString);	p2cstr(ItemString);	if(strcmp("Other",(char *)ItemString) == 0)		exec_other(0); /*launch what ever they select*/	else /*exec the item in the str 1000 + theItem*/	{		cur_res_fd = CurResFile();		UseResFile(appl_fd);		strH = Get1Resource ('STR ', strH_id);		UseResFile(cur_res_fd);		if( strH == 0 )			exec_other(strH_id); /*can't find the resource so create and launch it*/		else		{				HLock((Handle) strH);			strH_len = ** (unsigned char **) strH;			strHp = (* (char **) strH) + 1;			for(i = 0; i < strH_len; i++)				ItemString[i] = * strHp++;			ItemString[i] = 0;			exec_it((char *)ItemString,0,strH_id); /*launch it*/			/*The following will not happen unless we fail to launch*/			HUnlock((Handle) strH); 			ReleaseResource((Handle) strH); /*Throw away string*/			/*?DisposHandle((Handle)strH); /*release the handle*/		}	}}/* * Process mouse clicks in menu bar */void doCommand(	long	mResult,	long opt_key_down){long 				theMenu, theItem;long windownum;OurWindowPtr wp;FontInfo finfo;	theItem = LOWORD(mResult);	theMenu = HIWORD(mResult) - appleMenuid;		/* resource ID - 128 -> menunumber*/	switch (theMenu) {		case appleMenu:			if (theItem == aboutMeCommand)				showAboutMeDialog();			else appleDA (theItem);			break;		case fileMenu:			switch (theItem) {				case openCommand:	/*New Process*/					file_open();					break;				case closeCommand:	/*Close Process*/					file_close();					break;				case InitCommand:	/*Clean up every thing and start again*/					terminate_all_processes();					put_PC_in_progwindow();					clear_all_windows();					break;				case bootCommand:	/*Boot a system*/					boot();					break;				case binCommand:	/*load some binary code into location 0*/					binload();					break;				case shutdownCommand: /*tell the System to pack it in*/					shutdown();					break;				case saveIO:					file_save();					break;				case savestatecommand:					savestate(opt_key_down);					break;				case restorestatecommand:					restorestate(0);					break;				case quitCommand:					quit();					break;				default:					break;			}			break;		case editMenu:			/*			 * If this is for a 'standard' edit item,			 * run it through SystemEdit first.			 * SystemEdit will return FALSE if it's not a system window.			 */			if ((theItem <= pasteCommand) && SystemEdit(theItem-1)) {				break;			}			/*			 * Otherwise, it's my window.			 * Handle Cut/Copy/Paste properly			 * between the TEScrap and the Clipboard.			 */			switch (theItem) {				case undoCommand:					/* can't undo */					break;				case cutCommand:					if(ioWindow.windowptr == theActiveWindow)						iow_cut();					break;								case copyCommand:					if(ioWindow.windowptr == theActiveWindow)						iow_copy();					break;				case pasteCommand:					/*TEFromScrap();*/					/*TEPaste(TextH);*/					break;				default:					break;			} /*endsw theItem*/			break;		case runMenu:			switch (theItem)			{				case resetCommand:					run_reset();					break;				case goCommand:					run_go();					break;				case stepstepCommand:					run_stepstep();					break;				case stepCommand:					run_step();					break; 				case PauseCommand:					stop = 1; /*never called by main*/					break;				case watchCommand:					run_watch_for_access_toggle();					break;				case ClearAllWatchCommand:					clear_all_watch_points();					break;				case STOPonREADcommand:					run_wbtoggleREAD();					break;				case STOPonWRITEcommand:					run_wbtoggleWRITE();					break;				case display_sizes:					display_memory_usage();					break;				default:					break;			}			break;		case windowsMenu:			switch (theItem)			{			case programCommand:			case registersCommand:			case lmemoryCommand:			case ioCommand:				if(window[theItem-programCommand].secure == 1)                    break;				ShowHide(window[theItem-programCommand].windowptr,true);				SelectWindow(window[theItem-programCommand].windowptr);				HiliteMenu(0);				return;			case memdumpCommand:				if(hex_mem_dump)				{					if(dumphWindow.secure == 1)                    	break;					ShowWindow(dumphWindow.windowptr);					SelectWindow(dumphWindow.windowptr);				}				else				{					if(dumpdWindow.secure == 1)                   		break;					ShowWindow(dumpdWindow.windowptr);					SelectWindow(dumpdWindow.windowptr);				}				HiliteMenu(0);				return;			case physmemCommand:				if(physmemWindow.secure == 1)                    break;				ShowHide(physmemWindow.windowptr,true);				SelectWindow(physmemWindow.windowptr);				HiliteMenu(0);				return;			case syswCommand:				if(sysWindow.secure == 1)                    break;				ShowHide(sysWindow.windowptr,true);				SelectWindow(sysWindow.windowptr);				HiliteMenu(0);				return;			case stackwCommand:				if(stackWindow.secure == 1)                    break;				ShowHide(stackWindow.windowptr,true);				SelectWindow(stackWindow.windowptr);				HiliteMenu(0);				return;			}			if ((windownum = GetWRefCon(theActiveWindow) - progwID) >= 0 && windownum < NumWindows)			{				wp = &window[windownum];				switch (theItem)				{				case CLEARIOW:					clear_io_window();					break;				case POINT9COMMAND:					TextSize(wp->fsize = 9);					break;				case POINT12COMMAND:					TextSize(wp->fsize = 12);					break;				case POINT14COMMAND:					TextSize(wp->fsize = 14);					break;				case POINT18COMMAND:					TextSize(wp->fsize = 18);					break;				case BOLDCOMMAND:					TextFace(bold);					break;				case PLAINCOMMAND:					TextFace(normal);					break;				case COURIERCOM:					TextFont(courier);					break;				case MONACOCOM:					TextFont(monaco);					break;				default:					HiliteMenu(0);					return;				}				GetFontInfo(&finfo);				wp->forigin = finfo.descent + finfo.leading + 1;				wp->leading = finfo.leading + 1;				wp->lsize = finfo.ascent + wp->forigin;				if(wp->topMargin > 1) /*tempory cludge. fix it sometime.*/					wp->topMargin = wp->lsize;				wp->nlines = (wp->usable.bottom - wp->topMargin) / wp->lsize ; /*calculate num lines*/				EraseRect(&((wp->windowptr)->portRect));				MyDrawGrow(wp);				DrawControls(wp->windowptr);				wp->update_window();			}			break;							case optionMenu:			switch (theItem)			{			case hexaddrCommand:				windows_hexmode();				break;			case symmodeCommand:				windows_symmode();				break;			case DisplayHexCommand:				items_display_mode(HEX_FORMAT);				break;			case DisplaydecCommand:				items_display_mode(DEC_FORMAT);				break;			case DisplayudecCommand:				items_display_mode(UDEC_FORMAT);				break;			case DisplayasciiCommand:				items_display_mode(CHAR_FORMAT);				break;			case DisplayfloatCommand:				items_display_mode(FLOAT_FORMAT);				break;			case IgnoreModeCommand:				windows_ignoreprotectionmode();			}			break;					case ToMenu:			switch (theItem)			{			case TOaddress:				if ((windownum = GetWRefCon(theActiveWindow)) == physmemwID )					goto_address(USE_PHYSMEMW);				else					goto_address(USE_VIRTMEMW);				break;			case CodeStartCommand:				if(current_process)					goto_loc(current_process->entrypt);				break;			case DataStartCommand:				if(current_process)					goto_loc(current_process->txtmap.b2);				break;			case PCCommand:				goto_loc(PC);				break;			case SPCommand:				goto_loc(SP);				break;			case FPCommand:				goto_loc(FP);				break;			case APCommand:				goto_loc(AP);				break;			case USPCommand:				goto_loc(IPR(USP));				break;			case SSPCommand:				goto_loc(IPR(SSP));				break;			case ESPCommand:				goto_loc(IPR(ESP));				break;			case KSPCommand:				goto_loc(IPR(KSP));				break;			case ISPCommand:				goto_loc(IPR(ISP));				break;			case SCBBCommand:				goto_loc(virtual(IPR(SCBB)));				break;			case P0BRCommand:				goto_loc(IPR(P0BR));				break;			case P1BRCommand:				goto_loc(IPR(P1BR)+MAX_PAGE_TABLE_SIZE);				break;			case SBRCommand:				goto_loc(virtual(IPR(SBR)));				break;			case PCBBCommand:				goto_loc(virtual(IPR(PCBB)));				break;			default:					break;			}			break;		case TransferMenu:			Transfer(theItem);			break;					default:			break;					}/*endsw theMenu*/	HiliteMenu(0);	return;}void cleanup(void){	terminate_process();}void quit(void){	cleanup();	exit(0);			/*exit */}