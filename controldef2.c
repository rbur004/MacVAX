#include	<types.h>#include	<quickdraw.h>#include 	<fonts.h>#include	<controls.h>#include	<resources.h>#include	<packages.h>#include 	"controldef.h"pascal longProcessButtonArray(	short varCode,	ControlHandle theControl,	short message,	long param){#pragma unused (varCode)Rect pr; 							/*Picture Rectangle*/Rect cr; 							/*control Rectangle*/Rect dr; 							/*destination rectangle*/RgnHandle rgnH;Point *p;char process_number[16];short hold_txFont;short hold_txSize;static void itoa(register short i, char *p);	if((*theControl)->contrlData == 0) 		(*theControl)->contrlData = GetResource ( 'PICT',(short) PROCESS_BUTTON_ARRAY_RID );	pr = ( ( (PicPtr)( *( (*theControl)->contrlData ) ) )->picFrame );	cr = (*theControl)->contrlRect;	dr = cr;		/*zero origin of picture rectangle*/	pr.right -= pr.left;	pr.bottom -= pr.top;	pr.left = 0;	pr.top = 0;		/*calculate destination rectangle*/	dr.left = dr.right - pr.right;				switch(message)	{	case drawCntl:		if((*theControl)->contrlVis)		{			rgnH = NewRgn();			GetClip(rgnH);			ClipRect(&cr);			if((*theControl)->contrlHilite < 254 || (*theControl)->contrlHilite == 255)			{				switch(param & 0xFFFF)				{				case inPrevProcess:				case inProcessnum:				case inNextProcess:				case inAutoProcess:				case 129:				case 0: /*draw all of control*/				default:					DrawPicture((PicHandle)((*theControl)->contrlData), &dr );					itoa((*theControl)->contrlValue & 0x7f, process_number);					MoveTo(dr.left + (short)(inProcessnum - pba1_base) * (short)15 + 2, dr.top + 11);					hold_txFont = (*theControl)->contrlOwner->txFont;					hold_txSize = (*theControl)->contrlOwner->txSize;					TextFont(geneva);					TextSize(9);					DrawString(process_number);					TextFont(hold_txFont);					TextSize(hold_txSize);					break;				}				switch((*theControl)->contrlHilite)				{				case inPrevProcess:				case inProcessnum:				case inNextProcess:				case inAutoProcess:					dr.left += (short)((*theControl)->contrlHilite - pba1_base) * (short)15;					dr.right = dr.left + 15;					dr.top += 1;					InvertRect(&dr);					break;				case 129: /*thumb*/				case 0: /*No Highlight*/				default:					break;				}								dr = cr;				dr.left = dr.right - pr.right;				dr.top += 1;						if((*theControl)->contrlValue & 0x80)				{					dr.left += (short)(inAutoProcess - pba1_base) * (short)15;					dr.right = dr.left + 15;					InvertRect(&dr);				}							}			else			{				EraseRect(&dr);				FrameRect(&dr);			}			SetClip(rgnH);			DisposeRgn(rgnH);		}						return 0;		case testCntl: /*which part of control*/		if((*theControl)->contrlVis)		{			p = (Point *) &param;			if(PtInRect(*p, &dr))				return ((short)(p->h - dr.left) / (short)15) + pba1_base;		}		return 0;		case calcCRgns: /*returns region occupied by Control 24 bit call only*/		/*param is a region handle */		/*Param hit bit set means indicator only*/		param &= 0x00FFFFFF; /*needed for 24bit mode. One tech note suggests using 7FFFFFFF*/		/*	Debugger(); */	case calcThumbRgn: /*returns region occupied by Control 32 bit call*/	case calcCntlRgn: /*returns region occupied by Control 32 bit call*/		if(dr.right > cr.right)			dr.right = cr.right;		if(dr.bottom > cr.bottom)			dr.bottom = cr.bottom;		RectRgn((RgnHandle) param,&dr);		return 0;		case initCntl: /*Initialize control*/		/*(*theControl)->contrlData = GetResource ( 'PICT',(short) PROCESS_BUTTON_ARRAY_RID );*/		(*theControl)->contrlValue = 0x80;		return 0;		case dispCntl: /*release any private memory*/		if((*theControl)->contrlData != 0) 			ReleaseResource((*theControl)->contrlData);		return 0;		case posCntl: /*shift indicator*/		return 0;		case thumbCntl: /*calc slop and limiting rects*/		return 0;		case dragCntl: /*drag indicator or whole control*/		return 0;		case autoTrack: /*track control function*/		/* must do param &= 0xFFFF; if using param*/		return 0;		default:		return 0;	}	}static void itoa(register short i, char *p){/* This assumes the number will be between 0 and 99 *//* Output will be of the form "\2 0" to "\299"      */register short j;	*p++ = 2;	j = i/10;	if( j == 0)		*p++ = ' ';	else		*p++ = j + '0';	*p++ = (i - j * 10) + '0';	*p = '\0';}