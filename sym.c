/******************************************************************************//*                                                                            *//*                       S Y M B O L     R E A D I N G                        *//*                                                                            *//******************************************************************************/#include	<string.h>#define _SYM_C_#include		"symbol_tab.h"#include		"sym.h"#include 		"globals.h"#include		"mmemory.h"#include		"lmem.h"#include		"wprintf.h"#pragma segment SYMBOL_TABLE#ifdef OLDER/*Search for symbol table entry by brute forse method*/long printlabel(	unsigned long location){long        namelen;STRING      name;SYMTAB  	*symptr;long		printed = 0;Symbol_Table_Type *st;    Procentry = FALSE;	DotWord = FALSE;	if(location >= S_SPACE)		st = sys_process;	else		st = current_process;		    if ( st && (symptr = st->symvec))	{		for ( ; symptr < st->symvec + st->symnum; symptr++ )		{			if ( symptr->n_value == location && (symptr->n_type&N_TYPE)  == ISYM)			{				if ( ((symptr->n_other >> 3) & 0x1f) == IENTER ) 				   Procentry = TRUE;				if ( location < st->txtmap.e1				&&   location > st->txtmap.b1				&& ((symptr->n_other >> 3) & 0x1f) == IWORD ) 				   DotWord = TRUE;				   				namelen = strlen( name = symptr->n_un.n_name );				if (name != NIL_STRING && !( namelen >= 2					&& name[ namelen-1 ] == 'o'					&& name[ namelen-2 ] == '.' )) /*ie not a file name*/				{					if( symmode )					{						wprintf( "%s: ", name );						printed = 1;					}				}			}		}	}	return printed;}#else OLDER/*Search for label using binary search*/long printlabel(	unsigned long location){long        namelen;STRING      name;SYMTAB  	*symptr;long		printed = 0;Symbol_Table_Type *st;long hi,lo,i;	/*bin search temps*/    Procentry = FALSE;	DotWord = FALSE;	if(location >= S_SPACE)		st = sys_process;	else		st = current_process;		    if ( st && st->symvec)	{		lo = 0;		hi = st->symnum - 1;		symptr = st->symvec;		for(;hi >= lo;)		{			i = (lo + hi) / 2;					if(symptr[i].n_value == location)			{   /*found one*/				/*now look for the first one*/				while(i > 0 && symptr[i-1].n_value == location) i--;				/* Now print all symbols with this address   */				/* Also check for procedure entry and .words */				do				{					if ( (symptr[i].n_type & N_TYPE)  == ISYM)					{						if ( ((symptr[i].n_other >> 3) & 0x1f) == IENTER ) 		 		   			Procentry = TRUE;						if ( ((symptr[i].n_other >> 3) & 0x1f) == IWORD ) 		 		   			DotWord = TRUE;				   	   		 			namelen = strlen( name = symptr[i].n_un.n_name );	    				if ( symmode						&& name != NIL_STRING 						&& !( namelen >= 2						   && name[ namelen-1 ] == 'o'						   && name[ namelen-2 ] == '.' )) /*ie not a file name*/						{							wprintf( "%s: ", name );							printed = 1;						}	    			}					i++;				}while(i < st->symnum && symptr[i].n_value == location);				break;	/*exit for loop*/			}						else if(location > symptr[i].n_value)				lo = i + 1;						else /*if(location < symptr[i].n_value)*/				hi = i - 1;		}				}	return printed;}#endifvoid psymoff(	unsigned long v){unsigned long w;SYMTAB	 *symbol_table_p;	w = findsym(v, &symbol_table_p);    if ( w >= MAXOFF || !symmode || symbol_table_p == 0)		if(hexmode)			printhex( v );		else			printdec( v );    else	{		wprintf( "%s", symbol_table_p->n_un.n_name );		if ( w )	    	IGNORE wprintf(hexmode ? "+0x%x":"+%u", w );	}}#ifdef OLDER/*find a symbol using brute forse search*/unsigned long findsym(	unsigned long location,	SYMTAB	 **symbol_table_h){long     diff;long      namelen;STRING   name;SYMTAB   *symptr;short type;Symbol_Table_Type *st;unsigned long symval;    diff = 0x7fffffffL;    *symbol_table_h = 0;	if(location >= S_SPACE)		st = sys_process;	else		st = current_process;		    if ( st && (symptr = st->symvec))	{		for ( ; symptr < st->symvec + st->symnum; symptr++ )		{			type = symptr->n_type & N_TYPE;			if(type != ISYM && type != N_BSS && type != DSYM)				continue; /*only want data and code symbols*/			if ( ( name = symptr->n_un.n_name ) == NIL_STRING )				continue;			if ( ( namelen = strlen( name ) ) >= 2				&& name[ namelen-1 ] == 'o'				&& name[ namelen-2 ] == '.' )				continue;			symval = symptr->n_value;			if ( location - symval < diff && location >= symval )			{				*symbol_table_h = symptr;				if ( ( diff = location - symval ) == 0 )					break;			}		}				}    return diff;}#else OLDER/*search for symbol using binary search*/unsigned long findsym(	unsigned long location,	SYMTAB	 **symbol_table_h){long      namelen;STRING   name;SYMTAB   *symptr;short type;Symbol_Table_Type *st;long hi,lo,i;	/*bin search temps*/unsigned long here;    *symbol_table_h = 0;	if(location >= S_SPACE)		st = sys_process;	else		st = current_process;		    if ( st && st->symvec)	{		lo = 0;		hi = st->symnum - 1;		symptr = st->symvec;		for(;;)		{			i = (lo + hi) / 2;						if(hi < lo || symptr[i].n_value == location)			{ 	/*found one or failed*/				if(hi < lo)					i = hi;	/*In case of failure we still want the previous symbol*/								if(i < 0)					break;  /*there might not be a previous symbol*/								hi = st->symnum - 1;	    /*end of the symbol table*/				here = symptr[i].n_value;	/*this might not be the location we are after*/								/*search forward until we are at the last symbol table entry*/				/*with this address, Or we hit the end of the symbol table*/				while(i < hi && symptr[i+1].n_value == here) i++;								do				{					/*only want data and code symbols and not .o names*/					type = symptr[i].n_type & N_TYPE;					if( (type == ISYM  || type == N_BSS || type == DSYM  )					&&  ( ( name = symptr[i].n_un.n_name ) != NIL_STRING )					&&  ! ( ( namelen = strlen( name ) ) >= 2						   && name[ namelen-1 ] == 'o'						   && name[ namelen-2 ] == '.'  ) )					{						*symbol_table_h = &symptr[i];						return location - symptr[i].n_value;					}					i--;				}while(i >= 0);   				return 0xffffffffu; /*failed to find any symbol*/			}			else if(location > symptr[i].n_value )				lo = i+1;			else /* if(location < symptr[i].n_value) */				hi = i-1;		}				}    return 0xffffffffu;	/*failed to find any symbol, No symbol table to look in.*/}#endiflong findsymbyname(	char *name,	long system	/*if system == 1 then use system symbol table*/){SYMTAB   *symptr;short type;Symbol_Table_Type *st;	if(system)		st = sys_process;	else		st = current_process;		    if ( st && (symptr = st->symvec) && *name != '\0') //Yes 1 ='s	{		for (; symptr < st->symvec + st->symnum; symptr++ )		{			type = symptr->n_type & N_TYPE;			if((type == ISYM || type == N_BSS || type == DSYM)			&& strcmp( name , symptr->n_un.n_name ) == 0)				return(symptr->n_value);		}	}    return -1;}