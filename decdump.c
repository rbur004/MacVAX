#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<StdIO.h>#define __DECDUMP_C_#include "window.h"#include "main.h"#include "decdump.h"#include "hexdump.h"#include "mmemory.h"#include "docmds.h"#pragma segment DECWINDOWstatic putdnible(	long n){long b;	last_byte = b = (long)vax_fetchb((dumpdw_cline + dumpdw_cbyte)) & BYTE_MASK;	if((b = (b - (((b / dumpdw_cshift) % 10) * dumpdw_cshift)) + (n * dumpdw_cshift)) <= 255)	{		vax_putb(b, dumpdw_cline + dumpdw_cbyte) ;		return(0);	}	else	{		SysBeep(5);		return(-1);	}}void dumpdw_goto(	/*Shifts window origin so the address 'a' is visible*/	register address a){register address lbase;register address new_cline;	lbase = a / (unsigned long)10;	new_cline = lbase * (unsigned long)10;	if(new_cline <= last_lbase_d)			dumpdWindow.theOrigin.v = lbase;	else if(new_cline >= first_stackaddress_d && new_cline <= last_sysbase_d)			dumpdWindow.theOrigin.v = lbase - (first_stackaddress_d / 10) + ((unsigned long)last_lbase_d/10);	else	{		SysBeep(5);		return;	}	SetCtlValue(dumpdWindow.vScroll, dumpdWindow.theOrigin.v);	dumpdw_cline = new_cline;	dumpdw_cbyte = a - new_cline;	if(in_ascii)	{		dumpdw_byte = dumpdw_cbyte + ASCII_START;		dumpdw_cshift = 0;	}	else	{		dumpdw_byte = (dumpdw_cbyte * 4) + 1;		dumpdw_cshift = 100;	}}void dumpdw_click(	/*Handle clicks in the window*/	Point *p,	short modifiers){#pragma unused(modifiers)register short cw = CharWidth('0');register short column1 = COLUMN1;register short line_size =  dumpdWindow.lsize;long i;	if( p->h > column1 && p->v > line_size)	{		dumpdw_cline = dumpdWindow.mbase + (p->v  / line_size) * 10 - 10 ;		if(dumpdw_cline > (last_lbase_d/10)*10)			dumpdw_cline = (first_stackaddress_d/10)*10 + (dumpdw_cline - (last_lbase_d/10)*10);		dumpdw_byte = (p->h - column1) / cw ;		in_ascii = (dumpdw_byte >= ASCII_START && dumpdw_byte <= ASCII_END);		if( dumpdw_byte <= ASCII_END && ((i = dumpdw_byte % 4) || in_ascii )) //Yes 1 ='s		{	/*valid click*/			if(in_ascii)			{				dumpdw_cbyte = dumpdw_byte - ASCII_START;				dumpdw_cshift = 0;			}			else			{				dumpdw_cbyte = ((dumpdw_byte - dumpdw_byte / 4) - 1) / 3;				if(i == 1)					dumpdw_cshift = 100;				else if ( i == 2)					dumpdw_cshift = 10;				else					dumpdw_cshift = 1;			}		}		else			dumpdw_cline = -1;		update_decmem_window();		last_byte = -1;		return;	}}static void draw_d_cursor(	/*Draws the cursor*/	short v){register long	cw = CharWidth('0');register short 	column1 = COLUMN1;register short 	line_size =  dumpdWindow.lsize;Rect dumpdw_r;	if(dumpdw_cline == -1)		return;	dumpdw_r.left = (dumpdw_byte * cw) + column1 ;	dumpdw_r.right = dumpdw_r.left + cw;	dumpdw_r.bottom = v + dumpdWindow.forigin;				dumpdw_r.top	= dumpdw_r.bottom - line_size;	dumpdw_r.bottom -= dumpdWindow.leading;	InvertRect(&dumpdw_r);}static void draw_d_watches(	/*Draws the watch point boxes*/	char *box,	short v){register long	i;register long	cw = CharWidth('0');register short	line_size =  dumpdWindow.lsize;Rect dumpdw_r;	for(i = 1; i < ASCII_START; i += 4)	{		if(*box++)		{			dumpdw_r.left = (i * cw) + COLUMN1 - 1;			dumpdw_r.right = dumpdw_r.left + cw + cw + cw + 2;			dumpdw_r.bottom = v + dumpdWindow.forigin;						dumpdw_r.top	= dumpdw_r.bottom - line_size;			dumpdw_r.bottom -= dumpdWindow.leading;			FrameRect(&dumpdw_r);		}	}}address get_c_pos_d(	/* Return address of the cursor */	/* returns ERROR if cursor == nil  */	void){address loc;	if(dumpdw_cline == -1)		return ERROR;	else	{		loc = (address) (dumpdw_cline + dumpdw_cbyte);		if(dumpdw_cline < last_lbase_d)			return loc;		else if((unsigned long) dumpdw_cline < last_sysbase_d)			return loc;		else			return ERROR; /*Should never be the case*/	}}void dumpdw_keypress(	/*Handles keypresses*/	long key){	if(dumpdw_cline == -1)		return;	if(ignore_mode == 1)		displaymode = 1;	/*move screen if not displayed*/	if(in_ascii)	{		vax_putb((char)( key & BYTE_MASK ),dumpdw_cline + dumpdw_cbyte); 		if(++dumpdw_cbyte == 10)		{			dumpdw_cbyte = 0;			dumpdw_byte = ASCII_START;			dumpdw_cline += 10;		}		else			dumpdw_byte++;	}	else	{		if(key >= '0' && key <= '9' ) 		{			if(putdnible(key - '0'))			{				displaymode = 0;				return;			}		}		else		{			SysBeep(5);			displaymode = 0;			return;		}		if(dumpdw_cshift > 1)		{				dumpdw_byte++;				dumpdw_cshift /= 10;		}		else		{			if(++dumpdw_cbyte == 10)			{				dumpdw_byte = 1;				dumpdw_cbyte = 0;				dumpdw_cline += 10;			}			else			{				dumpdw_byte += 2;			}			dumpdw_cshift = 100;		}	}	update_memdisplay(NOTREG);}void dumpdw_undo_keypress(	/*handles Undo's*/	void){}void update_decmem_window(	/*Handles update events*/	void){char buff[64];/*40 for 10 dec numbers + 11 for 10 ascii chars*/long i;long j;long w;RgnHandle	hold_h;short cw;register short column1;register short line_size =  dumpdWindow.lsize;register short v =  line_size + line_size;register address lbase;long k;Rect r,l;char box[10];long c;GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	if( ((WindowPeek) (dumpdWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(dumpdWindow.windowptr);		exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;		cw = CharWidth('0');	column1 = COLUMN1;		hold_h = NewRgn();	GetClip(hold_h);	ClipRect(&dumpdWindow.usable);	PenNormal();	MoveTo(column1+cw,line_size - dumpdWindow.forigin);	DrawString((void *)"\p  0   1   2   3   4   5   6   7   8   9");	MoveTo(4,line_size - 1);	w = cw * 50;	PenSize(1,2);	Line(w,0);	PenNormal();	lbase = dumpdWindow.mbase = dumpdWindow.theOrigin.v * 10;	r = dumpdWindow.usable;	r.right = column1;	ClipRect(&r);	for(i = 0; i <= dumpdWindow.nlines; i++)	{		if(lbase  > last_lbase_d)		{			for(lbase = (first_stackaddress_d/10)*10 + (lbase - (last_lbase_d/10)*10);i <= dumpdWindow.nlines; i++)			{				if(IPR(MME) == 0 || lbase > last_sysbase_d)				{					l.top = v - line_size + dumpdWindow.forigin;					l.bottom = dumpdWindow.usable.bottom;					l.right = column1;					l.left = 0;					EraseRect(&l);					break;				}				else				{					buff[0] = sprintf(&buff[1],"%10.10u",lbase);					MoveTo(4, v);					DrawString((void *)buff);					v += line_size;					lbase += 10;				}			}			break;		}		else		{			buff[0] = sprintf(&buff[1],"%10.10u",lbase);			MoveTo(4, v);			DrawString((void *)buff);			v += line_size;			lbase += 10;		}	}	r.right = dumpdWindow.usable.right;	r.left = column1 + 2;	ClipRect(&r);	lbase = dumpdWindow.mbase;	v = line_size + line_size;	for(i = 0; i <= dumpdWindow.nlines; i++)	{		if(lbase  >= last_lbase_d )		{			if(lbase  == last_lbase_d )			{				l.right = dumpdWindow.usable.right;				l.left = column1;				l.bottom = v + dumpdWindow.forigin;				l.top = l.bottom - line_size - 1;				EraseRect(&l);				PenSize(1,2);				MoveTo(column1, v - (line_size/2));				Line(cw * (ASCII_END + 1),0);				v += line_size;				lbase += 10;				i++;			}			lbase = (first_stackaddress_d/10)*10 + (lbase - (last_lbase_d/10)*10);			for(; i <= dumpdWindow.nlines; i++)			{				if(IPR(MME) == 0 || lbase >= last_sysbase_d)				{					l.top = v - line_size + dumpdWindow.forigin;					l.bottom = dumpdWindow.usable.bottom;					l.left = column1;					l.right = dumpdWindow.usable.right;					EraseRect(&l);					break;				}				else				{					for(j = 0,k = 0; j < 10; j++, k += 4)					{	saw_watch_point = 0;						sprintf(&buff[k]," %3.3d", c = ((long) vax_fetchb(lbase + j)) & BYTE_MASK);						buff[j+ASCII_START] = (c < 0x7f && c > 0x1F) ? c:0xff;						box[j] = saw_watch_point;					}					buff[ASCII_START-1] = ' ';					MoveTo(column1, v);					DrawText(buff,(short)0,(short)ASCII_END+1);					if(lbase == dumpdw_cline)						draw_d_cursor(v);					draw_d_watches(box,v);					v += line_size;					lbase += 10;				}			}			break;		}		else		{			for(j = 0,k = 0; j < 10; j++, k += 4)			{	saw_watch_point = 0;				sprintf(&buff[k]," %3.3d", c = ((long) vax_fetchb(lbase + j)) & BYTE_MASK);				buff[j+ASCII_START] = (c < 0x7f && c > 0x1F) ? c:0xff;				box[j] = saw_watch_point;			}			buff[ASCII_START-1] = ' ';			MoveTo(column1, v);			DrawText(buff,(short)0,(short)ASCII_END+1);			if(lbase == dumpdw_cline)				draw_d_cursor(v);			draw_d_watches(box,v);			v += line_size;			lbase += 10;		}	}		SetClip(hold_h);	MoveTo(column1,0);	PenSize(2,1);	Line(0,dumpdWindow.usable.bottom);	PenNormal();	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void activate_decmem_window(	/*Handles activate events*/	long is_active){	if(is_active)	{		EnableItem(MyMenus[optionMenu], DisplayHexCommand);		EnableItem(MyMenus[optionMenu], DisplaydecCommand);	}	else	{		DisableItem(MyMenus[optionMenu], DisplayHexCommand);		DisableItem(MyMenus[optionMenu], DisplaydecCommand);	}}