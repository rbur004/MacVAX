#include 	<types.h>#include	<StdLib.h>#include	<string.h>#define _SYMBOL_TAB_C_#include		"a.out.h"#include		"structs.h"#include		"patch_a.out.h"#include 		"symbol_tab.h"#include		"vax_to_68000.h"#include		"window.h"#include		"aprintf.h"#include		"macio.h"#include		"lmem.h"#include		"mmemory.h"#include 		"vaxmacio.h"#include		"progw.h"#include		"display_process.h"#include 		"mmalloc.h"#pragma segment SYMBOL_TABLElong round_it(	long a,	long b){    if(b == 0)	{		aprintf("Internal Error; Round: b == 0");		return 0;	}	return ((a+b-1)/b)*b;}char * my_sbrk(	long incr){char *p;	if(incr == 0)		incr = 1;	p = mcalloc((unsigned long) incr, 1);	if(p == 0)	{		aprintf("my_sbrk:Calloc of %d bytes failed", incr);		return (char *) 0;	}			return(p);}void init_proc_tab(void){long i;	for(i = 0; i < NUMBER_PROGS; i++)	{		process_table[i] = 0;		Process_Control_Block[i] = 0xffffffff;	}	current_process = (Symbol_Table_Type *)0;	IPR(MVPID) = 0;	sys_process = (Symbol_Table_Type *)0;	lmem_nlines();	set_displayed_process_number(IPR(MVPID));}long alloc_proc_table_entry(	long sys_proc)/*Allocates a new process table entry. Used by system XFC SYS_SYMBOL_TABLE and ATTACH_SYMBOL_TABLE*//*Returns an index into the process_table if it suceeds.*//*Returns -1 if out of memory 						 *//*Returns -2 if too many processes for process_table		 */{long i;		if(sys_proc)	{		if(process_table[0])			free_symboltable(0);		if((process_table[0] = (Symbol_Table_Type *) my_sbrk(sizeof(Symbol_Table_Type))) == (Symbol_Table_Type *)0)		{			aprintf("alloc_proc_table_entry1: Unable to allocate space for symbol table record (%d)", sizeof(Symbol_Table_Type));			sys_process = (Symbol_Table_Type *)0;			lmem_nlines();			return -1;		}		sys_process = process_table[0];		lmem_nlines();		process_table[0]->ref_count = 1;		return 0;	}	else	{		for(i = 1; i < NUMBER_PROGS; i++)		{			if(process_table[i] == (Symbol_Table_Type *)  0)			{				if((process_table[i] = (Symbol_Table_Type *) my_sbrk(sizeof(Symbol_Table_Type))) == (Symbol_Table_Type *)0)				{					aprintf("alloc_proc_table_entry2: Unable to allocate space for symbol table record. (%d)", sizeof(Symbol_Table_Type));					return -1;				}				else				{					process_table[i]->ref_count = 1;					return i;				}			}		}		aprintf("alloc_proc_table_entry3: Unable to allocate space for symbol table record.\nToo many processes.");		return -2;	}}long create_symbol_table(	MFILE *fp,	long sys_proc)/*Creates a process table entry, and loads the symbol table*//*returns the process descriptor from alloc_proc_table_entry*/{long process_desc;	if((process_desc = alloc_proc_table_entry(sys_proc)) < 0)		return process_desc;	memcpy(process_table[process_desc]->name, fp->name, 64); /*keep a copy of file name*/	process_table[process_desc]->vrefnum = fp->vrefnum;		   /*keep a copy of vrefnum*/	process_table[process_desc]->fsym = fp; /*Copy file info into symbol table structure*/ 	setsym(process_table[process_desc]);	/*Any errors reported with dialog box*/	return process_desc;	}long duplicate_symbol_table(	long process_desc)/*Creates a process table entry, and loads the symbol table*//*returns the process descriptor from alloc_proc_table_entry*/{long i;	if(process_table[process_desc] == 0 || process_desc == 0)		return -1;	/*can't dup a null entry*/	for(i = 1; i < NUMBER_PROGS; i++)	{		if(process_table[i] == (Symbol_Table_Type *)  0)		{			process_table[i] = process_table[process_desc];			process_table[i]->ref_count++;			return i;		}	}	aprintf("new_proc: Unable to allocate space for symbol table record.\nToo many processes.");	return -2;}long use_user_symbol_table(	long process_desc)/*returns -1 for an invalid descriptor*/{	if(process_desc > 0	&& process_desc <  NUMBER_PROGS )	{		current_process = process_table[process_desc];		IPR(MVPID) = process_desc;		lmem_nlines();		set_displayed_process_number(IPR(MVPID));		return 0;	}	else	{		current_process = (Symbol_Table_Type *) 0;		IPR(MVPID) = 0;		lmem_nlines();		set_displayed_process_number(IPR(MVPID));		return -1;	}}	long free_symboltable(	long process_table_index){Symbol_Table_Type *st;	if(process_table_index >= 0	&& process_table_index <  NUMBER_PROGS 	&& (st = process_table[process_table_index]) )  //Yes 1 ='s	{		Process_Control_Block[process_table_index] = 0xffffffff;		if(--st->ref_count)	/*check for duplicate symbol tables*/		{			process_table[process_table_index] = (Symbol_Table_Type *)0;			return 0;		}		if(st->symvec)		{			mfree((char *)st->symvec);		}		if(st->strtab)		{			mfree((char *)st->strtab);		}		if(st->esymtab)		{			mfree((char *)st->esymtab);		}		if(st->bit_map)		{			mfree((char *)st->bit_map);		}		if( st == current_process )		{			current_process = (Symbol_Table_Type *)0;			IPR(MVPID) = 0;			set_displayed_process_number(IPR(MVPID));			lmem_nlines();		}		else if(process_table_index == 0)		{			sys_process = (Symbol_Table_Type *)0;			lmem_nlines();		}		mfree((char *) st);		process_table[process_table_index] = (Symbol_Table_Type *)0;		return 0;	}	else		return -1;}	void free_all_symboltable(void){long i;	IPR(MVPID) = 0;	current_process = (Symbol_Table_Type *)0;	sys_process = (Symbol_Table_Type *)0;	for(i = 0; i < NUMBER_PROGS; i++)		if( process_table[i] != (Symbol_Table_Type *)0)			free_symboltable(i);	set_displayed_process_number(IPR(MVPID));}long get_mac_filename_pd(	/*copies the MFILE->name and MFILE->vrefnum to VAX memory dest*/	unsigned long process_table_index,	address dest){Symbol_Table_Type *st;long fname_length;	if(process_table_index >= 0	&& process_table_index <  NUMBER_PROGS 	&& (st = process_table[process_table_index]) ) //Yes 1 ='s	{	/*write volume reference number*/		vax_putw(st->vrefnum,dest);		dest += sizeof(short);		/*write file name as pascal string*/		fname_length = strlen(st->name);		vax_putb((char) fname_length,dest++);		copy_to_vaxmem(	dest, st->name, fname_length );		return 0;	}	else	{		return -1;	}}int comp_elements(	const SYMTAB *e1, 	const SYMTAB *e2){	if(e1->n_value < e2->n_value)		return(-1);		if(e1->n_value == e2->n_value)		return(0);	return(1);}long setsym(	Symbol_Table_Type *st){TXTHDR      txthdr;SYMTAB      *symptr;long		symbas;		/* Base of symbol table               */long		strbas;		/* base of string table				  */long         strtabsiz;long i;unsigned long	tsize;		/* total text size */unsigned long origin = 0;		/* where the assembler thinks the prog should be loaded */short version = 100;				/* the version number * 100 */#ifdef hacky_debuggingchar dummy[50];	/* delete this */#endiflong position;	/*Read the a.out file header*/	    if ( mread( st->fsym->fd, ( char * ) &txthdr, TXTHDRSIZ ) != TXTHDRSIZ )    {		aprintf( "Could not read header information of %s", st->name );		return -1;	}	/*Put in 68000 Byte order*/	patch_header(&txthdr);	    st->magic       = txthdr.a_magic;	st->txtsiz      = txthdr.a_text;    st->datsiz      = txthdr.a_data;    st->bsssiz      = txthdr.a_bss;    st->symnum      = txthdr.a_syms/( sizeof ( SYMTAB ) );    st->entrypt     = txthdr.a_entry;#ifdef RELOCATION_INFO_WANTED    trsize      = txthdr.a_trsize;    trnum       = strsize/( sizeof ( RELINFO ) );    drsize      = txthdr.a_drsize;    drnum       = drsize/( sizeof ( RELINFO ) );    relflg      = trsize != 0 || drsize != 0;#endif    symbas      	= N_SYMOFF( txthdr );	strbas			= ( long ) N_STROFF( txthdr );	position = strbas+sizeof(long);	/* default in case there is no symbol table */	    if ( N_BADMAG(txthdr) )    {    		aprintf( "Bad magic number %o ( octal ) in  file", st->magic, st->name );		return -1;	}		/*Note Start addresses and sizes of CODE segment*/    st->txtmap.b1   = 0;					/*memory location to load CODE segment to*/    st->txtmap.e1   = st->txtsiz;			/*size of code segment*/    st->txtmap.f1   = N_TXTOFF( txthdr );	/*offset in file to find code segment*/	/*Note Start addresses and sizes of DATA segment*/    st->txtmap.b2   = ( st->magic == 0410 )		/*Location in memory of beginning of DATA segment*/                    ? round_it( ( long ) st->txtsiz, TXTRNDSIZ )                    : st->txtsiz;    st->txtmap.e2   = st->txtmap.b2 + st->datsiz;		/*size of DATA + CODE  segment*/    st->txtmap.f2   = st->txtmap.f1 + st->txtsiz;		/*Offset in file of DATA */		/*If there is a symbol table load it in*/    if ( st->symnum != 0 ) 	{					st->ndata_items = 0;		/*so far not many*/				/*allocate space for the symbol table*/        if((st->symvec = (SYMTAB *)my_sbrk( (long)(st->symnum + 1) * sizeof(SYMTAB) ) ) == ( SYMTAB * )0)		{			aprintf( "Warning!\nNot enough space for symbols for file %s!", st->name );            st->strtab = NIL_STRING;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;		}				/*Seek the string table offset in the file*/        IGNORE mlseek( st->fsym->fd, strbas, 0 );				/*obtain the string table size*/        if( mread( st->fsym->fd, ( char * ) &strtabsiz, sizeof ( long ) ) != sizeof ( long ))		{			aprintf("Unable to read string table size of file %s", st->name);			return -1;		}        strtabsiz = v2m_long(strtabsiz);	    if ( strtabsiz < 0 )		{            aprintf( "Bad string table size in file %s: %d", st->name, strtabsiz );			mfree((char *) st->symvec);            st->symvec = ( SYMTAB * ) NULL;            st->strtab = NIL_STRING;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;		}				/*Allocate space for the string table*/        if ((st->strtab = my_sbrk( strtabsiz )) == ( char * ) 0 ) 		{            aprintf( "Warning!\n\nNot enough space for string table in file %s!\nRequired %x (%d)\nNumber of Symbols %d", st->name , strtabsiz,strtabsiz,st->symnum);			mfree((char *) st->symvec);            st->symvec = ( SYMTAB * ) NULL;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;        }        else 		{			/* Read in the string table*/            if( mread( st->fsym->fd, ( char * ) st->strtab, strtabsiz - sizeof( long )) != strtabsiz  - sizeof( long ))			{				aprintf("Unable to read stringtable of file %s", st->name);				mfree((char *) st->symvec);				mfree((char *) st->strtab);            	st->symvec = ( SYMTAB * ) NULL;            	st->strtab = NIL_STRING;            	st->esymtab = (extra_symtab_info_type *) 0;            	st->symnum = 0;				return -1;			}						position = mlgetpos( st->fsym->fd );		/* save the position */			/*seek the Symbol table base*/            IGNORE mlseek(st->fsym->fd, ( long ) symbas, 0 );			/*read in the symbol table*/            if( mread( st->fsym->fd, (char *)st->symvec, ( long ) st->symnum*sizeof ( SYMTAB ) ) != ( long ) st->symnum*sizeof ( SYMTAB ))			{				aprintf("Unable to read symbol table of file %s", st->name);				mfree((char *) st->symvec);				mfree((char *) st->strtab);            	st->symvec = ( SYMTAB * ) NULL;            	st->strtab = NIL_STRING;            	st->esymtab = (extra_symtab_info_type *) 0;            	st->symnum = 0;				return -1;			}						/*patch the symbol table for 68000 Byte order and change string table offsets to addresses*/			st->last_symtab_ent = st->symvec + st->symnum;            for ( symptr = st->symvec; symptr < st->last_symtab_ent; symptr++ )			{				patch_nlist(symptr);                if (	symptr->n_un.n_strx == 0					||	symptr->n_un.n_strx > strtabsiz )                    symptr->n_un.n_name = NIL_STRING;                else                    symptr->n_un.n_name = st->strtab + symptr->n_un.n_strx - sizeof ( long );								/*Count the number of DATA items*/				if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA )						st->ndata_items++;										/*Warn about unresolved references.*/				if( (symptr->n_type&N_TYPE) == N_UNDF )					aprintf("WARNING!\n\nUnresolved External Reference: %s in file %s",symptr->n_un.n_name, st->name);            }					}				/*Sort the symbol table in address order.*/		qsort((char *)st->symvec, (size_t)(st->symnum), (size_t)sizeof ( SYMTAB ),							comp_elements);				/*Find the first DATA item*/		st->first_data_ent	= st->last_symtab_ent;	/*assume there are none*/		for ( symptr = st->symvec; symptr < st->last_symtab_ent; symptr++ )		{			if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA )				{	st->first_data_ent	= 	symptr;	/*found the first one*/				break;						/*so exit loop*/			}		}		/* RTB 15/7/93 determine version number and origin */		for ( symptr = st->symvec; symptr < st->last_symtab_ent; symptr++ )		{			if( strcmp(symptr->n_un.n_name,".version")  == 0)				{				version = symptr->n_value;			}			if( strcmp(symptr->n_un.n_name,".orig")  == 0)				{				origin = symptr->n_value;			}		}				st->txtmap.b1   = origin;					/* can now set this up properly*/		st->txtmap.e1 += origin;					/* and add the origin to other crap */		st->txtmap.b2 += origin;		st->txtmap.e2 += origin;/*		aprintf("origin = %x version = %d\n b1 = %x e1 = %x b2 =%x e2 = %x",origin,version,			st->txtmap.b1,			st->txtmap.e1,			st->txtmap.b2,			st->txtmap.e2			);		*/		/*Extract locally added symbol table info for "lmem" window*/		if( (st->esymtab = (extra_symtab_info_type *)my_sbrk( st->ndata_items * sizeof ( extra_symtab_info_type ) ) ) != (extra_symtab_info_type *) 0)		{			for( i = 0, symptr = st->first_data_ent; symptr < st->last_symtab_ent; symptr++ )				if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA)				{				long tnum_lines;				long tnum_items;					st->esymtab[i].line_no = st->ndata_lines;					st->esymtab[i].size    = SIZEOFTYPE(symptr);					st->esymtab[i].type    = TYPE(symptr);					if(st->esymtab[i].type == IASCII || st->esymtab[i].type == IASCIZ)						st->esymtab[i].format = CHAR_FORMAT;					else if (st->esymtab[i].type == IFFLOAT)						st->esymtab[i].format = FLOAT_FORMAT;					else if ( st->esymtab[i].type == ILONG || st->esymtab[i].type == IINT 						   || st->esymtab[i].type == IWORD || st->esymtab[i].type == IBYTE)						st->esymtab[i].format = DEC_FORMAT;					else 						st->esymtab[i].format = HEX_FORMAT;										/*st->esymtab[i].nitemspl = NUM_ITEMS_PL(symptr);*/					/*st->esymtab[i].elines   = NUM_LINES(symptr) + st->ndata_lines - 1;*/					/*st->ndata_lines += NUM_LINES(symptr);*/					/*MPW 3.2 compiler dies when attempting to compile above three lines. Replaced with lines below.*/										tnum_lines              = NUM_LINES(symptr);					tnum_items              = NUM_ITEMS(symptr);					st->esymtab[i].nitemspl = tnum_items/tnum_lines;					st->esymtab[i].elines   = tnum_lines + st->ndata_lines - 1;					st->ndata_lines        += tnum_lines;					i++;				}		}		else		{			aprintf("Warning!\nUnable to allocate space for some symbol table info.\nThe Memory by Label window will not display any data items for this file %s", st->name);			st->ndata_lines = 0;		}    }		/* load in the instruction start bit map */	tsize = st->txtsiz;    if((st->bit_map = my_sbrk( (long)( tsize+7 )>>3) ) == ( char * )0) {		aprintf( "Warning!\nNot enough space for instruction bit map for file", st->name );        st->strtab = NIL_STRING;        st->esymtab = (extra_symtab_info_type *) 0;        st->symnum = 0;		return -1;	}		/* the bit map is tacked on the end of the other data */	/* aprintf("position = %x",position); */    IGNORE mlseek( st->fsym->fd, position, 0 );	if( mread( st->fsym->fd, ( char * ) st->bit_map, ((long)( tsize+7 )>>3)) != ((long)( tsize+7 )>>3))		{			aprintf("Unable to read bit map of file %s. No backwards scrolling", st->name);			mfree((char *) st->symvec);			mfree((char *) st->strtab);			mfree((char *) st->bit_map);           	st->symvec = ( SYMTAB * ) NULL;           	st->strtab = NIL_STRING;           	st->esymtab = (extra_symtab_info_type *) 0;           	st->symnum = 0;			st->bit_map=(char *)0;			return -1;		}#ifdef hacky_debugging	for(i=0;i!=tsize;i++)		dummy[i] = (bit_map[i>>3] & (1 << (i & 0x7)))?'1':'0';	dummy[i]=0;	aprintf("A bit_map %s\nread from file pos for %x\ntsize was %d\n",dummy,position,( tsize+7 )>>3, tsize);#endif	return 0;}