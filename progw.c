#include	<quickdraw.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<memory.h>#define __PROGW_C_#include 	"window.h"#include 	"progw.h"#include 	"mmemory.h"#include 	"printins.h"#include	"execute.h"#include	"sym.h"#include 	"symbol_tab.h"#include	"docmds.h"#include	"wprintf.h"#include 	"display_process.h"/* macro that detects whether an address starts an instruction or not. */#define IN_BITMAP(addr,limit) ((addr) <= (limit))#define INS_START(bmap, addr, base) (bmap[((addr)-(base))>>3] & (1 << (((addr)-(base)) & 0x7)))void progw_click(	Point *p,	short modifiers){address newdot;address to_addr;address tmp_addr;long i;long line;long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;int		exited_on_label = 0;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	if((line = (p->v  / progWindow.lsize)) > 0)		line--;	else	{		stop = hold_stop;	/* RTB 16/7/93 */		exceptions_on = hold_exceptions_on;		saw_watch_point = hold_saw_watch_point;		displaymode = 0;		return;	}	/*loop until The address of the instruction clicked on is found*/	Was_case = 0;	newdot = progWindow.mbase;	for(i = 0; i <  line; i++)	{			if(printlabel(newdot) && ++i == line)		{	wdiscard();			exited_on_label = 1;			break;		}		newdot = printins( newdot );		wdiscard();	}		if(exited_on_label == 0 && printlabel(newdot))	{	wdiscard();		stop = hold_stop;	/* RTB 16/7/93 */		exceptions_on = hold_exceptions_on;		saw_watch_point = hold_saw_watch_point;		displaymode = 0;		return;	}		if( (modifiers & optionKey) && !(modifiers & ~optionKey) )	{		/*update PC*/		PC = newdot;	}	else if((modifiers & (optionKey | shiftKey)) && !(modifiers & ~(optionKey | shiftKey)) )	{		printins( newdot );		wdiscard();		display_comment();	}	else if(modifiers & cmdKey)	{		/*will put follow branch in here*/		printins( newdot );		wdiscard();		if ((modifiers & optionKey) && !( modifiers & ~(optionKey | cmdKey) ) )		{			tmp_addr = progWindow.mbase;			put_at_top_progwindow(last_top_of_progw);			last_top_of_progw = tmp_addr;		}		else if((to_addr = get_branch_dest()) != U_MAX_LONG)		{			draw_pointer_to_address(line,to_addr);			while(Button()) /*Empty*/;			if((modifiers & shiftKey) && !( modifiers & ~(shiftKey | cmdKey)) )			{					last_top_of_progw = progWindow.mbase;				put_at_top_progwindow(to_addr);			}		}	}	else	{		if(progw_selection_point == newdot)			progw_selection_point = -1;		else			progw_selection_point = newdot;	}	update_prog_reg_display();		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}address get_c_pos_prog(	/* Return address of the cursor */	/* returns ERROR if cursor == nil  */	void){	return (address) progw_selection_point;}void progw_keypress(	long key){#pragma unused(key)	SysBeep(5);}void progw_undo_keypress(void){	SysBeep(5);}BitMap  Bfinger;Handle	Hfinger;#define FINGER	256#pragma segment Initializevoid init_finger(void){	Hfinger = (Handle) GetCursor(FINGER)	;	MoveHHi(Hfinger);	HLock(Hfinger);	Bfinger.baseAddr = *Hfinger;	Bfinger.rowBytes = 2;	SetRect(&Bfinger.bounds,0,0,16,16);}#pragma segment Mainvoid put_PC_in_progwindow(void){register address olddot;register long i;register long j = ((progWindow.nlines/2)  + 1);long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	Was_case = 0;	if(PC >= dot || PC < progWindow.mbase)	{			if(new_pc == PC && progWindow.nlines > 2) /*we haven't branched*/		{			if(old_pc < dot && old_pc >= progWindow.mbase)			{				for(i =  0 ; i < j ; i++)				{					olddot = progWindow.mbase;					if( printlabel(olddot) && ++i == j)					{						wdiscard();						break;					}		 			progWindow.mbase += printins( olddot ) - olddot;					wdiscard();				}			}			else				progWindow.mbase = old_pc;		}		else			progWindow.mbase = PC;	}		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}static long last_dot = 0; /*First address of next page*/void update_prog_window(void){long newdot;RgnHandle	hold_h;long i;long j;short header = progWindow.lsize - progWindow.forigin;register short line_size = progWindow.lsize;register short v = line_size + line_size;	register short column1;short column1_5;register short column2;Rect r;		/*general purpose clip rect*/Rect r2;	/*clip rect for address column*/Rect e;Rect e2;Rect progw_cursor_r;Rect rfinger;GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;long	printed;			if( ((WindowPeek) (progWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(progWindow.windowptr);		exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;		column1 = CharWidth('0') * 12 + 5;	column1_5 = column1 + 14;	column2 = column1_5 + CharWidth('0') * 4;		Was_case = 0;	r = progWindow.usable;	hold_h = NewRgn();	GetClip(hold_h);		newdot = progWindow.mbase;	MoveTo(4, header);	r.right = column1  - CharWidth('0');	ClipRect(&r);	DrawString((void *)"\p    Addr");		MoveTo(column1 + CharWidth('0'),header);	ClipRect(&progWindow.usable);	DrawString((void *)"\p    Instruction");		MoveTo(4,line_size - 1);	PenSize(1,2);	Line(progWindow.usable.right,0);		PenSize(2,1);	MoveTo(column1 - CharWidth('0') ,0);	Line(0, progWindow.usable.bottom);		PenNormal();		r.top = line_size + 2;	rfinger.left   = column1;	rfinger.right  = column1 + 14;	rfinger.top    = r.top;	rfinger.bottom = progWindow.usable.bottom;		EraseRect(&rfinger);	/*zap current copy of finger*/		r2.top    = r.top;		/*clip rect for address column*/	r2.bottom = r.bottom;	r2.left   = 3;	r2.right  = column1  - CharWidth('0') - 2;		r.left   = column1;	r.bottom = progWindow.usable.bottom;	r.right  = progWindow.usable.right;		progw_cursor_r.left 	=  3;	/*fixed init part for highlight rect*/	progw_cursor_r.right 	=  r2.right - 2;		e.right = progWindow.usable.right;		e2.left  	= column1_5;	e2.right 	= column2;	for(i = 0, j = progWindow.nlines ; i <= j; i++)	{		dot = newdot;		ClipRect(&r);		MoveTo(column1_5 ,v);				saw_watch_point = 0;				printed = printlabel(dot);		wflush();				if(printed)		{			/*clear to end of line*/			e.left = (qd.thePort)->pnLoc.h;			e.bottom =  v + 3; /*(qd.thePort)->pnLoc.v + progWindow.forigin;*/			e.top = e.bottom - line_size; /*- 1*/			e.bottom -= progWindow.leading;			EraseRect(&e);						/*clear address field*/			progw_cursor_r.bottom 	=  v + 3;						progw_cursor_r.top		=  progw_cursor_r.bottom - line_size;			progw_cursor_r.bottom 	-= progWindow.leading;			ClipRect(&r2);			EraseRect(&progw_cursor_r);			ClipRect(&r);						v += line_size;			i++;		}		/*clear to end of column*/		e2.bottom 	=  v + 3;					e2.top		=  e2.bottom - line_size;		e2.bottom	-= progWindow.leading;		EraseRect(&e2);		if(dot == PC)		{			rfinger.top 	= v - 14;			rfinger.bottom 	= v + 2;						CopyBits( &Bfinger, &(progWindow.windowptr->portBits),					&Bfinger.bounds, &rfinger,srcOr,(RgnHandle)0);/*draw new one*/		} 				MoveTo(column2,v);				newdot = printins( dot );		wflush();				e.left = (qd.thePort)->pnLoc.h;		e.bottom =  v + 3; /*(qd.thePort)->pnLoc.v + progWindow.forigin;*/		e.top = e.bottom - line_size ;/*- 1;*/		e.bottom -= progWindow.leading;		EraseRect(&e);		MoveTo( 1 ,v);		ClipRect(&r2);		wprintf(hexmode ? " 0x%8.8x":" %10.10u",dot);		wflush();				if(dot == progw_selection_point || saw_watch_point)		{			progw_cursor_r.bottom 	=  v + 3;						progw_cursor_r.top		=  progw_cursor_r.bottom - line_size;			progw_cursor_r.bottom 	-= progWindow.leading;			if(dot == progw_selection_point)				InvertRect(&progw_cursor_r);			if(saw_watch_point)				FrameRect(&progw_cursor_r);		}					v += line_size;	}	SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	last_dot = dot;	displaymode = 0;}void activate_prog_window(	long is_active){#pragma unused(is_active)/*	if(is_active)		update_prog_window(); */}static address guess_last_ins(	address base){/*It is assumed that "stop", "exceptions_on" and "saw_watch_point" are	*//*saved and restored by the calling function							*//*Find the largest instruction that terminates on the current address.	*/int  i = 32;address newdot;address nextdot;	if(base == 0)		return base;		do	{		newdot  = base - i;		if((newdot & 0x80000000) && (base & 0x80000000) == 0)			i--; /*wrapped so skip this one*/ 		else		{			if(printlabel(newdot)) /*if we printed a label discard text*/				wdiscard();			nextdot = printins( newdot ); 			wdiscard();			if(nextdot == base)				return newdot;			else				i--;		}	} while( i >= 0);	return base - 1; /*Just guess at one byte to try and restore code sync*/}void progw_scroll(	short dh,	short dv){#pragma unused(dh)address olddot;/* current process == viewed process? */Symbol_Table_Type *st = (Symbol_Table_Type *)0;char *bit_map = 0;	/*zero so we can check if it was set later*/unsigned long base = 0; unsigned long limit = 0; long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	/*Check for virtual memory being on*/	if(IPR(MME) != 0 && progWindow.mbase >= S_SPACE) 		st = sys_process;	else		st = current_process;		/*Check that we have a symbol table*/	if(st != (Symbol_Table_Type *)0)	{		bit_map = st->bit_map;		base = st->txtmap.b1;	/* is this dodgy? */		limit = st->txtmap.e1;	}			/* aprintf("bit map = %x, base = %x dv = %d",bit_map,base,dv); */	Was_case = 0;	if(dv < 0)	{		if(down_a_byte) /*set in ScrollDown()*/		{			down_a_byte = 0;			progWindow.mbase++;		}		else if(down_an_instruction) /*set in ScrollDown()*/		{			down_an_instruction = 0;			olddot = progWindow.mbase;			if(printlabel(olddot))				wdiscard();			progWindow.mbase += printins( olddot ) - olddot;			wdiscard();		}		else /*must be page down*/		{			progWindow.mbase = last_dot;		}					}	else if(dv > 0)	{			if(up_a_byte) /*set in ScrollUp()*/		{			up_a_byte = 0;			if(progWindow.mbase-- == 0)				progWindow.mbase = 0;		}		else if(up_an_instruction) /*set in ScrollUp()*/		{				up_an_instruction = 0;			if (progWindow.mbase > base)			{				if(bit_map != 0 && IN_BITMAP(progWindow.mbase-1,limit)) 				{ /*have a bitmap and within limit*/				address new_dot = progWindow.mbase-1;										/*Calculate Previous Instruction*/					for( ; new_dot != base; new_dot--)						if (INS_START(bit_map, new_dot, base)) 							break;					progWindow.mbase = new_dot;				}				else /*No bitmap info for this region. Guess at previous instruction*/					progWindow.mbase = guess_last_ins(progWindow.mbase);			}			else /*No bitmap as we are before the bitmap. Guess at previous instruction*/				 /*should check to see if we need to change st*/				progWindow.mbase = guess_last_ins(progWindow.mbase);		}		else /*must be page scroll up*/		{	/*we get an error here because labels take up a line but this */			/*code doesn't take this into account*/			/* aprintf("bit map = %x, base = %x mbase = %x",bit_map,base,progWindow.mbase); */			if (progWindow.mbase > base)			{				if(bit_map != 0) 				{				/* Calculate one page back */				/* go up an instruction nline times */				address new_dot = progWindow.mbase;				int nln;															for(nln = 0; nln < progWindow.nlines && new_dot > base; nln++) 					{						/* find the start of an instruction */						if( IN_BITMAP(new_dot - 1,limit) )							while (--new_dot != base && !INS_START(bit_map, new_dot, base)) /*EMPTY*/;						else /*outside limit so guess at last instruction*/							new_dot = guess_last_ins(new_dot);						if(printlabel(new_dot)) /*check for a label line*/						{	wdiscard();							nln++;						}					}									progWindow.mbase = new_dot;				}				else /*guess at previous instructions*/				{				/* Calculate one page back */				/* go up an instruction nline times */				address new_dot;				int nln;															for(nln = 0; nln != progWindow.nlines; nln++) 						if((new_dot = guess_last_ins(progWindow.mbase)) == progWindow.mbase)							break; /*didn't move*/						else							progWindow.mbase = new_dot;				}								}		}	}	update_prog_reg_display();	SetCtlValue(progWindow.vScroll,1);	progWindow.theOrigin.v = 1;			stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void draw_pointer_to_address(	short from, /*line*/	address to /*line*/){address tmpdot;long i;short top;short bottom;GrafPtr savePort;Rect r;		/*general purpose clip rect*/register short column1;register short line_size = progWindow.lsize;RgnHandle	hold_h;long	hold_stop = stop;	/* RTB 16/7/93 */long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	exceptions_on = 0;	stop = 1;	if(ignore_mode == 1)		displaymode = 1;	if( ((WindowPeek) (progWindow.windowptr))->visible == false )		return;	hold_h = NewRgn();	GetClip(hold_h);	GetPort(&savePort);	SetPort(progWindow.windowptr);		r = progWindow.usable;	r.top = line_size + 2;		column1 = CharWidth('0') * 12 + 5;		top = (line_size * from) + line_size / 2 + r.top; /*halfway through line*/		if(to > last_dot) /*draw to end of screen*/		bottom = r.bottom;	else if ( to < progWindow.mbase) /*draw to beginning of screen*/		bottom = r.top;	else /*on screen*/	{		/*loop until The address of the instruction clicked on is found*/		Was_case = 0;		tmpdot = progWindow.mbase;		for(i = 0; tmpdot <  to; i++)		{				if(printlabel(tmpdot))			{					wdiscard();				i++;			}			tmpdot = printins( tmpdot );			wdiscard();		}		bottom = (line_size * i) + line_size/2 + r.top; /*halfway through line*/	}	ClipRect(&r);	PenSize(2,1);	MoveTo(column1 + 4,top);	Line(0, bottom - top);	PenNormal();		SetClip(hold_h);	SetPort(savePort);		stop = hold_stop;	/* RTB 16/7/93 */	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void put_at_top_progwindow(	address b){	Was_case = 0;	progWindow.mbase = b ;	update_prog_reg_display();}void progw_init(void){	SetCtlMax(progWindow.vScroll, 2); 	SetCtlMin(progWindow.vScroll, 0); 	SetCtlValue(progWindow.vScroll,1);	SetCtlMax(progWindow.hScroll, (NUMBER_PROGS - 1) | 0x80); 	SetCtlMin(progWindow.hScroll, 0); 	SetCtlValue(progWindow.hScroll,0x80);	progWindow.theOrigin.v = 1;	progWindow.mbase = 0;	init_display_process();}void dec_process_displayed(void){short i = display_process_id & 0x7f;	while(i-- > 1)		if(process_table[i] != 0)		{			display_process_id = i;			save_display_process_ctx();			SetCtlValue(progWindow.hScroll,i);			load_display_process_ctx();			put_PC_in_progwindow();			update_memdisplay(ANDREG);			progWindow.update_window();			return;		}}void inc_process_displayed(void){short i = display_process_id & 0x7f;	while(i++ < NUMBER_PROGS - 1)		if(process_table[i] != 0)		{			display_process_id = i;			save_display_process_ctx();			SetCtlValue(progWindow.hScroll,i);			load_display_process_ctx();			put_PC_in_progwindow();			update_memdisplay(ANDREG);			progWindow.update_window();			return;		}}void auto_process_displayed(void){/*Set auto by setting the high bit of the low byte*/	display_process_id |= 0x80;	save_display_process_ctx();	progWindow.update_window();}void set_displayed_process_number(short i){/*Only set this if we are on auto*/	if((display_process_id & 0x80) && i != (display_process_id & 0x7f))	{		display_process_id = i | 0x80;		SetCtlValue(progWindow.hScroll,display_process_id);	}}