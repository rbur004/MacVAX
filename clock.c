#define CLOCK_C#include "mmemory.h"#include "clock.h"#pragma segment VaxIns2/*increment the interval timer register*/void clock_tick(	long tick_type,	long Number_of_ticks){	if((tick_type == ICCS_SGL_BIT && !ICCS_RUN( IPR(ICCS) ) )		|| (tick_type == ICCS_RUN_BIT &&  ICCS_RUN( IPR(ICCS) ) ) )	{	 	while(Number_of_ticks--)	/*slow way to tick, but it will work*/			if( ++IPR(ICR) == 0 ) 	/*just overflowed*/				clock_overflow();	}}static voidclock_overflow(void){	if( ICCS_INT( IPR(ICCS) ) ) 		/*Already had an interrupt bit set*/		IPR(ICCS) |= ICCS_ERR_BIT ; 	/*set error bit*/		IPR(ICCS) |= ICCS_INT_BIT; 			/*set the interrupt bit*/	if( ICCS_INT_ENB( IPR(ICCS) )	)	/*interrupts enabled*/		IPR(SISR) |= ICR_INTERRUPT_BIT; 	/*IPL 24*/		IPR(ICR) = IPR(NICR);				/*copy next increment register to ICR*/}void clear_clock_interrupt(void){	/*clear the ICCS registers interrupt bit, leaving the system SISR alone	*/	/*We can't alter the SISR as something else might have requested a level*/	/* 24 interrupt															*/		IPR(ICCS) &= ~ICCS_INT_BIT;}/*return vector address for clock interrupt*/address clock_interrupt(void){	if(ICCS_INT( IPR(ICCS) ) == 0) /*covers the case where we cancel the interrupt*/		return (address) 0;	else		return (address) V_CLOCK;}		