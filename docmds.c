#include	<types.h>#include	<quickdraw.h>#include	<windows.h>#include	<dialogs.h>#include	<controls.h>#include	<toolutils.h>#include	<menus.h>#include 	<Files.h>#include	<StandardFile.h>#include 	<packages.h>#include	<segload.h>#include 	<memory.h>#include	<resources.h>#include 	<strings.h>#include	<StdLib.h>//#include 	<OSEvents.h>#include	<Events.h>#include	<OSutils.h>#include 	<FCntl.h>//#include	<desk.h>#define DOCMDS_C#include    "globals.h"#include 	"mmemory.h"#include 	"window.h"#include 	"main.h"#include 	"macio.h"#include 	"iow.h"#include	"clock.h"#include 	"docmds.h"#include	"sym.h"#include	"lmem.h"#include	"regw.h"#include	"progw.h"#include	"stackw.h"#include	"decdump.h"#include	"hexdump.h"#include	"vax.h"#include 	"exception.h"#include	"execute.h"#include	"aprintf.h"#include	"symbol_tab.h"#include	"vaxmacio.h"#include	"settings.h"#include	"launch.h"#include	"process.h"#include 	"controldef.h"#include	"gotod.h"#include 	"display_process.h"#pragma segment MENUSvoid file_open(void){	new_process( (MFILE *)0 );	put_PC_in_progwindow();	clear_all_windows();}void file_close( void ){	terminate_process();	put_PC_in_progwindow();	clear_all_windows();}void file_sendOpto(void){}void file_transfer(void){}void run_reset(void){		reset_current_proc();		put_PC_in_progwindow();		clear_io_window();		clear_all_windows();}long event_loop(void){EventRecord 			myEvent;long 					windownum;short 					myControl;long 					os_message;	/*	 * Main Event tasks:	 */	SystemTask();	if (!GetNextEvent(everyEvent, &myEvent)) {		/*		 * A null or system event, not for me.		 * Here is a good place for heap cleanup and/or		 * segment unloading if I want to.		 */		return 0;	}	switch (myEvent.what)	{	case mouseDown:		switch (FindWindow(myEvent.where, &whichWindow))		{		case inSysWindow:			/*			 * In the unlikely case that the active desk accessory does not			 * handle mouseDown, keyDown, or other events, GetNextEvent() will			 * give them to us!  So before we perform actions on some events,			 * we check to see that the affected window in question is really			 * our window.			 */			SystemClick(&myEvent, whichWindow);			break;		case inMenuBar:			doCommand(MenuSelect(myEvent.where),myEvent.modifiers & optionKey);			break;		case inDrag:			DragWindow(whichWindow, myEvent.where, &dragRect);			break;		case inGoAway:			if ((windownum = GetWRefCon(whichWindow) - progwID) >= 0 && windownum < NumWindows)				if (TrackGoAway(whichWindow, myEvent.where))				{	SendBehind(whichWindow,0L);					ShowHide(whichWindow,false);				}			break;					case inGrow:			if (whichWindow == theActiveWindow)				if ((windownum = GetWRefCon(whichWindow) - progwID) >= 0 && windownum < NumWindows)					GrowWnd(&window[windownum],myEvent.where);			else				SelectWindow(whichWindow);			break;					case inContent:			if (whichWindow != theActiveWindow && !(myEvent.modifiers & cmdKey)) 			{				SelectWindow(whichWindow);			} 			else if ((windownum = GetWRefCon(whichWindow) - progwID) >= 0 && windownum < NumWindows)			{	GlobalToLocal(&myEvent.where);				if (PtInRect(myEvent.where, &(window[windownum].usable)) ) 					window[windownum].click_window(&myEvent.where,myEvent.modifiers);				else 				{					myControl = FindControl(myEvent.where, whichWindow, &whichControl);					switch(myControl) 					{					case in0:							if(TrackControl(whichControl, myEvent.where , 0))								put_at_top_progwindow(0);							break;					case inUpByte:							TrackControl(whichControl, myEvent.where , sScrollUpProc);							break;					case inDownByte:							TrackControl(whichControl, myEvent.where , sScrollDownProc);							break;					case inUpInstruction:							TrackControl(whichControl, myEvent.where , sScrollUpProc);							break;					case inDownInstruction:							TrackControl(whichControl, myEvent.where , sScrollDownProc);							break;					case inPC:							if(TrackControl(whichControl, myEvent.where , 0))								put_at_top_progwindow(PC);							break;					case inAddress:							if(TrackControl(whichControl, myEvent.where , 0))								goto_address(USE_PROGMEMW);							break;					case inPrevProcess:							if(TrackControl(whichControl, myEvent.where , 0))								dec_process_displayed();							break;					case inNextProcess:							if(TrackControl(whichControl, myEvent.where , 0))								inc_process_displayed();							break;					case inAutoProcess:							if(TrackControl(whichControl, myEvent.where , 0))								auto_process_displayed();							break;					case inIStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(ISP, 1);							break;					case inKStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(KSP, 1);							break;					case inEStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(ESP, 1);							break;					case inSStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(SSP, 1);							break;					case inUStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(USP, 1);							break;					case inCStack:							if(TrackControl(whichControl, myEvent.where , 0))								set_stack(0, 0);							break;					case inUpButton:							TrackControl(whichControl, myEvent.where , sScrollUpProc);							break;					case inDownButton:							TrackControl(whichControl, myEvent.where ,sScrollDownProc);							break;					case inMyUpPage:							PageScroll_highlight(myControl, -window[windownum].nlines);							break;					case inMyDownPage:							PageScroll_highlight(myControl, window[windownum].nlines);							break;					case inPageUp:							PageScroll(myControl, -window[windownum].nlines);							break;					case inPageDown:							PageScroll(myControl, window[windownum].nlines);							break;					case inThumb:							TrackControl(whichControl, myEvent.where , 0);							ScrollBits();							break;					}				}			}			break;		default:			break;		}/*endsw findwindow*/		break;		case keyDown:		case autoKey:			if((myEvent.modifiers & cmdKey) )			{				if((myEvent.message & charCodeMask) == '.')				{	stop = 1;				}				else					doCommand(MenuKey(myEvent.message & charCodeMask),myEvent.modifiers & optionKey);			}			else if (stop == 1) /*if stopped allow editing of any window*/			{				if ((windownum = GetWRefCon(theActiveWindow) - progwID) >= 0 && windownum < NumWindows)					if(window[windownum].keypress)						window[windownum].keypress(myEvent.message & charCodeMask);			}			else	/*If running then io is considered console io*/				iow_keypress(myEvent.message & charCodeMask);			break;		case activateEvt:			if ((windownum = GetWRefCon((WindowPtr) myEvent.message) - progwID) >= 0 && windownum < NumWindows)				do_activate(&window[windownum],myEvent.modifiers & activeFlag);			break;		case updateEvt:			if ((windownum = GetWRefCon((WindowPtr) myEvent.message) - progwID) >= 0 && windownum < NumWindows)				doupdate(&window[windownum], 1L);			break;		case osEvt:			os_message = (myEvent.message >> 24) & BYTE_MASK;			if(os_message & suspendResumeMessage)			{				if(myEvent.message & resumeFlag )				{ /*resume*/					/*do_activate(theActiveWindow,0);*/				}				else /* suspend */				{					/*do_activate(theActiveWindow,1);*/				}			}			break;		default:			break;	}/*endsw myEvent.what*/	return (stop == 1 ? -1:0);}void run_go(void){register long i;	HiliteMenu((short)0);	DisableItem(MyMenus[runMenu], (short)goCommand);	DisableItem(MyMenus[runMenu], (short)stepstepCommand);	DisableItem(MyMenus[runMenu], (short)stepCommand);	EnableItem(MyMenus[runMenu], (short)PauseCommand);	save_display_process_ctx();		stop = 0;	i = 0;	saw_watch_point = 0;	while(stop == 0) 	{			exceptions_on = 1;		execute();		stop_writes = 0;		exceptions_on = 1;		/* 		if(i++ == 49)		{			if((display_process_id & 0x80) == 0)				load_display_process_ctx();							if(event_loop())			{				break;			}			else				i = 0;			if((display_process_id & 0x80) == 0)				save_display_process_ctx();		} */		clock_tick(ICCS_RUN_BIT,1);		service_interrupt();		stop_writes = 0;		exceptions_on = 0;		if((IPR(TXCS) & 0x80 ) == 0 ) /* output pending */		{			if(next_transmit_interrupt > 0) /*delay by random time set up on mtpr TXDB*/				next_transmit_interrupt--;			else				process_output();		}	}	stop = 1;	if((IPR(TXCS) & 0x80 ) == 0 ) /* output pending */		process_output();		load_display_process_ctx();		put_PC_in_progwindow();	update_memdisplay(ANDREG);	progWindow.update_window();	EnableItem(MyMenus[runMenu], (short)goCommand);	EnableItem(MyMenus[runMenu], (short)stepstepCommand);	EnableItem(MyMenus[runMenu], (short)stepCommand);	DisableItem(MyMenus[runMenu], (short)PauseCommand);}void run_stepstep(void){	HiliteMenu((short)0);	DisableItem(MyMenus[runMenu], (short)goCommand);	DisableItem(MyMenus[runMenu], (short)stepstepCommand);	DisableItem(MyMenus[runMenu], (short)stepCommand);	EnableItem(MyMenus[runMenu], (short)PauseCommand);	save_display_process_ctx();	stop = 0;	saw_watch_point = 0;	while(stop == 0 && event_loop() == 0) 	{			exceptions_on = 1;		execute();		stop_writes = 0;		exceptions_on = 1;		clock_tick(ICCS_RUN_BIT,1);		service_interrupt();		if((IPR(TXCS) & 0x80 ) == 0 ) /* output pending */		{			if(next_transmit_interrupt > 0) /*delay by random time set up on mtpr TXDB*/				next_transmit_interrupt--;			else				process_output();		}		stop_writes = 0;		exceptions_on = 0;		put_PC_in_progwindow();		update_memdisplay(ANDREG);		progWindow.update_window();	}	stop = 1;	if((IPR(TXCS) & 0x80 ) == 0 ) /* output pending */		process_output();	load_display_process_ctx();	EnableItem(MyMenus[runMenu], (short)goCommand);	EnableItem(MyMenus[runMenu], (short)stepstepCommand);	EnableItem(MyMenus[runMenu], (short)stepCommand);	DisableItem(MyMenus[runMenu], (short)PauseCommand);}void run_step(void){		HiliteMenu((short)0);	save_display_process_ctx();	exceptions_on = 1;	stop = 0;	saw_watch_point = 0;	execute();	stop_writes = 0;	exceptions_on = 1;	clock_tick(ICCS_RUN_BIT,1);	service_interrupt();	if((IPR(TXCS) & (long)0x80 ) == 0) /* output pending */		process_output();	stop_writes = 0;	exceptions_on = 0;	stop = 1;	load_display_process_ctx();	put_PC_in_progwindow();	update_memdisplay(ANDREG);	progWindow.update_window();}void run_watch_for_access_toggle(void) /*toggles a watch/break point*/{address loc;		switch(GetWRefCon(theActiveWindow))	{	case dumphwID:		if((loc = get_c_pos_h()) != ERROR)			toggle_watch_bit(loc);		break;	case dumpdwID:		if((loc = get_c_pos_d()) != ERROR)			toggle_watch_bit(loc);		break;		case progwID:		if((loc = get_c_pos_prog()) != ERROR)			toggle_watch_bit(loc);		break;	case physmemwID:	case memwID:	default:		return;	}	update_memdisplay(NOTREG);	progWindow.update_window();}void run_wbtoggleREAD(void){	r_watch_and_breaks_on = !r_watch_and_breaks_on; 	CheckItem(MyMenus[runMenu],STOPonREADcommand,r_watch_and_breaks_on);	if(w_watch_and_breaks_on || r_watch_and_breaks_on)	{		EnableItem(MyMenus[runMenu], (short)watchCommand);		EnableItem(MyMenus[runMenu], (short)ClearAllWatchCommand);	}	else	{		DisableItem(MyMenus[runMenu], (short)watchCommand);		DisableItem(MyMenus[runMenu], (short)ClearAllWatchCommand);	}	update_memdisplay(NOTREG);	progWindow.update_window();}void run_wbtoggleWRITE(void){	w_watch_and_breaks_on = !w_watch_and_breaks_on; 	CheckItem(MyMenus[runMenu],STOPonWRITEcommand,w_watch_and_breaks_on);	if(w_watch_and_breaks_on || r_watch_and_breaks_on)	{		EnableItem(MyMenus[runMenu], (short)watchCommand);		EnableItem(MyMenus[runMenu], (short)ClearAllWatchCommand);	}	else	{		DisableItem(MyMenus[runMenu], (short)watchCommand);		DisableItem(MyMenus[runMenu], (short)ClearAllWatchCommand);	}	update_memdisplay(NOTREG);	progWindow.update_window();}void windows_symmode(void){	symmode = !symmode;  /*Use symbols rather than addresses*/	clear_all_windows();	setitem(MyMenus[optionMenu],symmodeCommand,symmode ? "Non Symbolic Mode":"Symbolic Mode");}void windows_hexmode(void){	hexmode = !hexmode;  /*Use hex for addresses rather than decimal*/	clear_all_windows();	setitem(MyMenus[optionMenu],hexaddrCommand,hexmode?"Dec Addresses":"Hex Addresses");}void windows_ignoreprotectionmode(void){	ignore_mode = !ignore_mode;  	clear_all_windows();	setitem(MyMenus[optionMenu],IgnoreModeCommand,		ignore_mode ? "Use Page Protection" : "Ignore Page Protection" );}void goto_loc(	register address x){	dumpdw_goto(x);	dumphw_goto(x);	update_memdisplay(NOTREG);}void items_display_mode(	long mode){Rect  r;	if(theActiveWindow == regWindow.windowptr)	{		reg_display_mode(mode);	}	else if(theActiveWindow == memWindow.windowptr)	{		mem_display_mode(mode);	}	else if(theActiveWindow == dumphWindow.windowptr && mode == DEC_FORMAT)	{	SetCtlValue(dumpdWindow.vScroll, 		dumpdWindow.theOrigin.v = (GetCtlValue(dumphWindow.vScroll) * 16) / 10);		r = (*((WindowPeek) (dumphWindow.windowptr))->strucRgn)->rgnBBox;		HideWindow(dumphWindow.windowptr);		MoveWindow(dumpdWindow.windowptr,r.left, r.top + 19,false);		ShowWindow(dumpdWindow.windowptr);		SelectWindow(dumpdWindow.windowptr);		hex_mem_dump = 0;	}	else if(theActiveWindow == dumpdWindow.windowptr && mode == HEX_FORMAT)	{	SetCtlValue(dumphWindow.vScroll, 		dumphWindow.theOrigin.v = (GetCtlValue(dumpdWindow.vScroll) * 10 ) / 16 );		r = (*((WindowPeek) (dumpdWindow.windowptr))->strucRgn)->rgnBBox;		HideWindow(dumpdWindow.windowptr);		MoveWindow(dumphWindow.windowptr,r.left, r.top + 19,false);		ShowWindow(dumphWindow.windowptr);		SelectWindow(dumphWindow.windowptr);		hex_mem_dump = 1;	}}#define  DLGLEFT 	85#define  DLGTOP		100void exec_other(	short save_str_res_number){#ifdef C68Kstruct Point 			dlgOrigin;			/* dialogbox top left corner*/static SFReply			theReply;			/* Data returned from dialogbox*/OSType	types[4];StringHandle strH;short cur_res_fd; /*temp to hold the current resource file fd*/	dlgOrigin.h = DLGLEFT;	dlgOrigin.v = DLGTOP;	types[0] = 'APPL';	SFGetFile(dlgOrigin,(void *)"", (FileFilterProcPtr) 0, (short)1, types, (DlgHookProcPtr)0,			&theReply);				if(theReply.good)	{			if(save_str_res_number)		{			cur_res_fd = CurResFile();			UseResFile(appl_fd);			strH = (StringHandle) Get1Resource ('STR ', save_str_res_number);			if( strH == 0 )			{				strH = NewString(theReply.fName);				AddResource((Handle)strH,'STR ',save_str_res_number,(void *)"");			}				else			{				SetString(strH,theReply.fName);				ChangedResource((Handle)strH);			}			UpdateResFile(appl_fd);			UseResFile(cur_res_fd);		}			p2cstr(theReply.fName);		exec_it((char *)theReply.fName,theReply.vRefNum,save_str_res_number);		/*The following will not happen unless we fail to launch*/		HUnlock((Handle) strH); 		ReleaseResource((Handle) strH); /*Throw away string*/	}#else	aprintf("Not implemented for PPC\n");#endif}void exec_it(	char *name,				 	/*name to launch + it better be right or boom*/	short vrefnum, 				/*zero for current directory*/	short save_str_res_number 	/*resource number of 'STR '*/ ){#ifdef C68Kstruct mac_args{	short message;	short count;	AppFile argv;} *arglist;Handle args;Handle *lmg = (Handle *)0xaec;struct launch_params appl;OSErr	error;FInfo	finfo;	if(vrefnum)		SetVol((void *)0,vrefnum);	if((error = getfinfo(name,(short)0,&finfo)) == noErr)	{		if(finfo.fdType != 'APPL')		{			aprintf("%s is not an application\nHelp Me find it.",name);			exec_other(save_str_res_number);		}		else		{			file_close();			c2pstr(name);			appl.name = name;			appl.altsndbuff = (short)0;						/*set up null args to pass to application*/			SetZone(SystemZone());			DisposHandle(*lmg);			args = NewHandle(sizeof(struct mac_args));			HLock(args);			SetZone(ApplicZone());			arglist = (struct mac_args *)*args;			arglist->message = 0;			arglist->count = 0;			*lmg = args;			HUnlock(args);						EXEC(( struct launch_params * ) &appl);		}	}	else	{	aprintf("Error %d\nCan't find %s\nHelp Me find it",error,name);		exec_other(save_str_res_number);	}#else	aprintf("Not implemented for PPC\n");#endif}