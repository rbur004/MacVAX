#include 	<types.h>#include	<StdLib.h>#include	<string.h>#define _SYMBOL_TAB_C_#include		"a.out.h"#include		"structs.h"#include		"patch_a.out.h"#include 		"symbol_tab.h"#include		"vax_to_68000.h"#include		"window.h"#include		"aprintf.h"#include		"macio.h"#include		"lmem.h"#include		"memory.h"#include 		"vaxmacio.h"#include		"progw.h"#pragma segment SYMBOL_TABLElong round(	long a,	long b){    if(b == 0)	{		aprintf("Internal Error; Round: b == 0");		return 0;	}	return ((a+b-1)/b)*b;}char * sbrk(	long incr){char *p;	if(incr == 0)		incr = 1;	p = calloc((unsigned long) incr, 1);	return(p);}void init_proc_tab(void){long i;	for(i = 0; i < NUMBER_PROGS; i++);		process_table[i] = 0;	current_process = (Symbol_Table_Type *)0;	current_process_index = 0;	sys_process = (Symbol_Table_Type *)0;	lmem_nlines();	set_displayed_process_number(current_process_index);}long alloc_proc_table_entry(	long sys_proc)/*Allocates a new process table entry. Used by system XFC SYS_SYMBOL_TABLE and ATTACH_SYMBOL_TABLE*//*Returns an index into the process_table if it suceeds.*//*Returns -1 if out of memory 						 *//*Returns -2 if too many processes for process_table		 */{long i;		if(sys_proc)	{		if(process_table[0])			free_symboltable(0);		if((process_table[0] = (Symbol_Table_Type *) sbrk(sizeof(Symbol_Table_Type))) == (Symbol_Table_Type *)0)		{			aprintf("new_proc: Unable to allocate space for symbol table record");			sys_process = (Symbol_Table_Type *)0;			lmem_nlines();			return -1;		}		sys_process = process_table[0];		lmem_nlines();		return 0;	}	else	{		for(i = 1; i < NUMBER_PROGS; i++)		{			if(process_table[i] == (Symbol_Table_Type *)  0)			{				if((process_table[i] = (Symbol_Table_Type *) sbrk(sizeof(Symbol_Table_Type))) == (Symbol_Table_Type *)0)				{					aprintf("new_proc: Unable to allocate space for symbol table record.");					return -1;				}				else					return i;			}		}		aprintf("new_proc: Unable to allocate space for symbol table record.\nToo many processes.");		return -2;	}}long create_symbol_table(	MFILE *fp,	long sys_proc)/*Creates a process table entry, and loads the symbol table*//*returns the process descriptor from alloc_proc_table_entry*/{long process_desc;	if((process_desc = alloc_proc_table_entry(sys_proc)) < 0)		return process_desc;	memcpy(process_table[process_desc]->name, fp->name, 64); /*keep a copy of file name*/	process_table[process_desc]->vrefnum = fp->vrefnum;		   /*keep a copy of vrefnum*/	process_table[process_desc]->fsym = fp; /*Copy file info into symbol table structure*/ 	setsym(process_table[process_desc]);	/*Any errors reported with dialog box*/	return process_desc;	}long use_user_symbol_table(	long process_desc)/*returns -1 for an invalid descriptor*/{	if(process_desc > 0	&& process_desc <  NUMBER_PROGS )	{		current_process = process_table[process_desc];		current_process_index = process_desc;		lmem_nlines();		set_displayed_process_number(current_process_index);		return 0;	}	else	{		current_process = (Symbol_Table_Type *) 0;		current_process_index = 0;		lmem_nlines();		set_displayed_process_number(current_process_index);		return -1;	}}	long free_symboltable(	long process_table_index){Symbol_Table_Type *st;	if(process_table_index >= 0	&& process_table_index <  NUMBER_PROGS 	&& (st = process_table[process_table_index]) )	{		if(st->symvec)		{			free((char *)st->symvec);		}		if(st->strtab)		{			free((char *)st->strtab);		}		if(st->esymtab)		{			free((char *)st->esymtab);		}		if( st == current_process )		{			current_process = (Symbol_Table_Type *)0;			current_process_index = 0;			set_displayed_process_number(current_process_index);			lmem_nlines();		}		else if(process_table_index == 0)		{			sys_process = (Symbol_Table_Type *)0;			lmem_nlines();		}		free((char *) st);		process_table[process_table_index] = (Symbol_Table_Type *)0;		return 0;	}	else		return -1;}	void free_all_symboltable(void){long i;	current_process_index = 0;	current_process = (Symbol_Table_Type *)0;	sys_process = (Symbol_Table_Type *)0;	for(i = 0; i < NUMBER_PROGS; i++)		if( process_table[i] != (Symbol_Table_Type *)0)			free_symboltable(i);	set_displayed_process_number(current_process_index);}long get_mac_filename_pd(	/*copies the MFILE->name and MFILE->vrefnum to VAX memory dest*/	unsigned long process_table_index,	address dest){Symbol_Table_Type *st;long fname_length;	if(process_table_index >= 0	&& process_table_index <  NUMBER_PROGS 	&& (st = process_table[process_table_index]) )	{	/*write volume reference number*/		vax_putw(st->vrefnum,dest);		dest += sizeof(short);		/*write file name as pascal string*/		fname_length = strlen(st->name);		vax_putb((char) fname_length,dest++);		copy_to_vaxmem(	dest, st->name, fname_length );		return 0;	}	else	{		return -1;	}}int comp_elements(	SYMTAB *e1, 	SYMTAB *e2){	if(e1->n_value < e2->n_value)		return(-1);		if(e1->n_value == e2->n_value)		return(0);	return(1);}long setsym(	Symbol_Table_Type *st){TXTHDR      txthdr;SYMTAB      *symptr;long		symbas;		/* Base of symbol table               */long		strbas;		/* base of string table				  */long         strtabsiz;long i;	/*Read the a.out file header*/	    if ( mread( st->fsym->fd, ( char * ) &txthdr, TXTHDRSIZ ) != TXTHDRSIZ )    {		aprintf( "Could not read header information of %s", st->name );		return -1;	}	/*Put in 68000 Byte order*/	patch_header(&txthdr);	    st->magic       = txthdr.a_magic;	st->txtsiz      = txthdr.a_text;    st->datsiz      = txthdr.a_data;    st->bsssiz      = txthdr.a_bss;    st->symnum      = txthdr.a_syms/( sizeof ( SYMTAB ) );    st->entrypt     = txthdr.a_entry;#ifdef RELOCATION_INFO_WANTED    trsize      = txthdr.a_trsize;    trnum       = strsize/( sizeof ( RELINFO ) );    drsize      = txthdr.a_drsize;    drnum       = drsize/( sizeof ( RELINFO ) );    relflg      = trsize != 0 || drsize != 0;#endif    symbas      	= N_SYMOFF( txthdr );	strbas			= ( long ) N_STROFF( txthdr );    if ( N_BADMAG(txthdr) )    {    		aprintf( "Bad magic number %o ( octal ) in  file", st->magic, st->name );		return -1;	}		/*Note Start addresses and sizes of CODE segment*/    st->txtmap.b1   = 0;					/*memory location to load CODE segment to*/    st->txtmap.e1   = st->txtsiz;			/*size of code segment*/    st->txtmap.f1   = N_TXTOFF( txthdr );	/*offset in file to find code segment*/	/*Note Start addresses and sizes of DATA segment*/    st->txtmap.b2   = ( st->magic == 0410 )		/*Location in memory of beginning of DATA segment*/                    ? round( ( long ) st->txtsiz, TXTRNDSIZ )                    : st->txtsiz;    st->txtmap.e2   = st->txtmap.b2 + st->datsiz;		/*size of DATA + CODE  segment*/    st->txtmap.f2   = st->txtmap.f1 + st->txtsiz;		/*Offset in file of DATA */		/*If there is a symbol table load it in*/    if ( st->symnum != 0 ) 	{					st->ndata_items = 0;		/*so far not many*/				/*allocate space for the symbol table*/        if((st->symvec = (SYMTAB *)sbrk( (long)(st->symnum + 1) * sizeof(SYMTAB) ) ) == ( SYMTAB * )0)		{			aprintf( "Warning!\nNot enough space for symbols for file %s!", st->name );            st->strtab = NIL_STRING;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;		}				/*Seek the string table offset in the file*/        IGNORE mlseek( st->fsym->fd, strbas, 0 );				/*obtain the string table size*/        if( mread( st->fsym->fd, ( char * ) &strtabsiz, sizeof ( long ) ) != sizeof ( long ))		{			aprintf("Unable to read string table size of file %s", st->name);			return -1;		}        strtabsiz = v2m_long(strtabsiz);	    if ( strtabsiz < 0 )		{            aprintf( "Bad string table size in file %s: %d", st->name, strtabsiz );			free((char *) st->symvec);            st->symvec = ( SYMTAB * ) NULL;            st->strtab = NIL_STRING;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;		}				/*Allocate space for the string table*/        if ((st->strtab = sbrk( strtabsiz )) == ( char * ) 0 ) 		{            aprintf( "Warning!\n\nNot enough space for string table in file %s!\nRequired %x (%d)\nNumber of Symbols %d", st->name , strtabsiz,strtabsiz,st->symnum);			free((char *) st->symvec);            st->symvec = ( SYMTAB * ) NULL;            st->esymtab = (extra_symtab_info_type *) 0;            st->symnum = 0;			return -1;        }        else 		{			/* Read in the string table*/            if( mread( st->fsym->fd, ( char * ) st->strtab, strtabsiz - sizeof( long )) != strtabsiz  - sizeof( long ))			{				aprintf("Unable to read stringtable of file %s", st->name);				free((char *) st->symvec);				free((char *) st->strtab);            	st->symvec = ( SYMTAB * ) NULL;            	st->strtab = NIL_STRING;            	st->esymtab = (extra_symtab_info_type *) 0;            	st->symnum = 0;				return -1;			}						/*seek the Symbol table base*/            IGNORE mlseek(st->fsym->fd, ( long ) symbas, 0 );			/*read in the symbol table*/            if( mread( st->fsym->fd, (char *)st->symvec, ( long ) st->symnum*sizeof ( SYMTAB ) ) != ( long ) st->symnum*sizeof ( SYMTAB ))			{				aprintf("Unable to read symbol table of file %s", st->name);				free((char *) st->symvec);				free((char *) st->strtab);            	st->symvec = ( SYMTAB * ) NULL;            	st->strtab = NIL_STRING;            	st->esymtab = (extra_symtab_info_type *) 0;            	st->symnum = 0;				return -1;			}						/*patch the symbol table for 68000 Byte order and change string table offsets to addresses*/			st->last_symtab_ent = st->symvec + st->symnum;            for ( symptr = st->symvec; symptr < st->last_symtab_ent; symptr++ )			{				patch_nlist(symptr);                if (	symptr->n_un.n_strx == 0					||	symptr->n_un.n_strx > strtabsiz )                    symptr->n_un.n_name = NIL_STRING;                else                    symptr->n_un.n_name = st->strtab + symptr->n_un.n_strx - sizeof ( long );								/*Count the number of DATA items*/				if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA )						st->ndata_items++;										/*Warn about unresolved references.*/				if( (symptr->n_type&N_TYPE) == N_UNDF )					aprintf("WARNING!\n\nUnresolved External Reference: %s in file %s",symptr->n_un.n_name, st->name);            }					}				/*Sort the symbol table in address order.*/		qsort((char *)st->symvec,(size_t)(st->symnum),(size_t)sizeof ( SYMTAB ),							comp_elements);				/*Find the first DATA item*/		st->first_data_ent	= st->last_symtab_ent;	/*assume there are none*/		for ( symptr = st->symvec; symptr < st->last_symtab_ent; symptr++ )		{			if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA )				{	st->first_data_ent	= 	symptr;	/*found the first one*/				break;						/*so exit loop*/			}		}				/*Extract locally added symbol table info for "lmem" window*/		if( (st->esymtab = (extra_symtab_info_type *)sbrk( st->ndata_items * sizeof ( extra_symtab_info_type ) ) ) != (extra_symtab_info_type *) 0)		{			for( i = 0, symptr = st->first_data_ent; symptr < st->last_symtab_ent; symptr++, i++ )				if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA)				{				long tnum_lines;				long tnum_items;					st->esymtab[i].line_no = st->ndata_lines;					st->esymtab[i].size    = SIZEOFTYPE(symptr);					st->esymtab[i].type    = TYPE(symptr);					if(st->esymtab[i].type == IASCII || st->esymtab[i].type == IASCIZ)						st->esymtab[i].format = CHAR_FORMAT;					else if (st->esymtab[i].type == IFFLOAT)						st->esymtab[i].format = FLOAT_FORMAT;					else if ( st->esymtab[i].type == ILONG || st->esymtab[i].type == IINT 						   || st->esymtab[i].type == IWORD || st->esymtab[i].type == IBYTE)						st->esymtab[i].format = DEC_FORMAT;					else 						st->esymtab[i].format = HEX_FORMAT;										/*st->esymtab[i].nitemspl = NUM_ITEMS_PL(symptr);*/					/*st->esymtab[i].elines   = NUM_LINES(symptr) + st->ndata_lines - 1;*/					/*st->ndata_lines += NUM_LINES(symptr);*/					/*MPW 3.2 compiler dies when attempting to compile above three lines. Replaced with lines below.*/										tnum_lines              = NUM_LINES(symptr);					tnum_items              = NUM_ITEMS(symptr);					st->esymtab[i].nitemspl = tnum_items/tnum_lines;					st->esymtab[i].elines   = tnum_lines + st->ndata_lines - 1;					st->ndata_lines        += tnum_lines;				}		}		else		{			aprintf("Warning!\nUnable to allocate space for some symbol table info.\nThe Memory by Label window will not display any data items for this file %s", st->name);			st->ndata_lines = 0;		}    }	return 0;}