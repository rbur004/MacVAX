#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<StdIO.h>#include	<String.h>#define __LMEM_C_#include "main.h"#include "mmemory.h"#include "window.h"#include "lmem.h"#include "vax_to_68000.h"#include "defines.h"#include "structs.h"#include "globals.h"#include "symbol_tab.h"#include "docmds.h"void lmemw_click(	Point *p,	short modifiers){#pragma unused(modifiers)register short line_size =  memWindow.lsize;register long i;register long lmemw_line,lmemw_byte;Symbol_Table_Type *st = 0;	if((lmemw_line = p->v / line_size) == 0)		lmem_item = -1;	else	{		lmemw_byte = (p->h - 4) / CharWidth('0');		lmemw_line += memWindow.mbase - 1;		if(current_process)		{			if(lmemw_line < current_process->ndata_lines)			{				st = current_process;				lmem_system = 0;			}			else if(sys_process 		     	 && (lmemw_line -= current_process->ndata_lines + 1) < sys_process->ndata_lines)			{							st = sys_process;					lmem_system = 1;			}		}		else if(sys_process			&&  --lmemw_line < sys_process->ndata_lines)		{				st = sys_process;				lmem_system = 1;		}		if(st && st->esymtab)		{			/*Search for the data item*/			for(i = 0; i < st->ndata_items; i++)			{				if(st->esymtab[i].line_no <= lmemw_line && lmemw_line <= st->esymtab[i].elines)				{					lmem_item = i;					break;				}			}		}		else			lmem_item = -1;	}	update_lmem_window();	return;}void lmemw_keypress(long key){#pragma unused(key)	SysBeep(5);#ifdef DOTHISSOMETIME	if(ignore_mode == 1)		displaymode = 1;		...	displaymode = 0;#endif}void lmemw_undo_keypress(void){}void mem_display_mode(	long mode){Symbol_Table_Type *st = 0;	st = lmem_system ? sys_process:current_process;	if(lmem_item != -1 && st && st->esymtab)		st->esymtab[lmem_item].format = mode;	update_lmem_window();}void update_lmem_window(void){RgnHandle	hold_h;short header = memWindow.lsize - memWindow.forigin;register short column1;register short column2;register short line_size;Rect r ;GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	if( ((WindowPeek) (memWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(memWindow.windowptr);		exceptions_on = 0;	stop = 1;		if(ignore_mode == 1)		displaymode = 1;	column1 = CharWidth('0') * COLUMN1 + 4;	column2 = CharWidth('0') * COLUMN2 + 4;	line_size = memWindow.lsize;		r = memWindow.usable;	hold_h = NewRgn();	GetClip(hold_h);		r.right = column1  - CharWidth('0');	ClipRect(&r);	MoveTo(4,header);	DrawString((void *)"\p  Label ");		r.right = column2  - CharWidth('0');	ClipRect(&r);	MoveTo(column1 , header);	DrawString((void *)"\p  Address ");		ClipRect(&memWindow.usable);	MoveTo(column2 , header);	DrawString((void *)"\p  Value");	memWindow.mbase = memWindow.theOrigin.v;		dumpsyms();		MoveTo(4,memWindow.lsize - 1);	PenSize(1,2);	Line(memWindow.usable.right,0);		PenSize(2,1);	MoveTo(column1 - CharWidth('0') ,0);	Line(0,memWindow.usable.bottom);		MoveTo(column2 - CharWidth('0') ,0);	Line(0,memWindow.usable.bottom);		PenNormal();	SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);		stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;	displaymode = 0;}void dumpsyms(	void){Symbol_Table_Type *st;SYMTAB *symptr;char lbuff[128];long i;long j;long k;long l;long m;long x;unsigned char c;register short line_size =  memWindow.lsize;register short v = line_size + line_size;register short column1 = CharWidth('0') * COLUMN1 + 4;register short column2 = CharWidth('0') * COLUMN2 + 4;Rect r;Rect e;long lines_displayed = 0;		st = current_process;	for(x = 0; x < 2; x++) /* P symbols, Draw a line, then S symbols */	{		if(st && st->symvec && st->esymtab) /*ensure there is a symbol table*/		{				e = r = memWindow.usable;					for ( symptr = st->first_data_ent,i = 0; symptr < st->last_symtab_ent; symptr++)			{				if( (symptr->n_type&N_TYPE) == N_BSS || (symptr->n_type&N_TYPE) == N_DATA)				{					if(st->esymtab[i].elines < memWindow.mbase)					{							 i++;					}					else if(st->esymtab[i].line_no <= (memWindow.mbase + memWindow.nlines))					{					long addr;					long nlines = st->esymtab[i].elines - st->esymtab[i].line_no + 1;											if(st->esymtab[i].line_no < memWindow.mbase)						{							addr = symptr->n_value + ( memWindow.mbase - st->esymtab[i].line_no ) * st->esymtab[i].size * st->esymtab[i].nitemspl;							nlines -= ( memWindow.mbase - st->esymtab[i].line_no );						}						else						{							addr  = symptr->n_value;							lbuff[0] = sprintf(&lbuff[1], "%s", ( symptr->n_un.n_name == NIL_STRING )									? "        "									: symptr->n_un.n_name);							r.right = column1  - CharWidth('0');							ClipRect(&r);							MoveTo((short) 4, v);							DrawString((void *)lbuff);						}						if(lmem_item == i && x == lmem_system)							TextMode(notSrcCopy);						for(j = 0; j < nlines; j++)						{							r.right = column2  - CharWidth('0');							ClipRect(&r);							lbuff[0] = sprintf(&lbuff[1],hexmode ? "0x%8.8x":"%10.10d",addr);							MoveTo(column1 ,v);							DrawString((void *)lbuff);							m = 0;							switch(d_format[st->esymtab[i].format][st->esymtab[i].size].fetchx)							{							case C_:									m += sprintf(&lbuff[m],"\"");								for(k = 0; k < st->esymtab[i].nitemspl; k++)								{									for(l = 0 ; l < d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format,												(c = vax_fetchb(addr+l) & BYTE_MASK) < 0x20 || c >= 0x7f ? 0xff:c);									addr += st->esymtab[i].size;								}								m += sprintf(&lbuff[m],"\"");								break;							case B:									if(st->esymtab[i].format == HEX_FORMAT)									m += sprintf(&lbuff[m],"0x");								for(k = 0; k < st->esymtab[i].nitemspl; k++)								{									for(l = 0 ; l < d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchb(addr+l) & BYTE_MASK);									for(l = d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches + 1; l <= 0; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchb(addr-l) & BYTE_MASK);									addr += st->esymtab[i].size;								}								m += sprintf(&lbuff[m]," ");								break;							case BE:								/*special case of byte*/								/*repeat count must be 1, byte is sign extended*/								if(st->esymtab[i].format == HEX_FORMAT)								{									m += sprintf(&lbuff[m],"0x");									m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchb(addr) & BYTE_MASK);								}								else									m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, (long)vax_fetchb(addr) );								m += sprintf(&lbuff[m]," ");								addr += st->esymtab[i].size;								break;							case W:								if(st->esymtab[i].format == HEX_FORMAT)									m += sprintf(&lbuff[m],"0x");								for(k = 0; k < st->esymtab[i].nitemspl; k++)								{									for(l = 0 ; l < d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchw(addr+l) & WORD_MASK);									addr += st->esymtab[i].size;								}								m += sprintf(&lbuff[m]," ");								break;							case WE:								if(st->esymtab[i].format == HEX_FORMAT)								{									m += sprintf(&lbuff[m],"0x");									m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchw(addr) & WORD_MASK);								}								else									m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, (long) vax_fetchw(addr));								m += sprintf(&lbuff[m]," ");								addr += st->esymtab[i].size;								break;							case L:								if(st->esymtab[i].format == HEX_FORMAT)									m += sprintf(&lbuff[m],"0x");								for(k = 0; k < st->esymtab[i].nitemspl; k++)								{									for(l = 0 ; l < d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, vax_fetchl(addr+l) );									addr += st->esymtab[i].size;								}								m += sprintf(&lbuff[m]," ");								break;							case F:								for(k = 0; k < st->esymtab[i].nitemspl; k++)								{									for(l = 0 ; l < d_format[st->esymtab[i].format][st->esymtab[i].size].nfetches; l++)										m += sprintf(&lbuff[m],d_format[st->esymtab[i].format][st->esymtab[i].size].format, f2s(vax_fetchf(addr+l)) );									addr += st->esymtab[i].size;								}								m += sprintf(&lbuff[m]," ");								break;							default:								m += sprintf(&lbuff[m],"Item Cannot be Printed In this format");							}							ClipRect(&memWindow.usable);							MoveTo(column2 ,v);							DrawText(lbuff,(short)0,(short)strlen(lbuff));							e.left = (qd.thePort)->pnLoc.h;							e.bottom = (qd.thePort)->pnLoc.v + memWindow.forigin;							e.top = e.bottom - line_size - 1;							EraseRect(&e);							v += line_size;							if(++lines_displayed > memWindow.nlines)							{	if(lmem_item == i && x == lmem_system)									TextMode(srcCopy);								return;							}						}						if(lmem_item == i && x == lmem_system)							TextMode(srcCopy);						i++;					}					else						return;				}			}		}		if(x == 0)		{			if(lines_displayed > memWindow.nlines)				return;			st = sys_process;			if(lines_displayed && st && st->symvec && st->esymtab)			{				MoveTo(4, v - 1);				PenSize(1, 2);				Line(memWindow.usable.right,0);				PenNormal();				v += line_size;				if(++lines_displayed > memWindow.nlines)					return;			}		}	}}void activate_lmem_window(	long is_active){	if(is_active)	{		EnableItem(MyMenus[optionMenu], DisplayHexCommand);		EnableItem(MyMenus[optionMenu], DisplaydecCommand);		EnableItem(MyMenus[optionMenu], DisplayudecCommand);		EnableItem(MyMenus[optionMenu], DisplayasciiCommand);		EnableItem(MyMenus[optionMenu], DisplayfloatCommand);		DisableItem(MyMenus[runMenu], watchCommand);	}	else	{		DisableItem(MyMenus[optionMenu], DisplayHexCommand);		DisableItem(MyMenus[optionMenu], DisplaydecCommand);		DisableItem(MyMenus[optionMenu], DisplayudecCommand);		DisableItem(MyMenus[optionMenu], DisplayasciiCommand);		DisableItem(MyMenus[optionMenu], DisplayfloatCommand);		EnableItem(MyMenus[runMenu], watchCommand);		lmem_item = -1;		/*update_lmem_window();*/	}}void lmem_nlines(	void){short n = 0;		if(current_process 	&& current_process->symvec 	&& current_process->esymtab)		n += current_process->ndata_lines;		if(sys_process	&& sys_process->symvec 	&& sys_process->esymtab)		n += sys_process->ndata_lines;			SetCtlMax(memWindow.vScroll, n ); }