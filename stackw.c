#include <types.h>#include	<quickdraw.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<StdLib.h>#include	<String.h>#include	<StdIO.h>#define __STACK_C_#include "main.h"#include "window.h"#include "mmemory.h"#include "defines.h"#include "stackw.h"#include "aprintf.h"#include "progw.h"#include "vax_to_68000.h"#include "docmds.h"#include "iow.h"static int follow_stack = 1;static short displayed_stack;static long clicked_line = -1;void put_at_top_stackw(	address b){	if(b < stackWindow.mbase)	{		clicked_line = -1;	/*Want to Jump to an address before the stack*/		return;	}		/*Calculate the new line number for screen line 0*/	clicked_line = (b - stackWindow.mbase)/ 4;			if(clicked_line >= stackWindow.theOrigin.v 	&& clicked_line < stackWindow.nlines + stackWindow.theOrigin.v)	{		stackw_draw_r_cursor();	/*We are still on the same page*/		return;	}		stackWindow.theOrigin.v = clicked_line;		update_stack_window();	/*We went off of the page so we need to redraw the window*/}void stackw_click(	Point *pp,	short modifiers){short 	lbase;			/* line number of first line of the window*/short 	last_line; 		/* line number of the last line of the window*/short 	lineno = 0;		/* The Line we are processing*/long	hold_stop = stop;						/*Hold the current execution state*/long	hold_exceptions_on = exceptions_on;		/*Hold the current exceptions state*/long 	hold_saw_watch_point = saw_watch_point;	/*Hold the current watch point state*/word 	p;				/*Loop Temp*/long 	r;				/*Loop Temp*/address tmp_SP;			/*Stack pointer as we process stack*/address tmp_AP;			/*Temporary argument pointer as we process each stack frame*/word 	entry_mask;		/*Entry mask for procedures, need it to process saved registers*/address condition_handler;	/*condition handler address. First item on a Frame*/union{	unsigned long	x;	struct	{		unsigned long	 spa:2;		unsigned long	 SorG:1;		unsigned long 	 bit28:1;		unsigned long	 mask:12;		unsigned long    psw: 16;	}xx;}xxx;					/*Second Long on stack Frame. Need to break it into useful bits*/address saved_AP;		/*Saved Argument Pointer, Third long on Stack Frame*/address saved_FP;		/*Saved Frame Pointer, Fourth long on Stack Frame*/address saved_PC;		/*Saved Program Couner, Fifth long on Stack Frame*/unsigned long	saved_vax_register;	/*all saved registers loaded here before we print them*/address frame_pointer;	/*Next address we expect to see a Frame*/address last_frame_pointer = 0;	/*last address we saw a Frame*/int number_of_args;		/*Number of 4 byte Arguments on stack (From a "calls" instruction).*/		stackw_draw_r_cursor();	/*Remove provious clicked_line's highlighting*/		/*Determine the line that was clicked on*/	clicked_line = (pp->v  / stackWindow.lsize);		exceptions_on = 0;			stop = 1;		lbase = stackWindow.theOrigin.v ;	last_line = stackWindow.nlines + lbase;	clicked_line += lbase;			if(follow_stack || displayed_stack == (IS ? 4:CMD))	{		tmp_SP = SP & ~3; 	/*set tmp_SP to SP rounded to 4 byte boundary*/		frame_pointer = FP;	}	else	{		tmp_SP = IPR(displayed_stack) & ~3;		frame_pointer = IPR(displayed_stack + KFP); 	}		if(	tmp_SP != 0 )	/*Continue only if there is valid stack data*/	{		for(;;)		{			while(tmp_SP != frame_pointer)			{				if(lineno == clicked_line || lineno > last_line)				{					stackw_draw_r_cursor();										stop = hold_stop;					exceptions_on = hold_exceptions_on;					saw_watch_point = hold_saw_watch_point;					return;				}				tmp_SP += 4;				lineno++;			}			if(lineno > last_line)			{				break;			}			condition_handler = vax_fetchl(tmp_SP);			if(lineno == clicked_line)			{				if( (modifiers & cmdKey) ) 				{					if(! ( modifiers & ~(cmdKey)) )						put_at_top_progwindow(condition_handler);					else if((modifiers & shiftKey) && !( modifiers & ~(shiftKey | cmdKey)) )					{						put_at_top_stackw(last_frame_pointer);						stop = hold_stop;						exceptions_on = hold_exceptions_on;						saw_watch_point = hold_saw_watch_point;						return;					}				}				break;			}							if(++lineno > last_line)			{				break;			}			last_frame_pointer = tmp_SP;	/*remember location so we can jump back to it*/					tmp_SP += 4;			xxx.x = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno == clicked_line || ++lineno > last_line)			{				break;			}					saved_AP = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno == clicked_line)			{				if((modifiers & cmdKey) && !( modifiers & ~(cmdKey)) && saved_AP > tmp_SP)				{					put_at_top_stackw(saved_AP);					stop = hold_stop;					exceptions_on = hold_exceptions_on;					saw_watch_point = hold_saw_watch_point;					return;				}				break;			}			if(++lineno > last_line)			{				break;			}					frame_pointer = saved_FP = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno == clicked_line)			{				if((modifiers & cmdKey) && !( modifiers & ~(cmdKey)) && saved_FP > tmp_SP)				{					put_at_top_stackw(saved_FP);					stop = hold_stop;					exceptions_on = hold_exceptions_on;					saw_watch_point = hold_saw_watch_point;					return;				}				break;			}			if(++lineno > last_line)			{				break;			}					saved_PC = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno++ == clicked_line)			{				if((modifiers & cmdKey) && !( modifiers & ~(cmdKey)) )					put_at_top_progwindow(saved_PC);				break;			}			if(lineno > last_line)			{				break;			}					entry_mask = xxx.xx.mask;			for( r = 0, p = 0x1; p <= 0x800 ; p <<= 1, r++ )	/*pop off of stack marked registers*/				if( entry_mask & p )				{					saved_vax_register = vax_fetchl( tmp_SP );					tmp_SP += 4;					if(lineno == clicked_line || ++lineno > last_line)					{						stackw_draw_r_cursor();												stop = hold_stop;						exceptions_on = hold_exceptions_on;						saw_watch_point = hold_saw_watch_point;						return;					}				}			if(lineno > last_line)			{				break;			}			tmp_SP |= xxx.xx.spa;	/*drop stack alignment*/		//	saved_PSW = xxx.xx.psw & BYTE_MASK;			if(xxx.xx.SorG)			{				number_of_args = vax_fetchl(tmp_SP);				tmp_AP = tmp_SP + ((number_of_args & BYTE_MASK) * 4 + 4); /*was a calls instruction pop the arguments*/				tmp_SP += 4;				if(++lineno > last_line)				{					break;				}				while(tmp_SP != tmp_AP)				{					tmp_SP += 4;					if(lineno >= clicked_line || ++lineno > last_line)					{						stackw_draw_r_cursor();												stop = hold_stop;						exceptions_on = hold_exceptions_on;						saw_watch_point = hold_saw_watch_point;						return;					}				}				if(lineno > last_line)				{					break;				}			}		//	if(xxx.xx.psw & HI_BYTE_MASK)		//	{	/*manual says these bits must be zero*/		//	}		}	}	else		clicked_line = -1;		stackw_draw_r_cursor();		stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;}static void stackw_draw_r_cursor(void){register short line_size =  stackWindow.lsize;Rect r;	if(clicked_line == -1)		return;	/*Nothing to highlight*/			/*Calculate rectangle to invert*/	r.left = stackWindow.usable.left;	r.right = 35 * CharWidth('0');	r.bottom = (clicked_line + 1 - stackWindow.theOrigin.v )  * line_size + stackWindow.forigin;				r.top	= r.bottom - line_size;	r.bottom -= stackWindow.leading;	/*Return if region not in the window*/	if(r.top >= stackWindow.usable.bottom 	|| r.bottom <= stackWindow.usable.top)		return;	/* Clip to window without having to call ClipRect */	if(r.top < stackWindow.usable.top)		r.top = stackWindow.usable.top;	if(r.bottom > stackWindow.usable.bottom)		r.bottom = stackWindow.usable.bottom;	if(r.right > stackWindow.usable.right)		r.right = stackWindow.usable.right;		InvertRect(&r);}void stackw_keypress(	long key){	if(clicked_line == -1)		return;			stackw_draw_r_cursor();	switch(key)	{	case 0x1c:	case 0x1d:		break;	case 0x1f:		clicked_line++;		if(clicked_line == stackWindow.theOrigin.v + stackWindow.nlines)		{			stackWindow.theOrigin.v++;				update_stack_window();			return;		}		break;	case 0x1e:		if(clicked_line == 0)		{			SysBeep(5);		}		else		{			clicked_line--;			if(clicked_line < stackWindow.theOrigin.v)			{				put_at_top_stackw( clicked_line * 4 + stackWindow.mbase );					return;			}		}		break;	default:		break;	}	stackw_draw_r_cursor();}void stackw_undo_keypress(void){}							void update_stack_window(void){RgnHandle	hold_h;char 	buff[64];register short line_size =  stackWindow.lsize;register short v = line_size;GrafPtr savePort;short 	lbase;short 	last_line; short 	lineno = 0;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long 	hold_saw_watch_point = saw_watch_point;word 	p;long 	r;address tmp_SP;address tmp_AP;word 	entry_mask;address condition_handler;union{	unsigned long	x;	struct	{		unsigned long	 spa:2;		unsigned long	 SorG:1;		unsigned long 	 bit28:1;		unsigned long	 mask:12;		unsigned long    psw: 16;	}xx;}xxx;address saved_AP;address saved_FP;address saved_PC;unsigned long	saved_vax_register;address frame_pointer;int number_of_args;	if( ((WindowPeek) (stackWindow.windowptr))->visible == false )		return;	set_stack(0, 2);	GetPort(&savePort);	SetPort(stackWindow.windowptr);		exceptions_on = 0;	stop = 1;		hold_h = NewRgn();	GetClip(hold_h);	ClipRect(&stackWindow.usable);		lbase = stackWindow.theOrigin.v ;	last_line = stackWindow.nlines + lbase - 1;		if(follow_stack || displayed_stack == (IS ? 4:CMD))	{		tmp_SP = SP & ~3; 	/*set tmp_SP to SP rounded to 4 byte boundary*/		frame_pointer = FP;	}	else	{		tmp_SP = IPR(displayed_stack) & ~3;		frame_pointer = IPR(displayed_stack + KFP); 	}		stackWindow.mbase = tmp_SP;		if(	tmp_SP == 0 )	{		EraseRect(&stackWindow.usable);	}	else	{		for(;;)		{			while(tmp_SP != frame_pointer)			{				if(lineno > last_line)					break;				if(lineno >= lbase )				{					MoveTo(4, v);					sprintf(buff,"Local: 0x%8.8x       0x%8.8x ", tmp_SP, vax_fetchl(tmp_SP));					DrawText(buff,(short)0,(short) strlen(buff));					v += line_size;				}				tmp_SP += 4;				lineno++;			}			if(lineno > last_line)				break;				condition_handler = vax_fetchl(tmp_SP);			if(lineno >= lbase)			{				MoveTo(4, v);				sprintf(buff,"¥Cond Hnd: 0x%8.8x   0x%8.8x ", tmp_SP, condition_handler);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			tmp_SP += 4;			if(++lineno > last_line)				break;					xxx.x = vax_fetchl(tmp_SP);			tmp_SP += 4;				if(lineno >= lbase)			{				MoveTo(4, v);				sprintf(buff,"SPA %1.1x  %c  %1.1x  MASK 0x%3.3x PSW 0x%4.4x ",					xxx.xx.spa, xxx.xx.SorG ? 'S':'G', xxx.xx.bit28, xxx.xx.mask, xxx.xx.psw);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			if(++lineno > last_line)				break;					saved_AP = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno >= lbase)			{				MoveTo(4, v);				sprintf(buff,"Saved Argument Pointer: 0x%8.8x ", saved_AP);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			if(++lineno > last_line)				break;					frame_pointer = saved_FP = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno >= lbase)			{				MoveTo(4, v);				sprintf(buff,"Saved Frame Pointer:    0x%8.8x ", saved_FP);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			if(++lineno > last_line)				break;					saved_PC = vax_fetchl(tmp_SP);			tmp_SP += 4;			if(lineno >= lbase)			{				MoveTo(4, v);				sprintf(buff,"Saved Program Counter:  0x%8.8x ", saved_PC);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			if(++lineno > last_line)				break;					entry_mask = xxx.xx.mask;			for( r = 0, p = 0x1; p <= 0x800 ; p <<= 1, r++ )	/*pop off of stack marked registers*/				if( entry_mask & p )				{					saved_vax_register = vax_fetchl( tmp_SP );					tmp_SP += 4;					if(lineno >= lbase)					{						MoveTo(4, v);						sprintf(buff,"Saved Register: %1.1x       0x%8.8x ", r, saved_vax_register);						DrawText(buff,(short)0,(short) strlen(buff));						v += line_size;					}					if(++lineno > last_line)						break;				}			if(lineno > last_line)				break;			tmp_SP |= xxx.xx.spa;	/*drop stack alignment*/		//	saved_PSW = xxx.xx.psw & BYTE_MASK;			if(xxx.xx.SorG)			{				number_of_args = vax_fetchl(tmp_SP);				tmp_AP = tmp_SP + ((number_of_args & BYTE_MASK) * 4 + 4); /*was a calls instruction pop the arguments*/				tmp_SP += 4;				if(lineno >= lbase)				{					MoveTo(4, v);					sprintf(buff,"Number of Arguments:    0x%8.8x ", number_of_args);					DrawText(buff,(short)0,(short) strlen(buff));					v += line_size;				}				if(++lineno > last_line)					break;				while(tmp_SP != tmp_AP)				{					if(lineno >= lbase)					{						MoveTo(4, v);						sprintf(buff,"Argument: 0x%8.8x    0x%8.8x ",tmp_SP, vax_fetchl(tmp_SP));						DrawText(buff,(short)0,(short) strlen(buff));						v += line_size;					}					tmp_SP += 4;					if(++lineno > last_line)						break;				}				if(lineno > last_line)					break;			}		//	if(xxx.xx.psw & HI_BYTE_MASK)		//	{	/*manual says these bits must be zero*/		//	}		}		if(clicked_line >= lbase && clicked_line <= last_line)			stackw_draw_r_cursor();	}	SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;}void activate_stack_window(	long is_active){#pragma unused(is_active)}void set_maxscroll_stackw(unsigned short  nlines){	nlines = 4096; //Random number giving 16K of scrollable stack.	SetCtlMin(stackWindow.vScroll, 0); 	SetCtlValue(stackWindow.vScroll,1);	SetCtlMax(stackWindow.vScroll, nlines); 	if(stackWindow.theOrigin.v > nlines)		stackWindow.theOrigin.v = nlines;	clicked_line = -1;}void set_stack(short mode, int perminant){short control_value;	switch(perminant)	{	case 0:		follow_stack = 1; 		displayed_stack = IS ? 4:CMD;		control_value = displayed_stack | 8;		break;	case 1:		follow_stack = 0; 		control_value = displayed_stack = mode;		break;	default:		if(follow_stack == 1)		{			displayed_stack = IS ? 4:CMD;			control_value = displayed_stack | 8;		}		else			control_value = displayed_stack;		break;	}		SetCtlValue(stackWindow.hScroll, control_value  );		if(perminant != 2)		update_stack_window();}