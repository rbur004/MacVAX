#include <types.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<StdLib.h>#include	<String.h>#include	<StdIO.h>#define __SYSW_C_#include "main.h"#include "window.h"#include "mmemory.h"#include "defines.h"#include "sysw.h"#include "aprintf.h"#include "progw.h"#include "vax_to_68000.h"#include "docmds.h"void sysw_click(	Point *p,	short modifiers){#pragma unused(p)#pragma unused(modifiers)}static void draw_r_cursor(void){}void sysw_keypress(	long key){#pragma unused(key)}void sysw_undo_keypress(void){}static char *sysDisp[] = {	"KSP: ","ESP: ","SSP: ","USP: ",							"R0:  ","R1:  ","R2:  ","R3:  ","R4:  ","R5:  ","R6:  ","R7:  ",							"R8:  ","R9:  ","R10: ","R11: ","AP:  ","FP:  ","PC:  ","PSL: ",							"P0BR:","P0LR:","P1BR:","P1LR:"						  };							void update_sys_window(void){RgnHandle	hold_h;long i;unsigned long j;real_page_entry PageTable_ent;char buff[64];register short line_size =  sysWindow.lsize;register short v = line_size;GrafPtr savePort;address pcbb = IPR(PCBB);address a;long p1_pages;short lbase;short last_line; short lineno = 0;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long 	hold_saw_watch_point = saw_watch_point;	if( ((WindowPeek) (sysWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(sysWindow.windowptr);		exceptions_on = 0;	stop = 1;		hold_h = NewRgn();	GetClip(hold_h);	ClipRect(&sysWindow.usable);		lbase = sysWindow.theOrigin.v ;	last_line = sysWindow.nlines + lbase;		if(lbase == lineno)	{		MoveTo(4, v);		sprintf(buff,"%s", "Process Control Block:");		DrawText(buff,(short)0,(short) strlen(buff));		v += line_size;	}	lineno++;		/*do process control Block*/	for(i = 0; i < 20; i += 2)	{		if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4, v);			sprintf(buff,"%s 0x%8.8x    ", sysDisp[i],vax_fetchliR(pcbb) );			pcbb += 4;			sprintf(&buff[COLUMN1+5],"%s  0x%8.8x    ", sysDisp[i+1], vax_fetchliR(pcbb)  );			pcbb += 4;			DrawText(buff,(short)0,(short) strlen(buff));			v += line_size;		}		else			pcbb += 8;		lineno++;	}		if(lineno >= lbase && lineno <= last_line)	{		MoveTo(4, v);		sprintf(buff,"%s 0x%8.8x    ", sysDisp[i],vax_fetchliR(pcbb) );		pcbb += 4;		sprintf(&buff[COLUMN1+5],"%s 0x%2.2x %6.6x   ", sysDisp[i+1], fvax_fetchbR(pcbb + 3),vax_fetchliR(pcbb) & 0xffffff );		pcbb += 4;		DrawText(buff,(short)0,(short) strlen(buff));		i += 2;		v += line_size;	}	else		pcbb += 8;	lineno++;		if(lineno >= lbase && lineno <= last_line)	{		MoveTo(4, v);		sprintf(buff,"%s 0x%8.8x    ", sysDisp[i],vax_fetchliR(pcbb) );		pcbb += 4;		sprintf(&buff[COLUMN1+5],"%s 0x%2.2x %6.6x   ", sysDisp[i+1], fvax_fetchbR(pcbb + 3),vax_fetchliR(pcbb) & 0xffffff );		pcbb += 4;		DrawText(buff,(short)0,(short) strlen(buff));		i += 2;		v += line_size;	}	else		pcbb += 8;	lineno++;	if(IPR(MME))	{		if(lineno >= lbase && lineno <= last_line)		{			v += line_size;		}		lineno++;		if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4, v);			DrawString((void *)"\pSystem Page Table:");			v += line_size;		}		lineno++;				if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4 + 12 * CharWidth('0'), v);			DrawString((void *)"\pV P M Z O S  PFN");			v += line_size;		}		lineno++;				a = IPR(SBR);		for(j = 0; j < IPR(SLR); j++)		{			if(lineno >= lbase && lineno <= last_line)			{				MoveTo(4, v);				vax_fetchptR( a, 0, &PageTable_ent);				sprintf(buff,"0x%8.8X: %1.1X %1.1X %1.1X %1.1X %1.1X %1.1X %6.6X 0x%8.8X",a,				PageTable_ent.valid, PageTable_ent.protection, PageTable_ent.modified,				PageTable_ent.mbz, PageTable_ent.own, PageTable_ent.s, PageTable_ent.pfn,PageTable_ent);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			a += sizeof(long);			lineno++;		}				if(lineno >= lbase && lineno <= last_line)		{			v += line_size;		}		lineno++;				if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4, v);			DrawString((void *)"\pP0 Page Table:");			v += line_size;		}		lineno++;				if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4 + 12 * CharWidth('0'), v);			DrawString((void *)"\pV P M Z O S  PFN");			v += line_size;		}		lineno++;				a = IPR(P0BR);		for(j = 0; j < IPR(P0LR); j++)		{			if(lineno >= lbase && lineno <= last_line)			{				MoveTo(4, v);				PageTable_ent = vax_fetchpt( a, 0);				sprintf(buff,"0x%8.8X: %1.1X %1.1X %1.1X %1.1X %1.1X %1.1X %6.6X  0x%8.8X",a,				PageTable_ent.valid, PageTable_ent.protection, PageTable_ent.modified,				PageTable_ent.mbz, PageTable_ent.own, PageTable_ent.s, PageTable_ent.pfn,PageTable_ent);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			a += sizeof(long);			lineno++;		}				/*Next check the P1 space*/		if(lineno >= lbase && lineno <= last_line)		{			v += line_size;		}		lineno++;				if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4, v);			DrawString((void *)"\pP1 Page Table:");			v += line_size;		}		lineno++;				if(lineno >= lbase && lineno <= last_line)		{			MoveTo(4 + 12 * CharWidth('0'), v);			DrawString((void *)"\pV P M Z O S  PFN");			v += line_size;		}		lineno++;				a = IPR(P1BR) + (IPR(P1LR) << 2);		p1_pages = TOTAL_P1_PAGES; 		while(p1_pages-- > IPR(P1LR))		{			if(lineno >= lbase && lineno <= last_line)			{				MoveTo(4, v);				PageTable_ent = vax_fetchpt( a, 0);				sprintf(buff,"0x%8.8X: %1.1X %1.1X %1.1X %1.1X %1.1X %1.1X %6.6X, 0x%8.8X",a,				PageTable_ent.valid, PageTable_ent.protection, PageTable_ent.modified,				PageTable_ent.mbz, PageTable_ent.own, PageTable_ent.s, PageTable_ent.pfn,PageTable_ent);				DrawText(buff,(short)0,(short) strlen(buff));				v += line_size;			}			a += sizeof(long);			lineno++;		}	}	SetClip(hold_h);	DisposeRgn(hold_h);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;}void activate_system_window(	long is_active){#pragma unused(is_active)}void set_maxscroll_sysw(void){unsigned short nlines = 13;	if( IPR(MME) )		nlines += 9 + IPR(SLR) + IPR(P0LR) + (TOTAL_P1_PAGES - IPR(P1LR));	SetCtlMax(sysWindow.vScroll, nlines); 	if(sysWindow.theOrigin.v > nlines)		sysWindow.theOrigin.v = nlines;}