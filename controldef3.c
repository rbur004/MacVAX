#include	<types.h>#include	<quickdraw.h>#include 	<fonts.h>#include	<controls.h>#include	<resources.h>#include	<packages.h>#include 	"controldef.h"pascal longStackButtonArray(	short varCode,	ControlHandle theControl,	short message,	long param){#pragma unused (varCode)Rect pr; 							/*Picture Rectangle*/Rect cr; 							/*control Rectangle*/Rect dr; 							/*destination rectangle*/RgnHandle rgnH;Point *p;static void itoa(register short i, char *p);	if((*theControl)->contrlData == 0) 		(*theControl)->contrlData = GetResource ( 'PICT',(short) STACK_BUTTON_ARRAY_RID );	pr = ( ( (PicPtr)( *( (*theControl)->contrlData ) ) )->picFrame );	cr = (*theControl)->contrlRect;	dr = cr;		/*zero origin of picture rectangle*/	pr.right -= pr.left;	pr.bottom -= pr.top;	pr.left = 0;	pr.top = 0;		/*calculate destination rectangle*/	dr.left = dr.right - pr.right;		switch(message)	{	case drawCntl:		if((*theControl)->contrlVis)		{			rgnH = NewRgn();			GetClip(rgnH);			ClipRect(&cr);			if((*theControl)->contrlHilite < 254 )			{				switch(param & 0xFFFF)				{				case inKStack:				case inEStack:				case inSStack:				case inUStack:				case inIStack:				case inCStack:				case 129:				case 0: /*draw all of control*/				default:					DrawPicture((PicHandle)((*theControl)->contrlData), &dr );					break;				}				switch((*theControl)->contrlHilite)				{				case inKStack:				case inEStack:				case inSStack:				case inUStack:				case inIStack:					if((((*theControl)->contrlValue & 0x07) + sba1_base) != (*theControl)->contrlHilite)					{						dr.left += (short)((*theControl)->contrlHilite - sba1_base) * (short)15;						dr.right = dr.left + 15;						dr.top += 1;								InvertRect(&dr);					}					break;				case inCStack:					if( ((*theControl)->contrlValue & 0x08) == 0)					{						dr.left += (short)((*theControl)->contrlHilite - sba1_base) * (short)15;						dr.right = dr.left + 15;						dr.top += 1;								InvertRect(&dr);					}					break;				case 129: /*thumb*/					break;				case 0: /*No Highlight*/				default:					break;				}				dr = cr;				dr.left = dr.right - pr.right;				dr.top += 1;						if((*theControl)->contrlValue & 0x08)				{					dr.left += (short)(5) * (short)15;					dr.right = dr.left + 15;					InvertRect(&dr);				}								dr = cr;				dr.left = dr.right - pr.right;				dr.top += 1;						dr.left += (short)((*theControl)->contrlValue & 0x07) * (short)15;				dr.right = dr.left + 15;				InvertRect(&dr);			}			else			{				EraseRect(&dr);				FrameRect(&dr);			}			SetClip(rgnH);			DisposeRgn(rgnH);		}						return 0;		case testCntl: /*which part of control*/		if((*theControl)->contrlVis)		{			p = (Point *) &param;			if(PtInRect(*p, &dr))				return ((short)(p->h - dr.left) / (short)15) + sba1_base;		}		return 0;		case calcCRgns: /*returns region occupied by Control 24 bit call only*/		/*param is a region handle */		/*Param hit bit set means indicator only*/		param &= 0x00FFFFFF; /*needed for 24bit mode. One tech note suggests using 7FFFFFFF*/		/*	Debugger(); */	case calcThumbRgn: /*returns region occupied by Control 32 bit call*/	case calcCntlRgn: /*returns region occupied by Control 32 bit call*/		if(dr.right > cr.right)			dr.right = cr.right;		if(dr.bottom > cr.bottom)			dr.bottom = cr.bottom;		RectRgn((RgnHandle) param,&dr);		return 0;		case initCntl: /*Initialize control*/		/*(*theControl)->contrlData = GetResource ( 'PICT',(short) STACK_BUTTON_ARRAY_RID );*/		(*theControl)->contrlValue = 0;		return 0;		case dispCntl: /*release any private memory*/		if((*theControl)->contrlData != 0) 			ReleaseResource((*theControl)->contrlData);		return 0;		case posCntl: /*shift indicator*/		return 0;		case thumbCntl: /*calc slop and limiting rects*/		return 0;		case dragCntl: /*drag indicator or whole control*/		return 0;		case autoTrack: /*track control function*/		/* must do param &= 0xFFFF; if using param*/		return 0;		default:		return 0;	}	}