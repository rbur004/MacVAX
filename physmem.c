#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>//#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<StdIO.h>#define __PHYSMEM_C_#include "window.h"#include "main.h"#include "physmem.h"#include "mmemory.h"#include "docmds.h"#pragma segment PHYSMEMWINDOWvoid physmemw_goto(	register address a){register address lbase;register address new_cline;	if(a >= REAL_MEM_SIZE)	{		SysBeep(5);		return;	}	lbase = a / (unsigned long)16;	new_cline = lbase * (unsigned long)16;	physmemWindow.theOrigin.v = lbase;	SetCtlValue(physmemWindow.vScroll, physmemWindow.theOrigin.v);	*((unsigned long *)(&physmemw_cline)) = new_cline;	physmemw_cbyte = a - (unsigned)new_cline;	if(physmem_in_ascii)	{		physmemw_byte = physmemw_cbyte + ASCII_START;		physmemw_cshift = 0;	}	else	{		physmemw_byte = physmemw_cbyte * 3 + 1;		physmemw_cshift = 4;	}	update_memdisplay(NOTREG);}void physmemw_click(	Point *p,	short modifiers){#pragma unused(p)#pragma unused(modifiers)		SysBeep(5);}static void draw_p_cursor(	short v){#pragma unused(v)}static void draw_p_watches(	char *box,	short v){register long i;register long cw = CharWidth('0');register short line_size =  physmemWindow.lsize;Rect physmemw_r;	for(i = 1; i < ASCII_START; i += 3)	{		if(*box++)		{			physmemw_r.left = (i * cw) + (cw * 8) + 3;			physmemw_r.right = physmemw_r.left + cw + cw + 2;			physmemw_r.bottom = v + physmemWindow.forigin;						physmemw_r.top	= physmemw_r.bottom - line_size;			physmemw_r.bottom -= physmemWindow.leading;			FrameRect(&physmemw_r);		}	}}address get_c_pos_phys(void){	if(physmemw_cline == -1)		return ERROR;	else		return (physmemw_cline + physmemw_cbyte);}void physmemw_keypress(	long key){#pragma unused(key)	SysBeep(5);}void physmemw_undo_keypress(void){}void update_physmem_window(void){char buff[68]; /*48 for printing 16 hex numbers , 17 for 16 chars*/long i;long j;long w;long c;RgnHandle	hold_p;register long cw;register address lbase;register short line_size = physmemWindow.lsize;register short v = line_size + line_size;register short column1;long k;Rect r,l;char box[16];GrafPtr savePort;long	hold_stop = stop;long	hold_exceptions_on = exceptions_on;long	hold_saw_watch_point = saw_watch_point;	if( ((WindowPeek) (physmemWindow.windowptr))->visible == false )		return;	GetPort(&savePort);	SetPort(physmemWindow.windowptr);	exceptions_on = 0;	stop = 1;	cw = CharWidth('0');	column1 = cw * 8 + 4;		hold_p = NewRgn();	GetClip(hold_p);	ClipRect(&physmemWindow.usable);	PenNormal();	MoveTo(column1 + cw ,line_size - physmemWindow.forigin);	drawstring(" 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F");	MoveTo(4 ,line_size - 1);	w =  cw * 56 ;	PenSize(1,2);	Line(w,0);	PenNormal();	lbase = physmemWindow.mbase = physmemWindow.theOrigin.v * 16;	r = physmemWindow.usable;	r.right = column1;	ClipRect(&r);	for(i = 0; i <= physmemWindow.nlines; i++)	{		if(lbase >= REAL_MEM_SIZE)		{			l.top = v - line_size + physmemWindow.forigin;			l.bottom = physmemWindow.usable.bottom;			l.right = column1;			l.left = 0;			EraseRect(&l);			break;		}		sprintf(buff,"%8.8x",lbase);		MoveTo(4,v);		DrawText(buff,(short)0,(short)8);		lbase += 16;		v += line_size;	}	lbase = physmemWindow.mbase;	v = line_size + line_size;	r.right = physmemWindow.usable.right;	r.left = column1 + 2;	ClipRect(&r);		for(i = 0; i <= physmemWindow.nlines; i++)	{		if(lbase >= REAL_MEM_SIZE)		{			l.top = v - line_size + physmemWindow.forigin;			l.bottom = physmemWindow.usable.bottom;			l.left = column1;			l.right = physmemWindow.usable.right;			EraseRect(&l);			break;		}		for(j = 0,k = 0; j < 16; j++, k += 3)		{				saw_watch_point = 0;			sprintf(&buff[k]," %2.2X", c = (((long) fvax_fetchbR(lbase + j)) & BYTE_MASK));			buff[j+ASCII_START] = (c < 0x7f && c > 0x1F) ? c:0xff;			box[j] = saw_watch_point;		}		buff[ASCII_START-1] = ' ';		MoveTo(column1, v);		DrawText(buff,(short)0,(short)ASCII_END + 1);		if(lbase == physmemw_cline)			draw_p_cursor(v);		draw_p_watches(box,v);		lbase += 16;		v += line_size;	}	SetClip(hold_p);	MoveTo(column1 ,0);	PenSize(2,1);	Line(0,physmemWindow.usable.bottom);	PenNormal();	DisposeRgn(hold_p);	SetPort(savePort);	stop = hold_stop;	exceptions_on = hold_exceptions_on;	saw_watch_point = hold_saw_watch_point;}void activate_physmem_window(	long is_active){short i;	if(is_active)	{		for(i = CodeStartCommand; i <= PCBBCommand; i++)			DisableItem(MyMenus[ToMenu], i);	}	else	{		for(i = CodeStartCommand; i <= PCBBCommand; i++)			EnableItem(MyMenus[ToMenu], i);	}}void physmem_init(void){	physmemWindow.tlines = REAL_MEM_SIZE / 16;	SetCtlMax(physmemWindow.vScroll, physmemWindow.tlines); 	physmemWindow.theOrigin.v = 0;}