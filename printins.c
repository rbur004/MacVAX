#include	<types.h>#include	<quickdraw.h>#include	<StdIO.h>#define _PRINTINS_C_#include    "globals.h"#include	"instrs.h"#include 	"mmemory.h"#include 	"printins.h"#include	"sym.h"#include	"aprintf.h"#include	"wprintf.h"#include	"vax_to_68000.h"/******************************************************************************//*                                                                            *//*                  I N S T R U C T I O N     P R I N T E R                   *//*                                                                            *//******************************************************************************/#pragma segment	PRINTINSstatic void printfloat( 	v_float f){	    wprintf( "%e", f2e(f) );}static void printdfloat(	quad df){	printquad( df );}static void printgfloat(	quad gf){	printquad( gf );}static void printhfloat(	oct hf){	printocta( hf );}static void printquad(	quad q){	wprintf("0x%8.8X%8.8X", q.long1, q.long0 );}static void printocta(	oct o){	wprintf("0x%8.8X%8.8X%8.8X%8.8X", o.long3, o.long2, o.long1, o.long0);}char *xfc_function_name(int mode){   static char *LowNames[]={"READCHAR","WRITECHAR","READLINE","WRITESTRING","AHTOI",   							"ADTOI","ITOAH","ITOAD","OPEN_MAC_FILE","CREATE_MAC_FILE","CLOSE_MAC_FILE",							"READ_MAC_FILE","WRITE_MAC_FILE","SEEK_MAC_FILE",							"UPDATE_WINDOWS",							"PROG_TO_FRONT","REG_TO_FRONT","MEML_TO_FRONT","IO_TO_FRONT","MEM_TO_FRONT",							"PROG_CLOSE","REG_CLOSE","MEML_CLOSE","IO_CLOSE","MEM_CLOSE",							"ALLOC_MEM","FREE_MEM","CLEAR_IOW","MAC_TIME","OPEN_NAMED_FILE","GET_FILENAME_FD",							"FIND_FILE","GET_DIR_ID","GET_ADIR_ID","GET_CDIR_ID"};   static char *SysNames[]={"SYSTEM","REBOOT","CREATE_USER_SYMBOL_TABLE","CREATE_SYS_SYMBOL_TABLE",   							"FREE_SYMBOL_TABLE","USE_USER_SYMBOL_TABLE","GET_FILENAME_PD","DISPLAY_DIALOG",							"CLEAR_WATCHPOINTS","SET_WATCHPOINTS","DUP_USER_SYMBOL_TABLE"};   char temp[32];				   if(mode>=0 && mode<=34)   	   return(LowNames[mode]);   else if(mode>=128 && mode<=137)   		return(SysNames[mode-128]);   else {   	sprintf(temp,"Unknown system call (%d)",mode);	return(temp);   }}address printins(	address dot){register long argno;register long   mode;			/* mode */char  **r;						/* register name */register long   d;				/* assembled byte, word, long or float */register char  *ap;	/*pointer to argument discription part of the optab entry for this instruction*/OPTAB ip;						/*pointer to the optab entry for this instruction*/long ins;char *indexed;quad temp_quad;	/* RTB 8/7/93 ludicrous hack required because gc is unable to correctly */oct temp_oct;	/* return structures (of greater size than longs) from subroutines */				/* see case TYPQ: and case TYPO: (also TYPD,TYPG,TYPH) */				/* for examples of their use */    jump_address = U_MAX_LONG;	comment = 0;		ins = bget(dot++);					/*get instruction*/	if ( Procentry )	{	long comma = 0;	register long mask;	long i;			d = ins  | ( bget(dot++) << 8);		wprintf(".enter ^M<");		mask = 1;		for(i = 0; i < 12 ; i++)		{			if(mask & d)			{				if(comma) 					wputchar(',');				wprintf("r%d",i);				comma = 1;			}			mask <<= 1;		}		if(d & 0x4000)		{			if(comma) 				wputchar(',');			wprintf("iv");			comma = 1;		}		if(d & 0x8000)		{			if(comma) 				wputchar(',');			wprintf("dv");			comma = 1;		}		wputchar('>');		wprintf(hexmode ? " /* (0x%4.4x) ":						  " /* (%u) ", d);		if(d & 0x3000)		{			wprintf("Illegal Procedure Entry Mask. Bits 12 and 13 must be zero.*/");		}		else			wprintf("Procedure Entry Mask.*/");				Was_case = 0;		return (dot);	}	if( DotWord 	|| (Was_case && var[ 2 ] != LONG_HI_BIT && Was_case <= var[ 2 ] + 1))	{		d = (long)((word)ins  | (word)( bget(dot++) << 8));		if(Was_case)		{			jump_address = base_case+d;			psymoff(jump_address);			Was_case++;		}		else			wprintf(hexmode ? ".word  0x%4.4x":".word  %u", d & WORD_MASK);		return (dot);	}    ip = optab + ioptab[ ins ];		/*set up pointer to op table entry for instruction*/    wprintf("%s  ", ip->iname );	/*print out instruction name*/    ap = ip->argtype;				/*set up pointer to op table entry for the argument type*/    for ( argno = 0; argno < ip->nargs; argno++, ap++ ) 	{	/*for each arg expected*/        var[ argno ] = LONG_HI_BIT;			indexed = (char *)0;        if ( argno != 0 )            wputchar( ',' );			/*seperate args with commas*/top:        if ( *ap & ACCB )			/* branch displacement */            mode = 0xAF + ( (*ap & NIBBLE_MASK) << 5 );			/*will give modes of AF for byte -> A with PC (F) as reg 								 CF	for word -> C with PC (F) as reg								 EF for long -> E with PC (F) as reg */        else 		{            mode = bget( dot++ );        }        if ( mode & 0300 ) {          /* not short literal */            r = &reglist[  (( MAXREGS - 1 ) - ( mode & NIBBLE_MASK )) ];            mode >>= 4;            switch ( mode ) 			{                case 4:           /* [ r ] */					if(indexed || r == ARPC) /*not allowed to use pc as index reg*/					{						comment += sprintf(&comment_buff[comment]," Arg%d: Reseverd Address Mode Fault,",argno);						if(indexed)						{							comment += sprintf(&comment_buff[comment]," Cannot index an index.");						}						if(r == ARPC)						{							comment += sprintf(&comment_buff[comment]," Cannot use PC as index register.");							if(!indexed)								indexed = *r; /*Indexed Register. to be printed later*/						}						goto top;					}					indexed = *r; /*Indexed Register. to be printed later*/					goto top;                case 5:           /* r */					if(indexed || (*ap & ACCA)) /*not allowed to use pc as index reg*/					{						comment += sprintf(&comment_buff[comment]," Arg%d: Reseverd Address Mode Fault,",argno);						if(indexed)							comment += sprintf(&comment_buff[comment]," Cannot use register mode with index mode.");						if(*ap & ACCA)							comment += sprintf(&comment_buff[comment]," Cannot get address of a register.");					}                    wprintf( "%s", *r );                    break;/*register*/                case 6:           /* ( r ) */                    wprintf("(%s)", *r );/*Register defered.*/					break;                case 7:           /* -( r ) */                    wprintf("-(%s)", *r );					break;                case 9:           /* *( r )+   or PC Absolute*/                    wputchar( '@' ); /*vms @ rather than ultrix * */				case 8:           /* ( r )+   or PC immediate */                    if ( r == ARPC )					{                        wputchar( '#' );                        /* PC absolute, always 4 bytes */                        if ( mode == 9 ) 						{							d = vax_fetchl(dot);							dot += 4;                             goto disp;                        }                        switch( *ap & NIBBLE_MASK ) 						{                            case TYPB:                                var[ argno ] = d = (long) vax_fetchb(dot);								dot++;								if (ins == 0xFC)									wprintf("%s",xfc_function_name(d&BYTE_MASK));								else									wprintf(hexmode ? "0x%2.2x":"%u",d&BYTE_MASK);								break;								                            case TYPW:                                var[ argno ] = d = (long) vax_fetchw(dot);								dot += 2;                          		wprintf(hexmode ? "0x%4.4x":"%u",d&WORD_MASK);								break;								                            case TYPL:                                var[ argno ] = d = vax_fetchl(dot);								dot += 4;                                wprintf(hexmode ? "0x%8.8x":"%u",d);								break;								                            case TYPQ:							/* RTB 8/7/93 note that if we don't copy the temp value into */							/* temp_quad gc stuffs up */							/* Here is the original:- */							/* printquad(vax_fetchq(dot)); */                                printquad(temp_quad = vax_fetchq(dot));								dot += 8;                                break;                            case TYPO:							/* RTB 8/7/93 note that if we don't copy the temp value into */							/* temp_oct gc stuffs up */							/* Here is the original:- */							/* printocta( vax_fetcho(dot)); */                                printocta( temp_oct = vax_fetcho(dot));								dot += 16;                                break;                            case TYPF:                                printfloat( vax_fetchf(dot) );								dot += 4;                                break;                            case TYPD:								/* RTB 8/7/93 see case TYPQ for why we need to hack */                                printdfloat( temp_quad = vax_fetchq(dot));								dot += 8;                                break;								                            case TYPG:								/* RTB 8/7/93 see case TYPQ for why we need to hack */                                printgfloat( temp_quad = vax_fetchq(dot));								dot += 8;                                break;								                            case TYPH:								/* RTB 8/7/93 see case TYPO for why we need to hack */                                printhfloat( temp_oct = vax_fetcho(dot));								dot += 16;                                break;                         } /* End of type switch */                        						if( (*ap & ACCW) && ! indexed && mode == 8)						{							comment += sprintf(&comment_buff[comment]," Arg%d: Warning, writing to an immediate value.",argno);							wprintf("/*(PC)+*/");						}                    }                    else  /* It's not PC immediate or abs : It's just (r)+ */                    {						wprintf( "(%s)+", *r );					}					break;                case 0xB:           /* byte displacement defferred */                    wputchar( '@' ); /*@ rather than * */                case 0xA:           /* byte displacement */                    d = (long) vax_fetchb(dot);					dot++;                    goto disp;                case 0xD:           /* word displacement deferred */                    wputchar( '@' ); /*@ rather than * */                case 0xC:           /* word displacement */                    d = (long) vax_fetchw(dot);					dot += 2;                    goto disp;                case 0xF:           /* long displacement deferred */                    wputchar( '@' );                case 0xE:           /* long displacement */                    d = vax_fetchl(dot);					dot += 4;                    goto disp;					disp:/*displacement is in variable d .*/                var[ argno ] = d;               if ( (r == ARPC )  )				{                    /* PC offset addressing */					if(mode >= 0xA)                    	var[ argno ] += dot;                    psymoff(var[ argno ]);					if(*ap & (ACCA | ACCB))						jump_address = var[ argno ];                }                if ( r != ARPC )                    wprintf(hexmode ? "0x%x(%s)":"%d(%s)", d, *r );                break;                } /* end of the mode switch */        }        else		{   /* short literal */            var[ argno ] = mode;            if ( (*ap & NIBBLE_MASK ) == TYPF || (*ap & NIBBLE_MASK ) == TYPD )			{#ifdef TEST_FLOAT_CODE			extern extended flt_imm[64];			v_float xxx;				xxx.f = e2f( flt_imm[ mode ] );				wprintf( "#" );				printfloat(xxx);				comment += sprintf(&comment_buff[comment],"As stored (item %d): %e ",mode, flt_imm[ mode ]); #else               wprintf( "#%s", fltimm[ mode ] );#endif			}            else			{				if(indexed || (*ap & (ACCA | ACCW)) ) /*Not permitted with short literals*/				{					comment += sprintf(&comment_buff[comment]," Arg%d: Reseverd Address Mode Fault,",argno);					if(indexed)						comment += sprintf(&comment_buff[comment]," Cannot use short literal with index mode.");					else if( *ap & ACCA )						comment += sprintf(&comment_buff[comment]," Cannot get address of a short literal.");					else						comment += sprintf(&comment_buff[comment]," Cannot write to a short literal.");				}                wputchar( '#' ); /*vms # rather than ultrix $*/             	if ( !indexed 				&&  (  (ins == MTPR && argno == 1 )				 	|| (ins == MFPR && argno == 0 ) )				&& mode < NUM_IPRS )					wprintf("%s",internal_processor_registers[mode]);				else if (!indexed && ins == 0xFC /* && argno == 1 */)					  wprintf("%s",xfc_function_name(mode));				else {					if(hexmode)                		printhex(mode);					else						printdec(mode);				}			}        }		if(indexed)			 wprintf( "[%s]", indexed );    }	if(comment)		wprintf(" /*%s*/",comment_buff);	if ( ins == 0xCF || ins == 0xAF || ins == 0x8F )	 /* CASEx instr */	{		Was_case = 1;		base_case = dot;	}	else		Was_case = 0;       return dot;}address get_branch_dest(void){	return jump_address;}void display_comment(void){	aprintf("%s", comment_buff);}