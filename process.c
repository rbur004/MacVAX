#include	<types.h>#include	<quickdraw.h>//#include	<desk.h>#include	<menus.h>#define _PROCESS_C_#include "mmemory.h"#include "macio.h"#include "symbol_tab.h"#include "process.h"#include "macdev.h"#include "vaxmacio.h"#include "progw.h"#include "window.h"#include "func.h"#include "aprintf.h"#include "iow.h"#include "main.h"#include "docmds.h"void new_process(	/*create a new process in p0 space*/	MFILE *new_fsym){	if(is_a_system)	{ /*If there is a system then pass the buck*/		set_macvax_interrupt(NEW_PROCESS);		return;	}		if(new_fsym == (MFILE *) 0 && (new_fsym = mopen("AOUT")) == 0)	{			return;	}	/*If already have a process running*/	/*Kill it*/	terminate_process();	/*kill any running process*/		/*Get a new process descriptor*/	if((local_process_desc = create_symbol_table(new_fsym,0)) < 0 )	{		aprintf("new_process: Invalid process descriptor:%d\nAborted load (1).",local_process_desc);		mclose(new_fsym);		return;	}		/*set it as the current P0 descriptor*/	if(use_user_symbol_table(local_process_desc) < 0)	{		aprintf("new_process: Invalid process descriptor:%d\nAborted load (2).",local_process_desc);		mclose(new_fsym);		return;	}			alloc_sys_space();	/*reset up system space*/	alloc_p1_space();	/*reset up the stacks*/	if(load_process_P0(current_process) == -1)		terminate_process();		  /*Blat all of memory*/	else			fake_a_pcb();		mclose(new_fsym);	/*Don't keep file open as AS might want to write to it*/}void terminate_process(void){	if(is_a_system)	{ /*If there is a system then pass ithe buck*/		set_macvax_interrupt(KILL_PROCESS);		return;	}	if(local_process_desc)	{	/*Do have a process running*/		/*halt the processor*/		stop_writes = 0;		exceptions_on = 0;		stop = 1;		/*Kill it*/		free_symboltable(local_process_desc);		closeall_mac_files(); /*files opened within the simulator*/		local_process_desc = 0;	}		freeallmem(1);	/*blat all of VAX memory and watch points*/}	void terminate_all_processes(void){	is_a_system = 0;	local_process_desc = 0;	/*halt the processor*/	stop_writes = 0;	exceptions_on = 0;	stop = 1;	/*free things*/	free_all_symboltable();	closeall_mac_files(); /*files opened within the simulator*/	freeallmem(1);	/*blat all of VAX memory and watch points*/}	void reset_current_proc(void){MFILE *new_fsym;	if(is_a_system)	{ /*If there is a system then pass the buck*/		set_macvax_interrupt(RESET_PROCESS);		return;	}		if(local_process_desc)	{			if((new_fsym = mopen_na(current_process->name,current_process->vrefnum)) == (MFILE *) 0)		{	aprintf("Reset of %s Failed", current_process->name);			return;		}					/*Kill Running process */		terminate_process();	/*kill any running process*/				/*Get a new process descriptor*/		if((local_process_desc = create_symbol_table(new_fsym,0)) < 0 )		{			aprintf("new_process: Invalid process descriptor:%d\nAborted load (1).",local_process_desc);			mclose(new_fsym);			return;		}				/*set it as the current P0 descriptor*/		if(use_user_symbol_table(local_process_desc) < 0)		{			aprintf("new_process: Invalid process descriptor:%d\nAborted load (2).",local_process_desc);			mclose(new_fsym);			return;		}					alloc_sys_space();	/*reset up system space*/		alloc_p1_space();	/*reset up the stacks*/		if(load_process_P0(current_process) == -1)			terminate_process();		  /*Blat all of memory*/		else				fake_a_pcb();				mclose(new_fsym);	/*Don't keep file open as AS might want to write to it*/	}	else		terminate_all_processes();		  /*Blat everything*/}void fake_a_pcb(void){	/* Sets up SP, CMD, PCB, IS and IPL*/	SP = IPR(ISP);	IS = 1;	SP -= 4;	vax_putl(USERPSL,SP);	/*push a PSL*/	SP -= 4;		if(current_process)		vax_putl(current_process->entrypt,SP);	/*push the entry point for the prog*/	else		vax_putl(0,SP); /*Don't know entry point so push a 0*/			IPR(P0LR) |= IPR(ASTR) << 24;	svpctx("svpctx");			/*this will fill in PCB and pop 2 longs from the VAX STACK*/	IPR(P0LR) &= PAGE_LENGTH_MASK;	/*ldpctx("ldpctx");*/	vax_regs[14].contents.as_ulong  = IPR(USP); /*stack pointer to top of stack*/	CMD = PMD = USP;				  /*start in user mode*/	IS = 0;	IPL = 0;}long load_process_P0(	Symbol_Table_Type *proc){unsigned long i;long left;	/*Code segment*/	if(left = proc->txtsiz) //Yes 1 ='s	{		if(alloc_cd(proc->txtmap.b2 , ( proc->magic == OMAGIC ) ? UW:URKW) == (address) ERROR)		{	aprintf("ABORTED reading code\nClosing file");			return -1;		}				mlseek(proc->fsym->fd, proc->txtmap.f1,0);		for(i = 0; i < proc->txtsiz; i += PAGE_SIZE)		{		char *buff;			if((buff = (char *) mac_address(check_reference(i,KSP,WR,1))) == (char *)ERROR)			{	aprintf("Open Aborted\nAccess to page denied (reading code page %x).",i);				return -1;			}			mread(proc->fsym->fd,buff, (left < PAGE_SIZE) ? left:PAGE_SIZE);			left -= PAGE_SIZE;		}	}		/*Data Segment*/	if(left = proc->datsiz) //Yes 1 ='s	{		/*Get enough space for data and symbols*/		if(alloc_cd(proc->datsiz + proc->bsssiz , UW) == (address) ERROR)		{	aprintf("ABORTED reading data\nClosing file");			return -1;		}		mlseek(proc->fsym->fd,proc->txtmap.f2,0);		for(i = 0; i < proc->datsiz; i += PAGE_SIZE)		{			char *buff;			if((buff = (char *) mac_address(check_reference(i+proc->txtmap.b2 ,KSP,WR,1))) == (char *)ERROR)			{	aprintf("Open Aborted\nAccess to page denied (reading data page %x).",i);				return -1;			}			mread(proc->fsym->fd,buff, (left < PAGE_SIZE) ? left:PAGE_SIZE);			left -= PAGE_SIZE;		}	}	return 0;}void boot_file(	/*Load a program into Physical memory and execute*/	MFILE *fsym){char *buff;long process_desc;	terminate_all_processes();	/*Kill all the current process*/		setwtitle(progWindow.windowptr, fsym->name);		if(copy_boot_roms(0) == -1) /*Unable to load boot roms*/	{		mclose(fsym);		return;	}			if( (process_desc = create_symbol_table(fsym,0) ) > 0 	&&   use_user_symbol_table(process_desc) == 0 	&&  (buff = (char *) mac_address(0x0)) != (char *)ERROR )	{				mlseek(fsym->fd,current_process->txtmap.f1,0);		mread(fsym->fd,buff,current_process->txtsiz);				if((buff = (char *) mac_address(0x0 + current_process->txtmap.b2)) != (char *)ERROR)		{				mlseek(fsym->fd,current_process->txtmap.f2,0);			mread(fsym->fd,buff,current_process->datsiz);						SP = 0xF000;	/*set stack pointer high*/			PC = current_process->entrypt;			}	}	mclose(fsym);		put_PC_in_progwindow();	clear_io_window();	clear_all_windows();}void boot(){MFILE *fsym;	/* RTB 10/7/93 allows the loading of type boot files */	/* AOUT type could possibly be dropped from the list of openable boot */	/* files at a later date */	if((fsym = mopen("AOUTBOOT")) == 0)		return;		boot_file(fsym);}void binload(	/*Ignore file format and load it into memory*/	void){MFILE *fsym;char *buff;	if((fsym = mopen("")) == 0)		return;	terminate_all_processes();	/*Kill all the current process*/		setwtitle(progWindow.windowptr, fsym->name);	if(copy_boot_roms(0) == -1) /*Unable to load boot roms*/	{	mclose(fsym);		return;	}		mlseek(fsym->fd,0,0);	if((buff = (char *) mac_address(0x0)) == (char *)ERROR)	{	mclose(fsym);		return;	}	mread(fsym->fd,buff,65536);	SP = 0xF000;	PC = 0x0;		put_PC_in_progwindow();	clear_io_window();	clear_all_windows();	mclose(fsym);}void shutdown(void){	if(is_a_system)	{ /*If there is a system then pass the buck*/		set_macvax_interrupt(NEW_PROCESS);	}	DisableItem(MyMenus[fileMenu], (short)shutdownCommand);}